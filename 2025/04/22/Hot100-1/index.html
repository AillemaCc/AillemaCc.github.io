<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Hot100-1 | AllimacBlog</title><meta name="author" content="Allimac"><meta name="copyright" content="Allimac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="lc1 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。  暴力很容易想，直接遍历数组的过程中，检查没有遍历的部分是否存在能和当前数字加和为目标值的数字就可以了。这是因为题目当中有不能使用两次相同">
<meta property="og:type" content="article">
<meta property="og:title" content="Hot100-1">
<meta property="og:url" content="http://example.com/2025/04/22/Hot100-1/index.html">
<meta property="og:site_name" content="AllimacBlog">
<meta property="og:description" content="lc1 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。  暴力很容易想，直接遍历数组的过程中，检查没有遍历的部分是否存在能和当前数字加和为目标值的数字就可以了。这是因为题目当中有不能使用两次相同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2025-04-22T10:22:09.000Z">
<meta property="article:modified_time" content="2025-04-22T10:23:14.005Z">
<meta property="article:author" content="Allimac">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="hot100">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hot100-1",
  "url": "http://example.com/2025/04/22/Hot100-1/",
  "image": "http://example.com/img/avatar.png",
  "datePublished": "2025-04-22T10:22:09.000Z",
  "dateModified": "2025-04-22T10:23:14.005Z",
  "author": [
    {
      "@type": "Person",
      "name": "Allimac",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/faviconcute.png"><link rel="canonical" href="http://example.com/2025/04/22/Hot100-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hot100-1',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/nature_top_image.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">AllimacBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">Hot100-1</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Hot100-1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-22T10:22:09.000Z" title="发表于 2025-04-22 18:22:09">2025-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-22T10:23:14.005Z" title="更新于 2025-04-22 18:23:14">2025-04-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="lc1-两数之和"><a href="#lc1-两数之和" class="headerlink" title="lc1 两数之和"></a>lc1 两数之和</h1><blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<p>暴力很容易想，直接遍历数组的过程中，检查没有遍历的部分是否存在能和当前数字加和为目标值的数字就可以了。这是因为题目当中有<strong>不能使用两次相同的元素</strong>的条件</p>
<p>既然这样，考虑使用hashmap天然去重</p>
<p>一个错误的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现我提前把数组全都put进了map当中，再进行遍历，就有可能让这个数字匹配到自身。这个也可以解决，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将数组中的值和索引存入哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组，寻找符合条件的两个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="comment">// 确保找到的索引不是当前索引</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, index&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，我们可以进一步优化代码，将两次遍历减少为一次遍历。在遍历数组的同时，动态更新哈希表，这样可以避免先存储所有元素再查找的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">complement</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(complement), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>优化版本的关键点</strong></p>
<ol>
<li><strong>为什么不需要判断 <code>index != i</code>？</strong><ul>
<li>在优化版本中，我们在遍历数组的同时动态更新哈希表。</li>
<li>当我们检查 <code>map.containsKey(complement)</code> 时，哈希表中只存储了之前已经遍历过的数字及其索引。</li>
<li>因此，当前数字 <code>nums[i]</code> 不可能与自己匹配，因为 <code>nums[i]</code> 还没有被插入到哈希表中。</li>
</ul>
</li>
<li><strong>时间复杂度和空间复杂度</strong><ul>
<li>时间复杂度：<strong>O(n)</strong>，因为我们只需遍历数组一次。</li>
<li>空间复杂度：<strong>O(n)</strong>，用于存储哈希表</li>
</ul>
</li>
</ol>
<h1 id="lc49-字母异位词分组"><a href="#lc49-字母异位词分组" class="headerlink" title="lc49 字母异位词分组"></a>lc49 字母异位词分组</h1><blockquote>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure></blockquote>
<p>初始思路，可以过测试样例，但有一个很惨的事实，有一个奇怪的样例过不了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> len=strs[i].length();</span><br><span class="line">            String str=strs[i];</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="type">int</span> idx=str.charAt(j)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                res+=idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(res))&#123;</span><br><span class="line">                map.put(res,result.size());</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> index=map.get(res);</span><br><span class="line">            result.get(index).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体来说，字符索引和 <code>res</code> 的计算方式无法唯一标识一组字母异位词。例如，字符串 <code>&quot;ac&quot;</code> 和 <code>&quot;c&quot;</code> 都会产生相同的 <code>res</code> 值（<code>0 + 2 = 2</code>），但它们实际上不属于同一组字母异位词。</p>
<p>尝试使用更准确的唯一键</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] primes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs[i].length();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> str.charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                res *= primes[idx];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(res)) &#123;</span><br><span class="line">                map.put(res, result.size());</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(res);</span><br><span class="line">            result.get(index).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="解答错误121-126-个通过的测试用例"><a href="#解答错误121-126-个通过的测试用例" class="headerlink" title="解答错误121 &#x2F; 126 个通过的测试用例"></a>解答错误121 &#x2F; 126 个通过的测试用例</h3><p>输入</p>
<p>strs &#x3D;</p>
<p>[“aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”,”aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”]</p>
<p>添加到测试用例</p>
<p>输出</p>
<p>[[“aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”,”aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”]]</p>
<p>预期结果</p>
<p>[[“aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”],[“aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”]]</p>
</blockquote>
<ul>
<li>质数乘积法在大多数情况下是有效的，因为它利用了质数的性质来生成唯一的键。</li>
<li>然而，在处理非常长的字符串时，质数乘积可能会导致整数溢出（<code>int</code> 类型的最大值为 <code>2^31 - 1</code>），从而导致相同的键被分配给不同的字符串。</li>
</ul>
<p>直接使用long类型吧孩子们</p>
<p>但是可能超时</p>
<p>好吧，不会超时，但是测试用例更长了，连LONG都不好用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span>[] primes = &#123;<span class="number">2L</span>, <span class="number">3L</span>, <span class="number">5L</span>, <span class="number">7L</span>, <span class="number">11L</span>, <span class="number">13L</span>, <span class="number">17L</span>, <span class="number">19L</span>, <span class="number">23L</span>, <span class="number">29L</span>, <span class="number">31L</span>, <span class="number">37L</span>, <span class="number">41L</span>, <span class="number">43L</span>, <span class="number">47L</span>, <span class="number">53L</span>, <span class="number">59L</span>, <span class="number">61L</span>, <span class="number">67L</span>, <span class="number">71L</span>, <span class="number">73L</span>, <span class="number">79L</span>, <span class="number">83L</span>, <span class="number">89L</span>, <span class="number">97L</span>, <span class="number">101L</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs[i].length();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs[i];</span><br><span class="line">            <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> str.charAt(j) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                res *= primes[idx];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(res)) &#123;</span><br><span class="line">                map.put(res, result.size());</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(res);</span><br><span class="line">            result.get(index).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。哈希表的值为一组字母异位词列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化一个空的 HashMap map。<br> 遍历字符串数组 strs。对第一个字符串 “eat”执行:<br> 将 “eat” 转换为字符数组 [‘e’, ‘a’, ‘t’]<br> 对字符数组进行排序,得到 [‘a’, ‘e’, ‘t’]<br> 使用排序后的字符数组创建 key “aet”<br> 从 map 中获取 key 为 “aet” 的值,由于不存在,因此创建一个新的空列表 list &#x3D; []<br> 将 “eat” 添加到 list 中,现在 list &#x3D; [“eat”]<br> 将 key 为 “aet”,value 为 [“eat”] 的键值对存入 map<br> 对第二个字符串 “tea” 执行类似操作:<br> 字符数组为 [‘t’, ‘e’, ‘a’],排序后为 [‘a’, ‘e’, ‘t’],key 为 “aet”<br> 从 map 中获取 key 为 “aet” 的值,存在,为 [“eat”]<br> 将 “tea” 添加到列表中,现在列表为 [“eat”, “tea”]<br> 将更新后的列表存入 map,key 为 “aet”<br> 对其余字符串 “tan”, “ate”, “nat”, “bat” 执行类似操作,最终 map 为:<br> key 为 “aet”,value 为 [“eat”, “tea”, “ate”]<br> key 为 “ant”,value 为 [“tan”, “nat”]<br> key 为 “abt”,value 为 [“bat”]<br> 从 map 中获取所有 value,构造结果列表,即 [ [“eat”, “tea”, “ate”], [“tan”, “nat”], [“bat”] ]<br> 可以看到,通过将每个字符串排序作为 key,并存储字母异位词的字符串列表作为 value,算法成功将字母异位词分组了。这样的分组过程更加高效,避免了对每个字符串都进行两两比较的低效操作。</p>
</blockquote>
<h1 id="lc128-最长连续序列"><a href="#lc128-最长连续序列" class="headerlink" title="lc128 最长连续序列"></a>lc128 最长连续序列</h1><blockquote>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//使用HashSet进行去重操作</span></span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            set.add(num);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> longestStreak=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意，这里不能遍历数组中的元素，否则会超时，应当遍历set中的元素！！！</span></span><br><span class="line">        <span class="comment">//for(int num:nums)  错误写法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:set)&#123;</span><br><span class="line">            <span class="comment">//如果num-1不在序列中，说明num可以作为一个新的起点</span></span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//当前元素</span></span><br><span class="line">                <span class="type">int</span> currentNum=num;</span><br><span class="line">                <span class="comment">//目前记录的最大长度</span></span><br><span class="line">                <span class="type">int</span> currentStreak=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(currentNum+<span class="number">1</span>))&#123;</span><br><span class="line">                    currentNum++;</span><br><span class="line">                    <span class="comment">//更新目前记录最大长度</span></span><br><span class="line">                    currentStreak++;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(currentStreak&gt;longestStreak)&#123;</span><br><span class="line">                    longestStreak=currentStreak;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStreak;       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：空港急行</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/longest-consecutive-sequence/solutions/3606581/yi-zhi-chao-shi-de-yuan-yin-zhao-dao-lia-ma8r/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>这题不能排序，需要直接通过hashSet结构进行去重。排序时间复杂度就大了。其实这道题也可以算作某种程度上的贪心算法，从我们进入这个set开始遍历之后，其实并不关心是不是在物理上存在这个连续序列</p>
<blockquote>
<p>在这段代码中，<strong>排序并不是显式地实现的</strong>。代码的核心思想是通过 <strong>HashSet</strong> 来高效地查找连续序列，而不是直接对数组进行排序。下面我来详细解释这段代码的工作原理，并说明为什么不需要显式的排序。</p>
<hr>
<h3 id="代码逻辑解析"><a href="#代码逻辑解析" class="headerlink" title="代码逻辑解析"></a>代码逻辑解析</h3><h4 id="1-使用-HashSet-去重"><a href="#1-使用-HashSet-去重" class="headerlink" title="1. 使用 HashSet 去重"></a>1. 使用 <code>HashSet</code> 去重</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    set.add(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，将数组中的所有元素存入一个 <code>HashSet</code> 中。</li>
<li><code>HashSet</code> 的特点是：<ul>
<li>不允许重复元素。</li>
<li>查找操作的时间复杂度为 <strong>O(1)</strong>（平均情况下）。</li>
</ul>
</li>
<li>这一步的作用是去重，避免重复元素对结果的影响。</li>
</ul>
<hr>
<h4 id="2-遍历-HashSet-寻找连续序列"><a href="#2-遍历-HashSet-寻找连续序列" class="headerlink" title="2. 遍历 HashSet 寻找连续序列"></a>2. 遍历 <code>HashSet</code> 寻找连续序列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : set) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">            currentNum++;</span><br><span class="line">            currentStreak++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentStreak &gt; longestStreak) &#123;</span><br><span class="line">            longestStreak = currentStreak;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h5><ul>
<li>我们只在当前数字 <code>num</code> 是某个连续序列的起点时，才开始计算该序列的长度。</li>
<li>判断是否是起点的方法是：检查 <code>num - 1</code> 是否存在于 <code>set</code> 中。<ul>
<li>如果 <code>num - 1</code> 存在，说明 <code>num</code> 不是一个连续序列的起点，跳过它。</li>
<li>如果 <code>num - 1</code> 不存在，说明 <code>num</code> 是一个连续序列的起点，从这里开始向后扩展，寻找连续的数字。</li>
</ul>
</li>
</ul>
<h5 id="扩展过程："><a href="#扩展过程：" class="headerlink" title="扩展过程："></a>扩展过程：</h5><ul>
<li>一旦确定了起点 <code>num</code>，就通过 <code>while</code> 循环检查是否存在 <code>num + 1</code>、<code>num + 2</code> 等连续的数字。</li>
<li>每次找到一个连续的数字，就更新当前序列的长度 <code>currentStreak</code>。</li>
<li>最后，比较当前序列的长度与全局最长序列长度 <code>longestStreak</code>，并更新最大值。</li>
</ul>
<hr>
<h3 id="为什么不需要显式排序？"><a href="#为什么不需要显式排序？" class="headerlink" title="为什么不需要显式排序？"></a>为什么不需要显式排序？</h3><p>这段代码的核心优势在于 <strong>利用了 <code>HashSet</code> 的快速查找特性</strong>，而没有使用传统的排序算法。以下是原因：</p>
<ol>
<li><p><strong>传统排序的时间复杂度</strong>：</p>
<ul>
<li>如果使用排序算法（如快速排序或归并排序），时间复杂度为 <strong>O(n log n)</strong>。</li>
<li>排序后，可以通过一次遍历找到最长连续序列。</li>
</ul>
</li>
<li><p><strong>本方法的时间复杂度</strong>：</p>
<ul>
<li>构建 <code>HashSet</code> 的时间复杂度为 <strong>O(n)</strong>。</li>
<li>遍历 <code>HashSet</code> 并查找连续序列的时间复杂度也是 <strong>O(n)</strong>，因为每个数字最多只会被访问两次（一次作为起点，一次作为后续数字）。</li>
<li>因此，总时间复杂度为 <strong>O(n)</strong>，比排序更高效。</li>
</ul>
</li>
<li><p><strong>空间换时间</strong>：</p>
<ul>
<li>通过使用额外的空间（<code>HashSet</code>），我们避免了排序的开销，从而提高了效率。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码并没有实现显式的排序，而是通过 <strong>HashSet</strong> 和 <strong>贪心算法</strong> 的结合，巧妙地找到了最长连续序列。其核心思想是：</p>
<ul>
<li>利用 <code>HashSet</code> 快速判断某个数字是否存在。</li>
<li>只在连续序列的起点处开始扩展，避免了重复计算。</li>
</ul>
<p>这种方法的时间复杂度为 <strong>O(n)</strong>，空间复杂度为 <strong>O(n)</strong>，是一种非常高效的解决方案。</p>
</blockquote>
<h1 id="lc283-移动0"><a href="#lc283-移动0" class="headerlink" title="lc283 移动0"></a>lc283 移动0</h1><blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p>**进阶：**你能尽量减少完成的操作次数吗？</p>
</blockquote>
<p>这是双指针部分的习题</p>
<p>分为读指针–找到非0元素</p>
<p>写指针–把非0元素移到前面</p>
<p>非零元素都移动到前面之后，数组后面的部分直接填充成0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">writeIndex</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 写入指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步：将所有非零元素移到前面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">readIndex</span> <span class="operator">=</span> <span class="number">0</span>; readIndex &lt; len; readIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[readIndex] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[writeIndex] = nums[readIndex];</span><br><span class="line">                writeIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：将剩余位置填充为 0</span></span><br><span class="line">        <span class="keyword">while</span> (writeIndex &lt; len) &#123;</span><br><span class="line">            nums[writeIndex] = <span class="number">0</span>;</span><br><span class="line">            writeIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意，读指针应当作为遍历数组当中的过程，而不能在遍历之前定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=nums.length;</span><br><span class="line">        <span class="type">int</span> w=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[w]=nums[r];</span><br><span class="line">                w++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(w&lt;len)&#123;</span><br><span class="line">            nums[w]=<span class="number">0</span>;</span><br><span class="line">            w++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这样，就会使得读指针没办法及时更新</p>
<h1 id="lc11-盛水最多的容器"><a href="#lc11-盛水最多的容器" class="headerlink" title="lc11 盛水最多的容器"></a>lc11 盛水最多的容器</h1><blockquote>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure></blockquote>
<p>盛水最多，要求容器的宽度和高度都尽可能高</p>
<p>所以考虑头尾指针</p>
<p>同时考虑进行遍历</p>
<p>每次取最大的盛水容量</p>
<p>可以暴力</p>
<p>双循环</p>
<p>总结一下思路：</p>
<p>盛水的容量：宽乘高</p>
<p>宽度：两个指针索引之差</p>
<p>高度：两个指针索引元素的较小一方</p>
<p>为此，我们设置头尾指针，指向队首元素，队尾元素</p>
<p>分别是两个高度</p>
<p>初始就记录一下能装水的容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tail=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> width=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> capacity=width*Math.min(height[<span class="number">0</span>],height[tail]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[head]&lt;=height[tail])&#123;</span><br><span class="line">                head++;</span><br><span class="line">                width--;</span><br><span class="line">                capacity=Math.max(capacity,width*Math.min(height[head],height[tail]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tail--;</span><br><span class="line">                width--;</span><br><span class="line">                capacity=Math.max(capacity,width*Math.min(height[head],height[tail]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种不知道遍历次数最好用while</p>
<p>而且我忽略了最重要的一个条件</p>
<p>就是终止条件</p>
<p><strong>两个指针相遇，遍历结束</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 左指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> height.length - <span class="number">1</span>; <span class="comment">// 右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCapacity</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最大容量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">            <span class="comment">// 计算当前宽度和高度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> tail - head;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span> Math.min(height[head], height[tail]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentCapacity</span> <span class="operator">=</span> width * minHeight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大容量</span></span><br><span class="line">            maxCapacity = Math.max(maxCapacity, currentCapacity);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动指针</span></span><br><span class="line">            <span class="keyword">if</span> (height[head] &lt; height[tail]) &#123;</span><br><span class="line">                head++; <span class="comment">// 左指针向右移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail--; <span class="comment">// 右指针向左移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc15-三数之和"><a href="#lc15-三数之和" class="headerlink" title="lc15 三数之和"></a>lc15 三数之和</h1><blockquote>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure></blockquote>
<p>思路在于 排序加双指针</p>
<p>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端</p>
<p>数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集</p>
<p>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环</p>
<p>如果 nums[i] &#x3D;&#x3D; nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过</p>
<p>除此之外，和小于0 L++ 和大于0 R–</p>
<p>当 sum &#x3D;&#x3D; 0 时，nums[L] &#x3D;&#x3D; nums[L+1] 则会导致结果重复，应该跳过，L++</p>
<p>当 sum &#x3D;&#x3D; 0 时，nums[R] &#x3D;&#x3D; nums[R−1] 则会导致结果重复，应该跳过，R−−</p>
<p>L与R相遇的时候，i++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> ans; <span class="comment">// 边界条件检查</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; <span class="comment">// 注意范围是 nums.length - 2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前值大于 0，则后续不可能有解</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过重复值</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 定义双指针</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[left], nums[right])); <span class="comment">// 添加结果</span></span><br><span class="line">                    <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++; <span class="comment">// 和小于 0，移动左指针</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--; <span class="comment">// 和大于 0，移动右指针</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc42-接雨水"><a href="#lc42-接雨水" class="headerlink" title="lc42 接雨水"></a>lc42 接雨水</h1><blockquote>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure></blockquote>
<p>我这几天总是在b站刷到这道题</p>
<p>这种情景题肯定需要分析了</p>
<p>求每一列的水，我们只关注<strong>当前列，左边最高的墙，右边最高的墙</strong></p>
<p>装水的多少，当然根据木桶效应，我们只需要看左边最高的墙和右边最高的墙中较矮的一个就够了。</p>
<p>所以，根据较矮的那个墙和当前列的墙的高度可以分为三种情况。</p>
<ul>
<li>较矮的墙的高度大于当前列的墙的高度</li>
</ul>
<p>想象一下，往两边最高的墙之间注水。正在求的列会有多少水？</p>
<p>很明显，较矮的一边，也就是左边的墙的高度，减去当前列的高度就可以了，也就是 2 - 1 &#x3D; 1，可以存一个单位的水。</p>
<ul>
<li>较矮的墙的高度小于当前列的墙的高度</li>
</ul>
<p>想象下，往两边最高的墙之间注水。正在求的列会有多少水？</p>
<p>正在求的列不会有水，因为它大于了两边较矮的墙。</p>
<ul>
<li>较矮的墙的高度等于当前列的墙的高度。</li>
</ul>
<p>和上一种情况是一样的，不会有水。</p>
<p>遍历的方法超时</p>
<p>考虑双指针</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><blockquote>
<p>以下是对代码的详细注释和解释，帮助你更好地理解“接雨水”问题的双指针解法。</p>
<hr>
<h3 id="代码及详细注释"><a href="#代码及详细注释" class="headerlink" title="代码及详细注释"></a>代码及详细注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化结果变量，用于存储总的积水面积</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义左右指针，分别从数组两端向中间移动</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义前缀最大值和后缀最大值，分别记录左侧和右侧的最大高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 左侧最大高度（前缀最大值）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sufMax</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 右侧最大高度（后缀最大值）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当左右指针未相遇时，继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 更新左侧最大高度（前缀最大值）</span></span><br><span class="line">            preMax = Math.max(preMax, height[left]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新右侧最大高度（后缀最大值）</span></span><br><span class="line">            sufMax = Math.max(sufMax, height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较左右两侧的最大高度，决定处理哪一侧</span></span><br><span class="line">            <span class="keyword">if</span> (preMax &lt; sufMax) &#123;</span><br><span class="line">                <span class="comment">// 如果左侧最大高度小于右侧最大高度，则左侧当前柱子可以积水</span></span><br><span class="line">                <span class="comment">// 积水高度为左侧最大高度减去当前柱子高度</span></span><br><span class="line">                ans += preMax - height[left];</span><br><span class="line">                left++; <span class="comment">// 左指针右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果右侧最大高度小于等于左侧最大高度，则右侧当前柱子可以积水</span></span><br><span class="line">                <span class="comment">// 积水高度为右侧最大高度减去当前柱子高度</span></span><br><span class="line">                ans += sufMax - height[right];</span><br><span class="line">                right--; <span class="comment">// 右指针左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回总的积水面积</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. <strong>问题背景</strong></h4><p>给定一个非负整数数组 <code>height</code>，表示每个位置的高度。要求计算这些柱子之间能够接住的雨水总量。</p>
<hr>
<h4 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. <strong>核心思想</strong></h4><ul>
<li>使用双指针法，分别从数组两端向中间移动。</li>
<li>通过维护两个变量 <code>preMax</code> 和 <code>sufMax</code>，分别记录左右两侧的最大高度。</li>
<li>根据左右两侧最大高度的比较，决定处理哪一侧的柱子。</li>
</ul>
<hr>
<h4 id="3-关键变量"><a href="#3-关键变量" class="headerlink" title="3. 关键变量"></a>3. <strong>关键变量</strong></h4><ul>
<li><strong><code>ans</code></strong>：总积水面积，初始化为 0。</li>
<li><strong><code>left</code></strong> 和 <strong><code>right</code></strong>：左右指针，分别指向数组的起始和末尾。</li>
<li><strong><code>preMax</code></strong>：左侧最大高度（前缀最大值），随着左指针移动而更新。</li>
<li><strong><code>sufMax</code></strong>：右侧最大高度（后缀最大值），随着右指针移动而更新。</li>
</ul>
<hr>
<h4 id="4-为什么可以用双指针？"><a href="#4-为什么可以用双指针？" class="headerlink" title="4. 为什么可以用双指针？"></a>4. <strong>为什么可以用双指针？</strong></h4><ul>
<li>对于某个位置 <code>i</code>，它能接住的雨水量取决于：<ul>
<li>左侧的最大高度 <code>preMax</code>。</li>
<li>右侧的最大高度 <code>sufMax</code>。</li>
<li>雨水量为 <code>min(preMax, sufMax) - height[i]</code>。</li>
</ul>
</li>
<li>通过双指针法，我们可以动态地更新 <code>preMax</code> 和 <code>sufMax</code>，避免了额外的空间开销（如使用动态规划或单调栈）。</li>
</ul>
<hr>
<h4 id="5-逻辑分解"><a href="#5-逻辑分解" class="headerlink" title="5. 逻辑分解"></a>5. <strong>逻辑分解</strong></h4><h5 id="（1）更新最大高度"><a href="#（1）更新最大高度" class="headerlink" title="（1）更新最大高度"></a>（1）更新最大高度</h5><ul>
<li>在每次循环中，更新左侧最大高度 <code>preMax</code> 和右侧最大高度 <code>sufMax</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preMax = Math.max(preMax, height[left]);</span><br><span class="line">sufMax = Math.max(sufMax, height[right]);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>preMax</code> 表示从左到当前位置的最大高度。</li>
<li><code>sufMax</code> 表示从右到当前位置的最大高度。</li>
</ul>
</li>
</ul>
<h5 id="（2）比较两侧最大高度"><a href="#（2）比较两侧最大高度" class="headerlink" title="（2）比较两侧最大高度"></a>（2）比较两侧最大高度</h5><ul>
<li><p>如果 <code>preMax &lt; sufMax</code>，说明左侧的最大高度限制了积水高度，可以安全地处理左侧柱子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans += preMax - height[left];</span><br><span class="line">left++;</span><br></pre></td></tr></table></figure>
<ul>
<li>当前柱子的积水高度为 <code>preMax - height[left]</code>。</li>
<li>左指针右移。</li>
</ul>
</li>
<li><p>否则，说明右侧的最大高度限制了积水高度，可以安全地处理右侧柱子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans += sufMax - height[right];</span><br><span class="line">right--;</span><br></pre></td></tr></table></figure>
<ul>
<li>当前柱子的积水高度为 <code>sufMax - height[right]</code>。</li>
<li>右指针左移。</li>
</ul>
</li>
</ul>
<h5 id="（3）终止条件"><a href="#（3）终止条件" class="headerlink" title="（3）终止条件"></a>（3）终止条件</h5><ul>
<li>当 <code>left &gt;= right</code> 时，双指针相遇，循环结束。</li>
</ul>
<hr>
<h4 id="6-时间复杂度和空间复杂度"><a href="#6-时间复杂度和空间复杂度" class="headerlink" title="6. 时间复杂度和空间复杂度"></a>6. <strong>时间复杂度和空间复杂度</strong></h4><ul>
<li><strong>时间复杂度</strong>：O(n)<ul>
<li>双指针从两端向中间移动，每个元素最多被访问一次。</li>
</ul>
</li>
<li><strong>空间复杂度</strong>：O(1)<ul>
<li>只使用了常数级别的额外空间。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="示例运行"><a href="#示例运行" class="headerlink" title="示例运行"></a>示例运行</h3><p>输入数组：<code>[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]</code></p>
<p>执行过程：</p>
<ol>
<li><p>初始状态：</p>
<ul>
<li><code>left = 0</code>, <code>right = 11</code></li>
<li><code>preMax = 0</code>, <code>sufMax = 0</code></li>
<li><code>ans = 0</code></li>
</ul>
</li>
<li><p>第一次迭代：</p>
<ul>
<li><code>preMax = max(0, height[0]) = 0</code></li>
<li><code>sufMax = max(0, height[11]) = 1</code></li>
<li>因为 <code>preMax &lt; sufMax</code>，处理左侧柱子：<ul>
<li><code>ans += preMax - height[0] = 0 - 0 = 0</code></li>
<li><code>left++</code>，<code>left = 1</code></li>
</ul>
</li>
</ul>
</li>
<li><p>第二次迭代：</p>
<ul>
<li><code>preMax = max(0, height[1]) = 1</code></li>
<li><code>sufMax = max(1, height[10]) = 2</code></li>
<li>因为 <code>preMax &lt; sufMax</code>，处理左侧柱子：<ul>
<li><code>ans += preMax - height[1] = 1 - 1 = 0</code></li>
<li><code>left++</code>，<code>left = 2</code></li>
</ul>
</li>
</ul>
</li>
<li><p>第三次迭代：</p>
<ul>
<li><code>preMax = max(1, height[2]) = 1</code></li>
<li><code>sufMax = max(2, height[9]) = 2</code></li>
<li>因为 <code>preMax &lt; sufMax</code>，处理左侧柱子：<ul>
<li><code>ans += preMax - height[2] = 1 - 0 = 1</code></li>
<li><code>left++</code>，<code>left = 3</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>…</p>
<p>最终结果：<code>6</code></p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>双指针法是一种高效解决“接雨水”问题的方法。</li>
<li>核心在于动态更新左右两侧的最大高度，并根据最大高度的比较决定处理哪一侧。</li>
<li>去重逻辑和边界条件处理确保了算法的正确性和效率。</li>
</ul>
<p>希望这个详细注释能帮助你更好地理解代码！</p>
</blockquote>
<h1 id="lc3-无重复字符的最长子串"><a href="#lc3-无重复字符的最长子串" class="headerlink" title="lc3 无重复字符的最长子串"></a>lc3 无重复字符的最长子串</h1><blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长</strong> 子串</p>
<p> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></blockquote>
<p>将整个字符串抽象为数组</p>
<p>数组的每个元素是这个字符串的的相对值</p>
<p>问题简化成 找到这个数组当中两个相等的元素的最小间距</p>
<p>快慢指针试一下</p>
<p>慢指针从0出发，快指针首先从1出发</p>
<p>对于索引为慢和索引为快的元素</p>
<p>检查他们是否相等</p>
<p>假如相等，更新一个最小值</p>
<p>并且慢指针++，快指针更新为慢指针的下一个</p>
<p>这个思路并不好，优化一下成为滑动窗口</p>
<hr>
<p>万能模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外层循环扩展右边界，内层循环扩展左边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span> ; r &lt; n ; r++) &#123;</span><br><span class="line">	<span class="comment">//当前考虑的元素</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r &amp;&amp; check()) &#123;<span class="comment">//区间[left,right]不符合题意</span></span><br><span class="line">        <span class="comment">//扩展左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间[left,right]符合题意，统计相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//去重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;<span class="comment">//每一轮右端点都扩一个。</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> ss[right];<span class="comment">//right指向的元素，也是当前要考虑的元素</span></span><br><span class="line">            <span class="keyword">while</span>(set.contains(ch)) &#123;<span class="comment">//set中有ch，则缩短左边界，同时从set集合出元素</span></span><br><span class="line">                set.remove(ss[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(ss[right]);<span class="comment">//别忘。将当前元素加入。</span></span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);<span class="comment">//计算当前不重复子串的长度。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc438-找到字符串中所有字母异位词"><a href="#lc438-找到字符串中所有字母异位词" class="headerlink" title="lc438 找到字符串中所有字母异位词"></a>lc438 找到字符串中所有字母异位词</h1><p>字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</p>
<blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 字母异位词</p>
<p> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li>
<li><code>s</code> 和 <code>p</code> 仅包含小写字母</li>
</ul>
</blockquote>
<p>看看滑动窗口万能模板能不能用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外层循环扩展右边界，内层循环扩展左边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span> ; r &lt; n ; r++) &#123;</span><br><span class="line">	<span class="comment">//当前考虑的元素</span></span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r &amp;&amp; check()) &#123;<span class="comment">//区间[left,right]不符合题意</span></span><br><span class="line">        <span class="comment">//扩展左边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间[left,right]符合题意，统计相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充一下这个模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(string s, string t)</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中两处 … 表示的更新窗口数据的地方，到时候你直接往里面填就行了。</p>
<p>而且，这两个 … 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。</p>
<p><strong>套模板，只需要思考以下四个问题：</strong></p>
<p><strong>1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？</strong></p>
<p><strong>2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？</strong></p>
<p><strong>3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？</strong></p>
<p><strong>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/9749/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-">模板连接</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用两个哈希表分别记录目标字符串 t 和滑动窗口中的字符频率</span></span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 need 哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">// 滑动窗口的左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录窗口中满足条件的字符数量</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始滑动窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right); <span class="comment">// 获取右边界字符</span></span><br><span class="line">            right++; <span class="comment">// 扩展右边界</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新窗口内的数据</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">                window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                    valid++; <span class="comment">// 如果窗口中该字符的数量达到目标，增加 valid</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断左侧窗口是否需要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= t.length()) &#123;</span><br><span class="line">                <span class="comment">// 当窗口符合条件时，记录起始索引</span></span><br><span class="line">                <span class="keyword">if</span> (valid == need.size()) &#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left); <span class="comment">// 获取左边界字符</span></span><br><span class="line">                left++; <span class="comment">// 收缩左边界</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新窗口内的数据</span></span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                        valid--; <span class="comment">// 如果窗口中该字符的数量不再满足目标，减少 valid</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc560-和为k的子数组"><a href="#lc560-和为k的子数组" class="headerlink" title="lc560 和为k的子数组"></a>lc560 和为k的子数组</h1><blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-107 &lt;= k &lt;= 107</code></li>
</ul>
</blockquote>
<p>子串问题</p>
<p>考虑滑动窗口</p>
<p><strong>套模板，只需要思考以下四个问题：</strong></p>
<p><strong>1、当移动 right 扩大窗口，即加入字符时，应该更新哪些数据？</strong></p>
<p><strong>2、什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？</strong></p>
<p><strong>3、当移动 left 缩小窗口，即移出字符时，应该更新哪些数据？</strong></p>
<p><strong>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</strong></p>
<p>当加入字符时，更新当前的窗口内部的数值和</p>
<p>当窗口内部的数值的和，等于k的时候，开始移动left缩小窗口，并且res++</p>
<p>当移动left缩小窗口，移出字符的时候，应该更新当前窗口的内部的数值和</p>
<p>我们的结果应该在窗口进行变更时更新</p>
<p>看一下模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindow</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 need map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">// 右移窗口</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">                window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (window.get(c).equals(need.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">            <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (right - left &gt;= t.length()) &#123; <span class="comment">// 示例条件，具体逻辑根据需求修改</span></span><br><span class="line">                <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">// 左移窗口</span></span><br><span class="line">                left++;</span><br><span class="line">                <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.get(d).equals(need.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SlidingWindow</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SlidingWindow</span>();</span><br><span class="line">        sw.slidingWindow(<span class="string">&quot;ADOBECODEBANC&quot;</span>, <span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; window=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cursum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;nums.length)&#123;</span><br><span class="line">            <span class="type">int</span> num=nums[right];</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(cursum&lt;k)&#123;</span><br><span class="line">                cursum+=num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cursum==k)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="type">int</span> outnum=nums[left];</span><br><span class="line">                cursum-=outnum;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(cursum&gt;k)&#123;</span><br><span class="line">                <span class="type">int</span> outRangeNum=nums[left];</span><br><span class="line">                cursum-=outRangeNum;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这个思路是有问题的</p>
<p>这段代码的问题在于，当 <code>cursum == k</code> 时，直接移动左指针 <code>left</code> 并减少 <code>cursum</code> 的值，可能会跳过其他可能满足条件的子数组。例如，对于输入 <code>nums = [1, 2, 3]</code> 和 <code>k = 3</code>，您的代码可能只找到 <code>[1, 2]</code>，而忽略了 <code>[3]</code>。</p>
<p>我们需要确保在找到一个满足条件的子数组后，不立即收缩窗口（即不移动 <code>left</code>），而是继续尝试寻找其他可能的子数组。具体来说：</p>
<ol>
<li>当 <code>cursum == k</code> 时，增加计数器 <code>res</code>。</li>
<li>不要立即移动 <code>left</code>，而是让右指针 <code>right</code> 继续扩展窗口，直到 <code>cursum &gt; k</code> 或遍历结束。</li>
<li>只有在 <code>cursum &gt; k</code> 时，才通过移动 <code>left</code> 来缩小窗口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// 结果计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;      <span class="comment">// 左指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">// 右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cursum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 当前窗口的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="comment">// 将当前元素加入窗口</span></span><br><span class="line">            cursum += nums[right];</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否有满足条件的子数组</span></span><br><span class="line">            <span class="keyword">while</span> (cursum &gt;= k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cursum == k) &#123;</span><br><span class="line">                    res++; <span class="comment">// 找到一个满足条件的子数组</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                cursum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(solution.subarraySum(nums, k)); <span class="comment">// 输出: 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这道题（<strong>和为 k 的连续子数组数量</strong>）不适合使用滑动窗口算法的原因主要在于 <strong>数组中可能存在负数</strong>，这会导致滑动窗口的核心假设失效。</p>
<hr>
<h3 id="滑动窗口的核心假设"><a href="#滑动窗口的核心假设" class="headerlink" title="滑动窗口的核心假设"></a>滑动窗口的核心假设</h3><p>滑动窗口算法通常适用于以下场景：</p>
<ol>
<li><strong>单调性</strong>：窗口内的某种属性（如窗口的和）随着右指针的扩展而单调递增或递减。</li>
<li><strong>可收缩性</strong>：当窗口内的属性满足某种条件时，可以通过移动左指针来缩小窗口，且不会遗漏解。</li>
</ol>
<p>例如：</p>
<ul>
<li>在求解「最小覆盖子串」问题时，窗口的长度是单调递增的，因此可以通过移动左指针来缩小窗口。</li>
<li>在求解「最长无重复子串」问题时，窗口的长度也是单调递增的。</li>
</ul>
<p>然而，在本题中，由于数组中可能包含负数，这些假设不再成立。</p>
<hr>
<h3 id="为什么负数会破坏滑动窗口的假设？"><a href="#为什么负数会破坏滑动窗口的假设？" class="headerlink" title="为什么负数会破坏滑动窗口的假设？"></a>为什么负数会破坏滑动窗口的假设？</h3><h4 id="1-窗口和不单调"><a href="#1-窗口和不单调" class="headerlink" title="1. 窗口和不单调"></a>1. <strong>窗口和不单调</strong></h4><p>在滑动窗口中，我们通常假设：</p>
<ul>
<li>当右指针 <code>right</code> 向右移动时，窗口的和 <code>cursum</code> 单调递增。</li>
<li>当左指针 <code>left</code> 向右移动时，窗口的和 <code>cursum</code> 单调递减。</li>
</ul>
<p>但如果数组中存在负数，窗口的和可能会因为负数的加入而减少。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>], k = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当右指针从 <code>0</code> 移动到 <code>1</code> 时，窗口 <code>[1] -&gt; [1, -1]</code>，窗口和从 <code>1</code> 减少到 <code>0</code>。</li>
<li>这种情况下，窗口的和不再单调递增，导致滑动窗口的逻辑失效。</li>
</ul>
<h4 id="2-无法确定何时收缩窗口"><a href="#2-无法确定何时收缩窗口" class="headerlink" title="2. 无法确定何时收缩窗口"></a>2. <strong>无法确定何时收缩窗口</strong></h4><p>滑动窗口的一个关键步骤是通过移动左指针来缩小窗口。但在本题中，由于负数的存在，即使当前窗口的和大于 <code>k</code>，也不能保证通过移动左指针一定能使窗口和小于 <code>k</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">3</span>, -<span class="number">1</span>, <span class="number">2</span>], k = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>初始窗口 <code>[3]</code>，和为 <code>3</code>，满足条件。</li>
<li>扩展窗口为 <code>[3, -1]</code>，和为 <code>2</code>，小于 <code>k</code>。</li>
<li>再扩展窗口为 <code>[3, -1, 2]</code>，和为 <code>4</code>，大于 <code>k</code>。</li>
<li>此时如果移动左指针，窗口变为 <code>[-1, 2]</code>，和为 <code>1</code>，仍然小于 <code>k</code>。</li>
</ul>
<p>这种情况下，滑动窗口无法准确判断何时应该收缩窗口，容易导致遗漏解或错误结果。</p>
<hr>
<h3 id="更适合的方法：前缀和-哈希表"><a href="#更适合的方法：前缀和-哈希表" class="headerlink" title="更适合的方法：前缀和 + 哈希表"></a>更适合的方法：前缀和 + 哈希表</h3><p>由于滑动窗口的局限性，本题更适合使用 <strong>前缀和 + 哈希表</strong> 的方法。这种方法的核心思想是利用前缀和的性质，快速找到和为 <code>k</code> 的子数组。</p>
<h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><ol>
<li><p><strong>前缀和定义</strong>：<br>前缀和 <code>prefixSum[i]</code> 表示从数组起始位置到第 <code>i</code> 个位置的所有元素之和。<br>如果两个前缀和之间的差值等于 <code>k</code>，则说明中间的部分是一个和为 <code>k</code> 的子数组。</p>
</li>
<li><p><strong>哈希表的作用</strong>：<br>使用一个哈希表记录每个前缀和出现的次数，方便快速查找是否存在满足条件的子数组。</p>
</li>
</ol>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>时间复杂度</strong>：O(n)，只需遍历数组一次。</li>
<li><strong>空间复杂度</strong>：O(n)，用于存储前缀和的哈希表。</li>
</ul>
<hr>
<h3 id="对比两种方法"><a href="#对比两种方法" class="headerlink" title="对比两种方法"></a>对比两种方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>是否支持负数</th>
</tr>
</thead>
<tbody><tr>
<td>滑动窗口</td>
<td>元素非负，窗口和单调递增&#x2F;递减</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不支持</td>
</tr>
<tr>
<td>前缀和 + 哈希表</td>
<td>任意整数数组</td>
<td>O(n)</td>
<td>O(n)</td>
<td>支持</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>滑动窗口不适合本题的主要原因是数组中可能存在负数，导致窗口和不单调、无法确定何时收缩窗口。对于这类问题，<strong>前缀和 + 哈希表</strong> 是更通用、更高效的方法。</p>
</blockquote>
<h2 id="前缀和思路"><a href="#前缀和思路" class="headerlink" title="前缀和思路"></a>前缀和思路</h2><p>下面我们先来了解一下什么是前缀和。</p>
<p>前缀和其实我们很早之前就了解过的，我们求数列的和时，Sn &#x3D; a1+a2+a3+…an; 此时Sn就是数列的前 n 项和。例 S5 &#x3D; a1 + a2 + a3 + a4 + a5; S2 &#x3D; a1 + a2。所以我们完全可以通过 S5-S2 得到 a3+a4+a5 的值，这个过程就和我们做题用到的前缀和思想类似。我们的前缀和数组里保存的就是前 n 项的和。</p>
<p>我们通过前缀和数组保存前 n 位的和，presum[1]保存的就是 nums 数组中前 1 位的和，也就是 presum[1] &#x3D; nums[0], presum[2] &#x3D; nums[0] + nums[1] &#x3D; presum[1] + nums[1]. 依次类推，所以我们通过前缀和数组可以轻松得到每个区间的和。</p>
<p>例如我们需要获取  nums[2]  到  nums[4]  这个区间的和</p>
<p>直接让S5-S2就可以了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//细节，这里需要预存前缀和为 0 的情况，会漏掉前几位就满足的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//例如输入[1,1,0]，k = 2 如果没有这行代码，则会返回0,漏掉了1+1=2，和1+1+0=2的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入：[3,1,1,0] k = 2时则不会漏掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为presum[3] - presum[0]表示前面 3 位的和，所以需要map.put(0,1),垫下底</span></span><br><span class="line"></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line"></span><br><span class="line">            presum += x;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前前缀和已知，判断是否含有 presum - k的前缀和，那么我们就知道某一区间的和为 k 了。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(presum - k)) &#123;</span><br><span class="line"></span><br><span class="line">                count += map.get(presum - k);<span class="comment">//获取次数</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line"></span><br><span class="line">            map.put(presum,map.getOrDefault(presum,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：程序厨</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/subarray-sum-equals-k/solutions/562174/de-liao-yi-wen-jiang-qian-zhui-he-an-pai-yhyf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>这样更好理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] presum=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            presum[i+<span class="number">1</span>] = nums[i] + presum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.length;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(presum[j+<span class="number">1</span>]-presum[i]==k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc239-滑动窗口最大值"><a href="#lc239-滑动窗口最大值" class="headerlink" title="lc239 滑动窗口最大值"></a>lc239 滑动窗口最大值</h1><blockquote>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure></blockquote>
<p>维护一个队列</p>
<p>遍历题目当中给出的数组</p>
<ul>
<li>假如队列当前不为空，并且下一个要考虑的元素，大于当前的队尾元素，那么移除队尾元素。直到下一个要考虑的元素不再满足比较条件，或者队列为空。</li>
<li>移除结束，把这个要考虑的元素加入到queue当中</li>
<li>假如队首元素的下标小于滑动窗口左侧边界，将该队首元素移除。这个元素已经不在窗口内了</li>
<li>因为数组下标从0开始，所以直到窗口右边界大于k-1，才开始记录结果</li>
<li>当前队列的首元素，就是窗口内的最大值</li>
<li>因为我们事实上维护了一个单调队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>;right&lt;nums.length;right++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;nums[right]&gt;=nums[queue.peekLast()])&#123;</span><br><span class="line">                queue.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(right);</span><br><span class="line">            <span class="type">int</span> left=right-k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(queue.peekFirst()&lt;left)&#123;</span><br><span class="line">                queue.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right+<span class="number">1</span>&gt;=k)&#123;</span><br><span class="line">                res[left]=nums[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc76-最小覆盖子串"><a href="#lc76-最小覆盖子串" class="headerlink" title="lc76 最小覆盖子串"></a>lc76 最小覆盖子串</h1><blockquote>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure></blockquote>
<p>和438比较像</p>
<p>考虑滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; ht = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            ht.put(t.charAt(i),ht.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=Integer.MAX_VALUE;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="type">char</span> cr=s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(ht.containsKey(cr))&#123;</span><br><span class="line">                hs.put(cr,hs.getOrDefault(cr,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(hs.get(cr).equals(ht.get(cr)))&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right-left&gt;=t.length()&amp;&amp;right-left+<span class="number">1</span>&lt;s.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt==ht.size())&#123;</span><br><span class="line">                   sb.append(s.substring(left,right+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> cl=s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span>(ht.containsKey(cl))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(hs.get(cl).equals(ht.get(cl)))&#123;</span><br><span class="line">                        cnt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hs.put(cl,hs.get(cl)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>

<p>这一版是错误的代码</p>
<p>我们来说明一下错误的原因</p>
<blockquote>
<ol>
<li><code>sb.append</code> 的逻辑错误<ul>
<li>你直接将符合条件的子串追加到 <code>StringBuilder</code> 中，而不是记录最短的子串。</li>
<li>最终结果应该是最短的子串，而不是所有符合条件的子串。</li>
</ul>
</li>
<li>窗口收缩条件不正确<ul>
<li>当前的条件 <code>right - left &gt;= t.length()</code> 和 <code>right - left + 1 &lt; s.length()</code> 不够严谨。</li>
<li>正确的条件应该是：当窗口内的字符已经满足 <code>t</code> 的所有字符要求时，尝试收缩窗口。</li>
</ul>
</li>
<li>没有记录最短子串的起始位置和长度<ul>
<li>需要额外的变量来记录当前最短子串的起始索引和长度。</li>
</ul>
</li>
</ol>
</blockquote>
<p>最开始我考虑的方向出了问题，因为这道题实际上得到的字串是可以长度大于目标字串的</p>
<p>所以在收缩窗口的条件上，我们就不能使用438当中的那种条件了。</p>
<p>那么在这道题当中，我们什么时候收缩窗口呢</p>
<p>当cnt，也就是窗口内满足条件的字符数量大于等于目标字符串的长度</p>
<p>开始收缩窗口</p>
<p>因为我们要找到最小的覆盖字串，在收缩窗口的同时，要更新最小的窗户长度</p>
<p>之后再执行缩小窗口的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; ht = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 ht</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            ht.put(c, ht.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最短子串的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cr</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新窗口内的字符计数</span></span><br><span class="line">            <span class="keyword">if</span> (ht.containsKey(cr)) &#123;</span><br><span class="line">                hs.put(cr, hs.getOrDefault(cr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (hs.get(cr).equals(ht.get(cr))) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当窗口满足条件时，尝试收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> (cnt &gt;= ht.size()) &#123;</span><br><span class="line">                <span class="comment">// 更新最短子串</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; minLength) &#123;</span><br><span class="line">                    minLength = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> <span class="variable">cl</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新窗口内的字符计数</span></span><br><span class="line">                <span class="keyword">if</span> (ht.containsKey(cl)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hs.get(cl).equals(ht.get(cl))) &#123;</span><br><span class="line">                        cnt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hs.put(cl, hs.get(cl) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + minLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="lc53-最大子数组和"><a href="#lc53-最大子数组和" class="headerlink" title="lc53 最大子数组和"></a>lc53 最大子数组和</h1><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中连续的 <strong>非空</strong> 元素序列</p>
<p>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>**进阶：**如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
</blockquote>
<p>贪心</p>
<p>记录当前位置的子数组和</p>
<ul>
<li><strong>不能在累加后立即重置窗口和</strong>，因为这会中断当前正在计算的有效子数组，导致丢失可能的最优解。</li>
<li>正确的做法是：<strong>只有当当前窗口和变为负数时，才重置窗口和</strong>。</li>
<li>这种逻辑符合贪心算法的思想，能够保证找到全局最优解。</li>
</ul>
<p>如果当前窗口的和变为负数，说明继续扩展这个窗口不会带来更大的和，因此重置 <code>cnt</code> 为 0，表示从下一个元素重新开始计算新的窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur+=nums[i];</span><br><span class="line">            res=Math.max(res,cur);</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lc56-合并区间"><a href="#lc56-合并区间" class="headerlink" title="lc56 合并区间"></a>lc56 合并区间</h1><blockquote>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 104</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li>
</ul>
</blockquote>
<p>排序和贪心算法</p>
<p>为什么贪心呢，我们要从局部最优挑选到整体最优</p>
<p>什么是局部最优：当前两个数组排序之后有重合，我们直接提取重合部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals,(x,y)-&gt;Integer.compare(x[<span class="number">0</span>],y[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] last=res.getLast();</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=last[<span class="number">1</span>])&#123;</span><br><span class="line">                last[<span class="number">1</span>]=Math.max(last[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">                last[<span class="number">0</span>]=Math.min(intervals[i][<span class="number">0</span>],last[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>首先，按照每个区间的起始点对所有区间进行升序排序。</li>
<li>这样做的目的是为了方便后续的合并操作，因为排序后，重叠或相邻的区间会连续地出现在数组中。</li>
</ul>
<h5 id="合并逻辑："><a href="#合并逻辑：" class="headerlink" title="合并逻辑："></a>合并逻辑：</h5><ul>
<li><p><strong>获取当前结果集中最后一个区间</strong>：<code>int[] last = res.getLast();</code></p>
</li>
<li><p>判断当前区间是否与最后一个区间重叠</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (intervals[i][0] &lt;= last[1])</span><br></pre></td></tr></table></figure>

<ul>
<li>如果当前区间的起始点小于等于最后一个区间的结束点，说明两者重叠。</li>
<li>更新最后一个区间的结束点为两者的最大值：<code>last[1] = Math.max(last[1], intervals[i][1]);</code></li>
<li>更新最后一个区间的起始点为两者的最小值：<code>last[0] = Math.min(intervals[i][0], last[0]);</code></li>
</ul>
</li>
<li><p>如果不重叠</p>
<ul>
<li>直接将当前区间添加到结果集中：<code>res.add(intervals[i]);</code></li>
</ul>
</li>
</ul>
</blockquote>
<p>利用Java数组作为引用类型的特性，可以直接修改结果集中最后一个元素来实现区间合并，而不需要创建新的数组对象，从而提高效率。</p>
<p><strong>修改 <code>last</code> 就可以直接对 <code>res</code> 列表中的最后一个区间进行修改</strong>。这是因为 Java 中的数组是<strong>引用类型</strong>，<code>last</code> 和 <code>res</code> 的最后一个元素实际上是同一个数组对象的引用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Allimac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/22/Hot100-1/">http://example.com/2025/04/22/Hot100-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">AllimacBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/hot100/">hot100</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/22/TechDuck200/" title="TechDuck200"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">TechDuck200</div></div><div class="info-2"><div class="info-item-1">两百java热门题目，五到六天结束，今天是第一天 2025年4月13日 Java当中HashMap的原理底层实现是数组加链表或者红黑树的形式。可以从如何将一个键值对放进哈希map当中来解释它的原理。首先通过hashcode计算key的哈希值，判断他要放入的数组位置，哈希值经过一定的哈希扰动处理避免高频率的哈希碰撞。假如哈希碰撞了，会使用链接法来解决。碰撞的位置会链接出链表来存储碰撞的元素。假如链表长度大于八，会转换成红黑树。同时，插入元素之后会检测整个哈希表的元素是不是到了负载因子规定的0.75这个阈值，如果到达了阈值，那就需要扩容到原来的二倍并且重新哈希 插入的具体操作是什么样的答案连接 我就不再详细整理一遍，之前的拾遗里面应该写过 Java当中ConcurrentHashMap...</div></div></div></a><a class="pagination-related" href="/2025/04/22/JavaBasic8Gu/" title="JavaBasic8Gu"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JavaBasic8Gu</div></div><div class="info-2"><div class="info-item-1">Java基础八股拾遗</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/22/Algorithm-HashMap/" title="Algorithm-HashMap"><img class="cover" src="https://s21.ax1x.com/2025/02/22/pElQ72q.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-22</div><div class="info-item-2">Algorithm-HashMap</div></div><div class="info-2"><div class="info-item-1">哈希表基础知识什么是哈希表哈希表页脚散列表 在官方的定义当中，哈希表是根据关键码的值而直接进行访问的数据结构 坦白来说，数组就是一张哈希表 数组的下标就是我们说的key，通过key可以直接访问数组中的元素 一般来说，哈希表都是用来快速判断一个元素是否出现在集合里 比如说我们要查询一个名字是否出现在学校当中 如果要枚举的话，时间复杂度就是O(n)。但如果使用哈希表，就是需要O(1) 为什么是常数级复杂度 因为我么你只需要初始化把这所学校里学生的名字都存在哈希表当中，在查询的时候通过索引就可以知道这个同学在不在学校当中了 将学生姓名映射到哈希表上就涉及到了hash function...</div></div></div></a><a class="pagination-related" href="/2025/01/29/%E8%93%9D%E6%A1%A5-2/" title="蓝桥-2"><img class="cover" src="https://s21.ax1x.com/2025/01/29/pEVw73q.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-29</div><div class="info-item-2">蓝桥-2</div></div><div class="info-2"><div class="info-item-1">删除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1：  12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]  示例 2： 12输入：head = [], val = 1输出：[]  示例 3： 12输入：head = [7,7,7,7], val = 7输出：[]  提示：  列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50   代码123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *    ...</div></div></div></a><a class="pagination-related" href="/2025/01/25/%E8%93%9D%E6%A1%A5-1/" title="蓝桥-1"><img class="cover" src="https://s21.ax1x.com/2025/01/24/pEEKSjx.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="info-item-2">蓝桥-1</div></div><div class="info-2"><div class="info-item-1">数组理论基础数组是存放在连续内存空间上的 相同类型 数据的 集合 在这之中，需要注意的两个点： 数组下标从零开始 数组内存空间的地址是连续的 正是因为数组在内存空间的地址是连续的 所以我们再删除或者增加元素的时候，就需要移动其他元素的地址 数组的元素不能删除 只能覆盖 cpp当中二维数组也是内存上连续分布的 二分查找力扣连接 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 元素有序那很好了，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，想一想是不是可以用二分法了 二分法第一种写法12345678910111213141516171819class Solution &#123;    public int search(int[] nums, int target) &#123;        int left=0;        int...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Allimac</div><div class="author-info-description">华丽的仓库存放着我简陋的思想</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AillemaCc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AillemaCc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="http://www.swindle.icu/#/Home" target="_blank" title="曾经的博客"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是小梦一场的大床</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lc1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">lc1 两数之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">lc49 字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94%E9%94%99%E8%AF%AF121-126-%E4%B8%AA%E9%80%9A%E8%BF%87%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">2.0.1.</span> <span class="toc-text">解答错误121 &#x2F; 126 个通过的测试用例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">lc128 最长连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E8%A7%A3%E6%9E%90"><span class="toc-number">3.0.1.</span> <span class="toc-text">代码逻辑解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-HashSet-%E5%8E%BB%E9%87%8D"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">1. 使用 HashSet 去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%81%8D%E5%8E%86-HashSet-%E5%AF%BB%E6%89%BE%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">2. 遍历 HashSet 寻找连续序列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">3.0.1.2.1.</span> <span class="toc-text">核心思想：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.0.1.2.2.</span> <span class="toc-text">扩展过程：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">3.0.2.</span> <span class="toc-text">为什么不需要显式排序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.0.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc283-%E7%A7%BB%E5%8A%A80"><span class="toc-number">4.</span> <span class="toc-text">lc283 移动0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">lc11 盛水最多的容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">6.</span> <span class="toc-text">lc15 三数之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">7.</span> <span class="toc-text">lc42 接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">7.1.</span> <span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E8%AF%A6%E7%BB%86%E6%B3%A8%E9%87%8A"><span class="toc-number">7.1.1.</span> <span class="toc-text">代码及详细注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="toc-number">7.1.2.</span> <span class="toc-text">详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">1. 问题背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">2. 核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%8F%98%E9%87%8F"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">3. 关键变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">7.1.2.4.</span> <span class="toc-text">4. 为什么可以用双指针？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%BB%E8%BE%91%E5%88%86%E8%A7%A3"><span class="toc-number">7.1.2.5.</span> <span class="toc-text">5. 逻辑分解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9B%B4%E6%96%B0%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6"><span class="toc-number">7.1.2.5.1.</span> <span class="toc-text">（1）更新最大高度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%AF%94%E8%BE%83%E4%B8%A4%E4%BE%A7%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6"><span class="toc-number">7.1.2.5.2.</span> <span class="toc-text">（2）比较两侧最大高度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.1.2.5.3.</span> <span class="toc-text">（3）终止条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">7.1.2.6.</span> <span class="toc-text">6. 时间复杂度和空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C"><span class="toc-number">7.1.3.</span> <span class="toc-text">示例运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">lc3 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">9.</span> <span class="toc-text">lc438 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">10.</span> <span class="toc-text">lc560 和为k的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E5%81%87%E8%AE%BE"><span class="toc-number">10.0.1.</span> <span class="toc-text">滑动窗口的核心假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B4%9F%E6%95%B0%E4%BC%9A%E7%A0%B4%E5%9D%8F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%81%87%E8%AE%BE%EF%BC%9F"><span class="toc-number">10.0.2.</span> <span class="toc-text">为什么负数会破坏滑动窗口的假设？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AA%97%E5%8F%A3%E5%92%8C%E4%B8%8D%E5%8D%95%E8%B0%83"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">1. 窗口和不单调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E6%B3%95%E7%A1%AE%E5%AE%9A%E4%BD%95%E6%97%B6%E6%94%B6%E7%BC%A9%E7%AA%97%E5%8F%A3"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">2. 无法确定何时收缩窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E9%80%82%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">10.0.3.</span> <span class="toc-text">更适合的方法：前缀和 + 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">10.0.3.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">10.0.3.2.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.4.</span> <span class="toc-text">对比两种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">10.0.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E6%80%9D%E8%B7%AF"><span class="toc-number">10.1.</span> <span class="toc-text">前缀和思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">11.</span> <span class="toc-text">lc239 滑动窗口最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">12.</span> <span class="toc-text">lc76 最小覆盖子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">13.</span> <span class="toc-text">lc53 最大子数组和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lc56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">14.</span> <span class="toc-text">lc56 合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-number">14.0.0.0.1.</span> <span class="toc-text">合并逻辑：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/JavaBasic8Gu/" title="JavaBasic8Gu">JavaBasic8Gu</a><time datetime="2025-04-22T10:30:18.000Z" title="发表于 2025-04-22 18:30:18">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/Hot100-1/" title="Hot100-1">Hot100-1</a><time datetime="2025-04-22T10:22:09.000Z" title="发表于 2025-04-22 18:22:09">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/TechDuck200/" title="TechDuck200">TechDuck200</a><time datetime="2025-04-22T10:20:48.000Z" title="发表于 2025-04-22 18:20:48">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-2/" title="12306Business-2">12306Business-2</a><time datetime="2025-04-22T10:14:27.000Z" title="发表于 2025-04-22 18:14:27">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-1/" title="12306Business-1">12306Business-1</a><time datetime="2025-04-22T10:10:07.000Z" title="发表于 2025-04-22 18:10:07">2025-04-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Allimac</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>