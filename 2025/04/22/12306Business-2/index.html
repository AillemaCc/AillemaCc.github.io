<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>12306Business-2 | AllimacBlog</title><meta name="author" content="Allimac"><meta name="copyright" content="Allimac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="解决海量下单并发压力；下单过程解析；">
<meta property="og:type" content="article">
<meta property="og:title" content="12306Business-2">
<meta property="og:url" content="http://example.com/2025/04/22/12306Business-2/index.html">
<meta property="og:site_name" content="AllimacBlog">
<meta property="og:description" content="解决海量下单并发压力；下单过程解析；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2025-04-22T10:14:27.000Z">
<meta property="article:modified_time" content="2025-04-22T10:16:53.629Z">
<meta property="article:author" content="Allimac">
<meta property="article:tag" content="12306业务梳理">
<meta property="article:tag" content="秒杀架构选型">
<meta property="article:tag" content="令牌桶缓存限流">
<meta property="article:tag" content="下单过程解析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "12306Business-2",
  "url": "http://example.com/2025/04/22/12306Business-2/",
  "image": "http://example.com/img/avatar.png",
  "datePublished": "2025-04-22T10:14:27.000Z",
  "dateModified": "2025-04-22T10:16:53.629Z",
  "author": [
    {
      "@type": "Person",
      "name": "Allimac",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/faviconcute.png"><link rel="canonical" href="http://example.com/2025/04/22/12306Business-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '12306Business-2',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/nature_top_image.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">AllimacBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">12306Business-2</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">12306Business-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-22T10:14:27.000Z" title="发表于 2025-04-22 18:14:27">2025-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-22T10:16:53.629Z" title="更新于 2025-04-22 18:16:53">2025-04-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/12306/">12306</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="如何解决海量下单并发压力"><a href="#如何解决海量下单并发压力" class="headerlink" title="如何解决海量下单并发压力"></a>如何解决海量下单并发压力</h1><p>换句话说，海量下单给我们带来了什么并发上的问题。结合业务来看，一辆车，甚至是所有的车，票数的总量是有限的。大量的请求都是无意义的，如何限制这些无意义的请求竞争，这其实是我们需要解决的问题</p>
<h2 id="传统秒杀架构–缓存-数据库"><a href="#传统秒杀架构–缓存-数据库" class="headerlink" title="传统秒杀架构–缓存+数据库"></a>传统秒杀架构–缓存+数据库</h2><p>第一时间我们可能想到通过余票缓存也可以进行限流，判断缓存当中剩下的数量可能就行了。我们可以先来说一下这一点，也就是传统的余票缓存方案</p>
<p>起到两个作用：展示余票数量和限制流量。将列车余票放到缓存中，充当限流作用，通过 LUA 脚本扣减余票后，扣减成功代表余票数量充足，才可以进入流程分配座位，并创建订单，扣减失败请求打回。</p>
<p>因为扣减列车站点余票涉及到比较多的扣减关系，所以这里要使用 LUA 脚本。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE58ORH"><img src="https://s21.ax1x.com/2025/04/21/pE58ORH.png" alt="pE58ORH.png"></a></p>
<h2 id="构建库存令牌容器，拆分限流和缓存"><a href="#构建库存令牌容器，拆分限流和缓存" class="headerlink" title="构建库存令牌容器，拆分限流和缓存"></a>构建库存令牌容器，拆分限流和缓存</h2><p>相对于上一种方案，拆分了一个令牌容器，其中存放的令牌就是列车余票数据。如果用户购买车票，需要先扣减令牌容器，扣减成功代表余票数量充足，扣减失败请求打回。</p>
<p>用户查询列表所看到的余票数量，通过余票缓存，而不是令牌容器。</p>
<p>扣减令牌容器后，对余票缓存并没有影响，只有在修改了座位表后，才会通过 Canal 形式监听并减少余票缓存。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE5G9df"><img src="https://s21.ax1x.com/2025/04/21/pE5G9df.png" alt="pE5G9df.png"></a></p>
<h2 id="为什么拆分令牌容器"><a href="#为什么拆分令牌容器" class="headerlink" title="为什么拆分令牌容器"></a>为什么拆分令牌容器</h2><p>在用户购买车票时，首先从令牌容器（它代表了余票库存）中扣减令牌，然后再扣减数据库，并通过 Binlog  同步更新余票缓存。</p>
<p>用户看到的是余票缓存，而令牌容器缓存则属于技术实现层面的内容，对用户透明。 </p>
<p>那么两者有什么不同呢？如果在传统秒杀架构中，余票缓存被用来展示列车余票数量并进行限流，遇到极端场景时——例如扣减完余票缓存后，系统宕机，导致数据库未能成功更新——就可能出现前端展示余票为 0，但数据库中实际还有库存的情况。</p>
<p>在这种情况下，就像电商平台的处理方式一样，余票为 0 的记录是不允许用户继续提交订单的。 而如果我们使用令牌容器架构，遇到类似问题时，令牌余量为 0，余票缓存正常，数据库也正常。此时，只要余票缓存不为  0，哪怕令牌容器中的令牌已耗尽，也可以允许用户下单，并通过该操作触发令牌容器的刷新。 </p>
<p>对于传统秒杀架构，如果发生类似情况，当某个商品库存为 0  时，可以通过定时任务或异步任务检查数据库与缓存的库存是否一致，不一致时同步更新缓存。</p>
<p>但这也带来了一些潜在风险。 例如，在宕机时，如果商品库存充足（例如 100），扣减缓存后变为 99，发生宕机时，数据库和缓存中的库存会不一致。直到库存余量为 0  之前，这种不一致可能会持续存在。</p>
<p>虽然这不会引发超卖，但商品显示不足也是一个问题。解决方案之一是通过定时任务频繁刷新商品余量，但对于大量商品而言，这样的做法会消耗较大的性能，而且在刷新过程中，数据库和缓存的状态可能不一致（例如缓存为 99，数据库仍为 100，这时需要将缓存库存恢复为 100？），这容易导致更多问题。</p>
<h1 id="下单过程"><a href="#下单过程" class="headerlink" title="下单过程"></a>下单过程</h1><h2 id="责任链校验"><a href="#责任链校验" class="headerlink" title="责任链校验"></a>责任链校验</h2><h3 id="非空校验"><a href="#非空校验" class="headerlink" title="非空校验"></a>非空校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购票流程过滤器之验证参数必填</span></span><br><span class="line"><span class="comment"> * 公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainPurchaseTicketParamNotNullChainHandler</span> <span class="keyword">implements</span> <span class="title class_">TrainPurchaseTicketChainFilter</span>&lt;PurchaseTicketReqDTO&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(PurchaseTicketReqDTO requestParam)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(requestParam.getTrainId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;列车标识不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(requestParam.getDeparture())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;出发站点不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(requestParam.getArrival())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;到达站点不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(requestParam.getPassengers())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;乘车人至少选择一位&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (PurchaseTicketPassengerDetailDTO each : requestParam.getPassengers()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StrUtil.isBlank(each.getPassengerId())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;乘车人不能为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(each.getSeatType())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;座位类型不能为空&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数合法性校验"><a href="#参数合法性校验" class="headerlink" title="参数合法性校验"></a>参数合法性校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购票流程过滤器之验证参数是否有效</span></span><br><span class="line"><span class="comment"> * 验证参数有效这个流程会大量交互缓存，为了优化性能需要使用 Lua。为了方便大家理解流程，这里使用多次调用缓存</span></span><br><span class="line"><span class="comment"> * 公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 标记为 Spring 的组件，会被自动扫描并注册到容器中</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// 自动生成构造函数，注入 final 修饰的依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainPurchaseTicketParamVerifyChainHandler</span> <span class="keyword">implements</span> <span class="title class_">TrainPurchaseTicketChainFilter</span>&lt;PurchaseTicketReqDTO&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrainMapper trainMapper; <span class="comment">// 列车数据访问对象，用于查询列车信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrainStationMapper trainStationMapper; <span class="comment">// 车站数据访问对象，用于查询车站信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistributedCache distributedCache; <span class="comment">// 分布式缓存对象，用于缓存和读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(PurchaseTicketReqDTO requestParam)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询会员购票车次是否存在，通过封装后安全的 Get 方法</span></span><br><span class="line">        <span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                TRAIN_INFO + requestParam.getTrainId(), <span class="comment">// 缓存键值，基于车次 ID 拼接</span></span><br><span class="line">                TrainDO.class, <span class="comment">// 返回的数据类型</span></span><br><span class="line">                () -&gt; trainMapper.selectById(requestParam.getTrainId()), <span class="comment">// 数据库查询逻辑</span></span><br><span class="line">                ADVANCE_TICKET_DAY, <span class="comment">// 缓存过期时间</span></span><br><span class="line">                TimeUnit.DAYS); <span class="comment">// 时间单位</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(trainDO)) &#123; <span class="comment">// 如果车次信息为空</span></span><br><span class="line">            <span class="comment">// 如果按照严谨逻辑，类似异常应该记录当前用户的 userid 并发送到风控中心</span></span><br><span class="line">            <span class="comment">// 如果一段时间有过几次的异常，直接封号处理。下述异常同理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;请检查车次是否存在&quot;</span>); <span class="comment">// 抛出客户端异常，提示车次不存在</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO，当前列车数据并没有通过定时任务每天生成最新的，所以需要隔离这个拦截。后期定时生成数据后删除该判断</span></span><br><span class="line">        <span class="keyword">if</span> (!EnvironmentUtil.isDevEnvironment()) &#123; <span class="comment">// 非开发环境时，进行以下校验</span></span><br><span class="line">            <span class="comment">// 查询车次是否已经发售</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().before(trainDO.getSaleTime())) &#123; <span class="comment">// 当前时间早于发售时间</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;列车车次暂未发售&quot;</span>); <span class="comment">// 抛出客户端异常，提示车次未发售</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查询车次是否在有效期内</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().after(trainDO.getDepartureTime())) &#123; <span class="comment">// 当前时间晚于出发时间</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;列车车次已出发禁止购票&quot;</span>); <span class="comment">// 抛出客户端异常，提示车次已出发</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 车站是否存在车次中，以及车站的顺序是否正确</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trainStationStopoverDetailStr</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                TRAIN_STATION_STOPOVER_DETAIL + requestParam.getTrainId(), <span class="comment">// 缓存键值，基于车次 ID 拼接</span></span><br><span class="line">                String.class, <span class="comment">// 返回的数据类型</span></span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 构建查询条件，查询指定车次的所有车站信息</span></span><br><span class="line">                    LambdaQueryWrapper&lt;TrainStationDO&gt; queryWrapper = Wrappers.lambdaQuery(TrainStationDO.class)</span><br><span class="line">                            .eq(TrainStationDO::getTrainId, requestParam.getTrainId()) <span class="comment">// 车次 ID 匹配</span></span><br><span class="line">                            .select(TrainStationDO::getDeparture); <span class="comment">// 只查询车站名称字段</span></span><br><span class="line">                    List&lt;TrainStationDO&gt; actualTrainStationList = trainStationMapper.selectList(queryWrapper); <span class="comment">// 执行查询</span></span><br><span class="line">                    <span class="keyword">return</span> CollUtil.isNotEmpty(actualTrainStationList) ? JSON.toJSONString(actualTrainStationList) : <span class="literal">null</span>; <span class="comment">// 转换为 JSON 字符串</span></span><br><span class="line">                &#125;,</span><br><span class="line">                Index12306Constant.ADVANCE_TICKET_DAY, <span class="comment">// 缓存过期时间</span></span><br><span class="line">                TimeUnit.DAYS <span class="comment">// 时间单位</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓存中的车站信息解析为列表</span></span><br><span class="line">        List&lt;TrainStationDO&gt; trainDOList = JSON.parseArray(trainStationStopoverDetailStr, TrainStationDO.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验车站顺序是否正确</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">validateStation</span> <span class="operator">=</span> validateStation(</span><br><span class="line">                trainDOList.stream().map(TrainStationDO::getDeparture).toList(), <span class="comment">// 提取车站名称列表</span></span><br><span class="line">                requestParam.getDeparture(), <span class="comment">// 出发车站</span></span><br><span class="line">                requestParam.getArrival() <span class="comment">// 到达车站</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!validateStation) &#123; <span class="comment">// 如果车站顺序不正确</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;列车车站数据错误&quot;</span>); <span class="comment">// 抛出客户端异常，提示车站数据错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>; <span class="comment">// 定义过滤器的执行顺序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验车站顺序是否正确</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stationList 车站名称列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startStation 出发车站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endStation 到达车站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStation</span><span class="params">(List&lt;String&gt; stationList, String startStation, String endStation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> stationList.indexOf(startStation); <span class="comment">// 获取出发车站的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> stationList.indexOf(endStation); <span class="comment">// 获取到达车站的索引</span></span><br><span class="line">        <span class="keyword">if</span> (index1 == -<span class="number">1</span> || index2 == -<span class="number">1</span>) &#123; <span class="comment">// 如果任意一个车站不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回非法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index2 &gt;= index1; <span class="comment">// 到达车站的索引必须大于等于出发车站的索引</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="为什么不需要验证中间站点？"><a href="#为什么不需要验证中间站点？" class="headerlink" title="为什么不需要验证中间站点？"></a>为什么不需要验证中间站点？</h2><ol>
<li><strong>业务场景限制</strong>：<ul>
<li>这是一个购票参数验证过滤器，不是完整的行程规划验证</li>
<li>用户购票时只能选择出发站和到达站，不能自由组合中间站点</li>
</ul>
</li>
<li><strong>数据来源可靠性</strong>：<ul>
<li><code>stationList</code>来自系统维护的经停站数据(<code>TRAIN_STATION_STOPOVER_DETAIL</code>)</li>
<li>经停站列表本身已经是有序的（从始发站到终点站的顺序）</li>
<li>只要出发站和到达站在该列表中，且顺序正确，中间站点必然有序</li>
</ul>
</li>
<li><strong>性能考虑</strong>：<ul>
<li>验证所有中间站点顺序会增加计算复杂度</li>
<li>在当前场景下属于过度验证</li>
</ul>
</li>
</ol>
<h2 id="当前设计的合理性"><a href="#当前设计的合理性" class="headerlink" title="当前设计的合理性"></a>当前设计的合理性</h2><ol>
<li><strong>符合最小够用原则</strong>：<ul>
<li>满足基础购票场景的需求</li>
<li>避免不必要的性能开销</li>
</ul>
</li>
<li><strong>数据完整性保障</strong>：<ul>
<li>经停站数据来自系统维护的可靠数据源</li>
<li>车站顺序的正确性由数据录入环节保证</li>
</ul>
</li>
<li><strong>异常处理</strong>：<ul>
<li>当车站不存在或顺序明显错误时能正确拦截</li>
<li>日志记录可供后续分析改进</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="库存验证"><a href="#库存验证" class="headerlink" title="库存验证"></a>库存验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购票流程过滤器之验证列车站点库存是否充足</span></span><br><span class="line"><span class="comment"> * 公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 标记为 Spring 的组件，会被自动扫描并注册到容器中</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// 自动生成构造函数，注入 final 修饰的依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainPurchaseTicketParamStockChainHandler</span> <span class="keyword">implements</span> <span class="title class_">TrainPurchaseTicketChainFilter</span>&lt;PurchaseTicketReqDTO&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SeatMarginCacheLoader seatMarginCacheLoader; <span class="comment">// 座位余票缓存加载器，用于加载座位余票信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistributedCache distributedCache; <span class="comment">// 分布式缓存对象，用于缓存和读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(PurchaseTicketReqDTO requestParam)</span> &#123;</span><br><span class="line">        <span class="comment">// 车次站点是否还有余票。如果用户提交多个乘车人非同一座位类型，拆分验证</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, requestParam.getTrainId(), requestParam.getDeparture(), requestParam.getArrival());</span><br><span class="line">        <span class="comment">// 将车次 ID、出发站、到达站拼接成缓存键值后缀，确保唯一性</span></span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">stringRedisTemplate</span> <span class="operator">=</span> (StringRedisTemplate) distributedCache.getInstance(); <span class="comment">// 获取 Redis 操作模板</span></span><br><span class="line">        List&lt;PurchaseTicketPassengerDetailDTO&gt; passengerDetails = requestParam.getPassengers(); <span class="comment">// 获取所有乘车人信息</span></span><br><span class="line">        <span class="comment">// 按照座位类型对乘车人进行分组</span></span><br><span class="line">        Map&lt;Integer, List&lt;PurchaseTicketPassengerDetailDTO&gt;&gt; seatTypeMap = passengerDetails.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType)); <span class="comment">// 按座位类型分组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个座位类型的乘车人信息，校验余票是否充足</span></span><br><span class="line">        seatTypeMap.forEach((seatType, passengerSeatDetails) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取指定座位类型的余票数量</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">stockObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, String.valueOf(seatType));</span><br><span class="line">            <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> Optional.ofNullable(stockObj).map(each -&gt; Integer.parseInt(each.toString())).orElseGet(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果缓存中没有余票信息，则从数据库或其他数据源加载</span></span><br><span class="line">                Map&lt;String, String&gt; seatMarginMap = seatMarginCacheLoader.load(</span><br><span class="line">                        String.valueOf(requestParam.getTrainId()), <span class="comment">// 车次 ID</span></span><br><span class="line">                        String.valueOf(seatType), <span class="comment">// 座位类型</span></span><br><span class="line">                        requestParam.getDeparture(), <span class="comment">// 出发站</span></span><br><span class="line">                        requestParam.getArrival() <span class="comment">// 到达站</span></span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> Optional.ofNullable(seatMarginMap.get(String.valueOf(seatType))).map(Integer::parseInt).orElse(<span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验余票是否充足</span></span><br><span class="line">            <span class="keyword">if</span> (stock &gt;= passengerSeatDetails.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 如果余票充足，继续处理下一个座位类型</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;列车站点已无余票&quot;</span>); <span class="comment">// 如果余票不足，抛出客户端异常</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>; <span class="comment">// 定义过滤器的执行顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们举个例子看看</p>
<p>对于输入的购票坐席信息</p>
<p>假如是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PurchaseTicketPassengerDetailDTO&gt; passengerDetails = [</span><br><span class="line">    &#123; name: <span class="string">&quot;张三&quot;</span>, seatType: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; name: <span class="string">&quot;李四&quot;</span>, seatType: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; name: <span class="string">&quot;王五&quot;</span>, seatType: <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; name: <span class="string">&quot;赵六&quot;</span>, seatType: <span class="number">2</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>按座位类型进行分组之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>: [&#123; name: <span class="string">&quot;李四&quot;</span>, seatType: <span class="number">0</span> &#125;],</span><br><span class="line">    <span class="number">1</span>: [</span><br><span class="line">        &#123; name: <span class="string">&quot;张三&quot;</span>, seatType: <span class="number">1</span> &#125;,</span><br><span class="line">        &#123; name: <span class="string">&quot;王五&quot;</span>, seatType: <span class="number">1</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="number">2</span>: [&#123; name: <span class="string">&quot;赵六&quot;</span>, seatType: <span class="number">2</span> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来对分组的数据进行遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">seatTypeMap.forEach((seatType, passengerSeatDetails) -&gt; &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">stockObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, String.valueOf(seatType));</span><br><span class="line">            <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> Optional.ofNullable(stockObj).map(each -&gt; Integer.parseInt(each.toString())).orElseGet(() -&gt; &#123;</span><br><span class="line">                Map&lt;String, String&gt; seatMarginMap = seatMarginCacheLoader.load(String.valueOf(requestParam.getTrainId()), String.valueOf(seatType), requestParam.getDeparture(), requestParam.getArrival());</span><br><span class="line">                <span class="keyword">return</span> Optional.ofNullable(seatMarginMap.get(String.valueOf(seatType))).map(Integer::parseInt).orElse(<span class="number">0</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (stock &gt;= passengerSeatDetails.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientException</span>(<span class="string">&quot;列车站点已无余票&quot;</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><ul>
<li><code>seatType</code>：当前迭代的键，表示座位类型（如 0、1、2）。</li>
<li><code>passengerSeatDetails</code>：当前迭代的值，表示该座位类型对应的乘客列表。</li>
</ul>
<p>比如说，遍历到坐席等级为1的时候，那<code>passengerSeatDetails</code>的size就是2.</p>
<p>对于每个 <code>seatType</code> 和对应的 <code>passengerSeatDetails</code>，执行以下逻辑：</p>
<h4 id="遍历逻辑"><a href="#遍历逻辑" class="headerlink" title="遍历逻辑"></a>遍历逻辑</h4><h5 id="首先获取缓存当中的余票数量"><a href="#首先获取缓存当中的余票数量" class="headerlink" title="首先获取缓存当中的余票数量"></a>首先获取缓存当中的余票数量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">stockObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, String.valueOf(seatType));</span><br></pre></td></tr></table></figure>

<p><code>keySuffix</code>是我们拼接出来的余票查询key</p>
<p><code>String.valueOf(seatType)</code> 是座位类型的值（如 <code>&quot;0&quot;</code>、<code>&quot;1&quot;</code>、<code>&quot;2&quot;</code>）。根据当前遍历的情况决定</p>
<p><code>stockObj</code> 是 Redis 中存储的余票数量，可能为 <code>null</code> 或字符串形式的数字。</p>
<h5 id="解析余票数量"><a href="#解析余票数量" class="headerlink" title="解析余票数量"></a>解析余票数量</h5><p>将 <code>stockObj</code> 转换为整数形式的余票数量。如果缓存中没有数据，则从数据库或其他数据源加载。</p>
<p><strong>检查缓存是否存在数据</strong>：</p>
<ul>
<li>如果 <code>stockObj</code> 不为 <code>null</code>，将其转换为整数。</li>
<li>如果 <code>stockObj</code> 为 <code>null</code>，执行 <code>orElseGet</code> 中的逻辑。</li>
</ul>
<p>也就是说，数据不存在缓存当中，就从数据库当中加载。但是这里面涉及到比较复杂的逻辑。</p>
<h6 id="缓存重建"><a href="#缓存重建" class="headerlink" title="缓存重建"></a>缓存重建</h6><p>下面涉及到一个座位缓存余量加载的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 座位余量缓存加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 声明为 Spring 的组件，由 Spring 容器管理</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// 自动生成构造函数，注入 final 修饰的依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeatMarginCacheLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrainMapper trainMapper; <span class="comment">// 列车信息 Mapper，用于查询列车基本信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SeatMapper seatMapper; <span class="comment">// 座位信息 Mapper，用于查询座位相关信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DistributedCache distributedCache; <span class="comment">// 分布式缓存工具类，封装 Redis 操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedissonClient redissonClient; <span class="comment">// Redisson 客户端，用于实现分布式锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrainStationService trainStationService; <span class="comment">// 列车站点服务，用于获取列车站点路线信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">load</span><span class="params">(String trainId, String seatType, String departure, String arrival)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储所有车次站点的余票信息，外层键是缓存键，内层值是余票信息</span></span><br><span class="line">        Map&lt;String, Map&lt;String, String&gt;&gt; trainStationRemainingTicketMaps = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建缓存键后缀，格式化为 &quot;trainId_departure_arrival&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> CacheUtil.buildKey(trainId, departure, arrival);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Redisson 分布式锁，避免多个线程同时加载相同的数据（缓存击穿问题）</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(String.format(LOCK_SAFE_LOAD_SEAT_MARGIN_GET, keySuffix));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁，确保同一时间只有一个线程可以执行加载逻辑</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 Redis 操作实例，用于操作 Redis 缓存</span></span><br><span class="line">            <span class="type">StringRedisTemplate</span> <span class="variable">stringRedisTemplate</span> <span class="operator">=</span> (StringRedisTemplate) distributedCache.getInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试从 Redis 缓存中获取指定座位类型的余票数量</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">quantityObj</span> <span class="operator">=</span> stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, seatType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果缓存未命中（即 quantityObj 为空或为空字符串）</span></span><br><span class="line">            <span class="keyword">if</span> (CacheUtil.isNullOrBlank(quantityObj)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从分布式缓存或数据库中获取列车信息</span></span><br><span class="line">                <span class="comment">// 如果缓存中没有数据，则调用 trainMapper.selectById 从数据库中加载</span></span><br><span class="line">                <span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">                        TRAIN_INFO + trainId, <span class="comment">// 缓存键，格式为 &quot;TRAIN_INFO_trainId&quot;</span></span><br><span class="line">                        TrainDO.class, <span class="comment">// 返回类型</span></span><br><span class="line">                        () -&gt; trainMapper.selectById(trainId), <span class="comment">// 数据库查询方法</span></span><br><span class="line">                        ADVANCE_TICKET_DAY, <span class="comment">// 缓存过期时间</span></span><br><span class="line">                        TimeUnit.DAYS <span class="comment">// 时间单位</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取列车的所有站点路线信息，包括出发站和到达站</span></span><br><span class="line">                List&lt;RouteDTO&gt; routeDTOList = trainStationService.listTrainStationRoute(</span><br><span class="line">                        trainId, <span class="comment">// 列车 ID</span></span><br><span class="line">                        trainDO.getStartStation(), <span class="comment">// 列车始发站</span></span><br><span class="line">                        trainDO.getEndStation() <span class="comment">// 列车终点站</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果站点路线信息不为空</span></span><br><span class="line">                <span class="keyword">if</span> (CollUtil.isNotEmpty(routeDTOList)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 根据列车类型处理不同的座位类型</span></span><br><span class="line">                    <span class="keyword">switch</span> (trainDO.getTrainType()) &#123; <span class="comment">// 列车类型：0 - 普通列车，1 - 动车，2 - 高铁</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">0</span> -&gt; &#123; <span class="comment">// 普通列车</span></span><br><span class="line">                            <span class="keyword">for</span> (RouteDTO each : routeDTOList) &#123; <span class="comment">// 遍历每个站点路线</span></span><br><span class="line">                                Map&lt;String, String&gt; trainStationRemainingTicket = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">// 存储当前站点的余票信息</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;0&quot;</span>, selectSeatMargin(trainId, <span class="number">0</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询硬座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;1&quot;</span>, selectSeatMargin(trainId, <span class="number">1</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询软座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;2&quot;</span>, selectSeatMargin(trainId, <span class="number">2</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询硬卧余票</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 构建缓存键后缀，格式为 &quot;trainId_startStation_endStation&quot;</span></span><br><span class="line">                                <span class="type">String</span> <span class="variable">actualKeySuffix</span> <span class="operator">=</span> CacheUtil.buildKey(trainId, each.getStartStation(), each.getEndStation());</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 将当前站点的余票信息存入外层 Map</span></span><br><span class="line">                                trainStationRemainingTicketMaps.put(TRAIN_STATION_REMAINING_TICKET + actualKeySuffix, trainStationRemainingTicket);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span> -&gt; &#123; <span class="comment">// 动车</span></span><br><span class="line">                            <span class="keyword">for</span> (RouteDTO each : routeDTOList) &#123; <span class="comment">// 遍历每个站点路线</span></span><br><span class="line">                                Map&lt;String, String&gt; trainStationRemainingTicket = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">// 存储当前站点的余票信息</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;3&quot;</span>, selectSeatMargin(trainId, <span class="number">3</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询一等座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;4&quot;</span>, selectSeatMargin(trainId, <span class="number">4</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询二等座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;5&quot;</span>, selectSeatMargin(trainId, <span class="number">5</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询商务座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;13&quot;</span>, selectSeatMargin(trainId, <span class="number">13</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询无座余票</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 构建缓存键后缀，格式为 &quot;trainId_startStation_endStation&quot;</span></span><br><span class="line">                                <span class="type">String</span> <span class="variable">actualKeySuffix</span> <span class="operator">=</span> CacheUtil.buildKey(trainId, each.getStartStation(), each.getEndStation());</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 将当前站点的余票信息存入外层 Map</span></span><br><span class="line">                                trainStationRemainingTicketMaps.put(TRAIN_STATION_REMAINING_TICKET + actualKeySuffix, trainStationRemainingTicket);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span> -&gt; &#123; <span class="comment">// 高铁</span></span><br><span class="line">                            <span class="keyword">for</span> (RouteDTO each : routeDTOList) &#123; <span class="comment">// 遍历每个站点路线</span></span><br><span class="line">                                Map&lt;String, String&gt; trainStationRemainingTicket = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">// 存储当前站点的余票信息</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;6&quot;</span>, selectSeatMargin(trainId, <span class="number">6</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询一等座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;7&quot;</span>, selectSeatMargin(trainId, <span class="number">7</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询二等座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;8&quot;</span>, selectSeatMargin(trainId, <span class="number">8</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询商务座余票</span></span><br><span class="line">                                trainStationRemainingTicket.put(<span class="string">&quot;13&quot;</span>, selectSeatMargin(trainId, <span class="number">13</span>, each.getStartStation(), each.getEndStation())); <span class="comment">// 查询无座余票</span></span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 构建缓存键后缀，格式为 &quot;trainId_startStation_endStation&quot;</span></span><br><span class="line">                                <span class="type">String</span> <span class="variable">actualKeySuffix</span> <span class="operator">=</span> CacheUtil.buildKey(trainId, each.getStartStation(), each.getEndStation());</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 将当前站点的余票信息存入外层 Map</span></span><br><span class="line">                                trainStationRemainingTicketMaps.put(TRAIN_STATION_REMAINING_TICKET + actualKeySuffix, trainStationRemainingTicket);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有站点路线信息</span></span><br><span class="line">                    Map&lt;String, String&gt; trainStationRemainingTicket = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); <span class="comment">// 存储当前站点的余票信息</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 根据列车类型获取支持的座位类型，并初始化默认余票为 &quot;0&quot;</span></span><br><span class="line">                    VehicleTypeEnum.findSeatTypesByCode(trainDO.getTrainType()) <span class="comment">// 获取列车类型对应的座位类型列表</span></span><br><span class="line">                            .forEach(each -&gt; trainStationRemainingTicket.put(String.valueOf(each), <span class="string">&quot;0&quot;</span>)); <span class="comment">// 默认余票为 0</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将当前站点的余票信息存入外层 Map</span></span><br><span class="line">                    trainStationRemainingTicketMaps.put(TRAIN_STATION_REMAINING_TICKET + keySuffix, trainStationRemainingTicket);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 批量写入 Redis 缓存，将所有站点的余票信息一次性写入</span></span><br><span class="line">                trainStationRemainingTicketMaps.forEach((cacheKey, cacheMap) -&gt;</span><br><span class="line">                        stringRedisTemplate.opsForHash().putAll(cacheKey, cacheMap)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 确保在任何情况下都释放分布式锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前车次、出发站、到达站的余票信息</span></span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(trainStationRemainingTicketMaps.get(TRAIN_STATION_REMAINING_TICKET + keySuffix))</span><br><span class="line">                .orElse(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;()); <span class="comment">// 如果没有找到对应的数据，返回空 Map</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询指定车次、座位类型、出发站和到达站的余票数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">selectSeatMargin</span><span class="params">(String trainId, Integer type, String departure, String arrival)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建查询条件，使用 MyBatis-Plus 的 LambdaQueryWrapper</span></span><br><span class="line">        LambdaQueryWrapper&lt;SeatDO&gt; queryWrapper = Wrappers.lambdaQuery(SeatDO.class)</span><br><span class="line">                .eq(SeatDO::getTrainId, trainId) <span class="comment">// 列车 ID</span></span><br><span class="line">                .eq(SeatDO::getSeatType, type) <span class="comment">// 座位类型</span></span><br><span class="line">                .eq(SeatDO::getSeatStatus, SeatStatusEnum.AVAILABLE.getCode()) <span class="comment">// 座位状态：可用</span></span><br><span class="line">                .eq(SeatDO::getStartStation, departure) <span class="comment">// 出发站</span></span><br><span class="line">                .eq(SeatDO::getEndStation, arrival); <span class="comment">// 到达站</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询符合条件的座位数量，并转换为字符串</span></span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(seatMapper.selectCount(queryWrapper)) <span class="comment">// 查询符合条件的座位数量</span></span><br><span class="line">                .map(String::valueOf) <span class="comment">// 转换为字符串</span></span><br><span class="line">                .orElse(<span class="string">&quot;0&quot;</span>); <span class="comment">// 如果查询结果为空，默认返回 &quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从头开始一点点吃透这段代码</p>
<hr>
<p>代码的主要目的：</p>
<p>系统会先获取分布式锁，然后从数据库中获取列车 <code>&quot;T123&quot;</code> 的信息和站点路线信息，根据列车类型计算不同座位类型的余量，将计算结果更新到 Redis 中，最后释放锁并返回所需的座位余量信息。这样，下次再查询相同的座位余量时，就可以直接从缓存中获取数据。主要的目的事实上是</p>
<p><strong>加载数据+重建缓存</strong></p>
<hr>
<p>构建Map，用来向Redis当中进行构建缓存。后面数据库当中查到的内容，就会放在这个Maps当中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, String&gt;&gt; trainStationRemainingTicketMaps = new LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<p>构建查询key</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String keySuffix = CacheUtil.buildKey(trainId, departure, arrival);</span><br></pre></td></tr></table></figure>

<p>对于坐席，用火车id和出发站到达站进行规约</p>
<hr>
<p>分布式锁＋双重判定锁</p>
<p>拿到分布式锁，防止大量并发请求打掉数据库</p>
<p>双重判定锁，进一步减少请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redissonClient.getLock(String.format(LOCK_SAFE_LOAD_SEAT_MARGIN_GET, keySuffix));</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">            StringRedisTemplate stringRedisTemplate = (StringRedisTemplate) distributedCache.getInstance();</span><br><span class="line">            Object quantityObj = stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, seatType);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>假如缓存仍然查询不到–<code>CacheUtil.isNullOrBlank(quantityObj)</code>，进行初步的构建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TrainDO trainDO = distributedCache.safeGet(</span><br><span class="line">        TRAIN_INFO + trainId,</span><br><span class="line">        TrainDO.class,</span><br><span class="line">        () -&gt; trainMapper.selectById(trainId),</span><br><span class="line">        ADVANCE_TICKET_DAY,</span><br><span class="line">        TimeUnit.DAYS</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>再看看缓存里面有没有，没有的话就去查数据库，再构建一下缓存，设置个有效期</p>
<p>这时候，trainDO一定有内容了，就是通过传入的trainId查询到的</p>
<hr>
<p>我们要思考的地方来了，根据我们之前的余票扣减逻辑，买一张票，不光要扣出发和到达的站点当中的票，还要依次扣除中间短程的票。之前有图说过这个流程，在这里贴一下</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE4lnFH"><img src="https://s21.ax1x.com/2025/04/19/pE4lnFH.png" alt="pE4lnFH.png"></a></p>
<p>那怎么计算这个中间站点呢？这个方法被我们封装起来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RouteDTO&gt; routeDTOList = trainStationService.listTrainStationRoute(trainId, trainDO.getStartStation(), trainDO.getEndStation());</span><br></pre></td></tr></table></figure>

<p><code>TrainStationServiceImpl</code>当中实现了这几个方法。同时，真正计算中间站点的逻辑，我们可以先贴出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 站点计算工具</span></span><br><span class="line"><span class="comment"> * 公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StationCalculateUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算出发站和终点站中间的站点（包含出发站和终点站）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stations     所有站点数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startStation 出发站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endStation   终点站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出发站和终点站中间的站点（包含出发站和终点站）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;RouteDTO&gt; <span class="title function_">throughStation</span><span class="params">(List&lt;String&gt; stations, String startStation, String endStation)</span> &#123;</span><br><span class="line">        List&lt;RouteDTO&gt; routesToDeduct = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> stations.indexOf(startStation);</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> stations.indexOf(endStation);</span><br><span class="line">        <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span> || endIndex &lt; <span class="number">0</span> || startIndex &gt;= endIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> routesToDeduct;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= endIndex; j++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">currentStation</span> <span class="operator">=</span> stations.get(i);</span><br><span class="line">                <span class="type">String</span> <span class="variable">nextStation</span> <span class="operator">=</span> stations.get(j);</span><br><span class="line">                <span class="type">RouteDTO</span> <span class="variable">routeDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteDTO</span>(currentStation, nextStation);</span><br><span class="line">                routesToDeduct.add(routeDTO);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> routesToDeduct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算出发站和终点站需要扣减余票的站点（包含出发站和终点站）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stations     所有站点数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startStation 出发站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endStation   终点站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出发站和终点站需要扣减余票的站点（包含出发站和终点站）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;RouteDTO&gt; <span class="title function_">takeoutStation</span><span class="params">(List&lt;String&gt; stations, String startStation, String endStation)</span> &#123;</span><br><span class="line">        List&lt;RouteDTO&gt; takeoutStationList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> stations.indexOf(startStation);</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> stations.indexOf(endStation);</span><br><span class="line">        <span class="keyword">if</span> (startIndex == -<span class="number">1</span> || endIndex == -<span class="number">1</span> || startIndex &gt;= endIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> takeoutStationList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (startIndex != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; startIndex; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; stations.size() - startIndex; j++) &#123;</span><br><span class="line">                    takeoutStationList.add(<span class="keyword">new</span> <span class="title class_">RouteDTO</span>(stations.get(i), stations.get(startIndex + j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; stations.size() &amp;&amp; i &lt; endIndex; j++) &#123;</span><br><span class="line">                takeoutStationList.add(<span class="keyword">new</span> <span class="title class_">RouteDTO</span>(stations.get(i), stations.get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> takeoutStationList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; stations = Arrays.asList(<span class="string">&quot;北京南&quot;</span>, <span class="string">&quot;济南西&quot;</span>, <span class="string">&quot;南京南&quot;</span>, <span class="string">&quot;杭州东&quot;</span>, <span class="string">&quot;宁波&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">startStation</span> <span class="operator">=</span> <span class="string">&quot;北京南&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">endStation</span> <span class="operator">=</span> <span class="string">&quot;南京南&quot;</span>;</span><br><span class="line">        StationCalculateUtil.takeoutStation(stations, startStation, endStation).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>主方法是编写的一个示例，我们要买一张北京南到南京南的票。</p>
<p>生成的扣减票是这样的</p>
<blockquote>
<p>RouteDTO(startStation&#x3D;北京南, endStation&#x3D;济南西)<br>RouteDTO(startStation&#x3D;北京南, endStation&#x3D;南京南)<br>RouteDTO(startStation&#x3D;北京南, endStation&#x3D;杭州东)<br>RouteDTO(startStation&#x3D;北京南, endStation&#x3D;宁波)<br>RouteDTO(startStation&#x3D;济南西, endStation&#x3D;南京南)<br>RouteDTO(startStation&#x3D;济南西, endStation&#x3D;杭州东)<br>RouteDTO(startStation&#x3D;济南西, endStation&#x3D;宁波)</p>
</blockquote>
<p>我们完整的看一下这个工具类</p>
<blockquote>
<h1 id="StationCalculateUtil-方法详解"><a href="#StationCalculateUtil-方法详解" class="headerlink" title="StationCalculateUtil 方法详解"></a>StationCalculateUtil 方法详解</h1><p>这个工具类主要用于处理铁路站点之间的路线计算，包含两个核心方法：<code>throughStation</code> 和 <code>takeoutStation</code>。下面我将详细解释每个方法的原理，并通过例子说明。</p>
<h2 id="1-throughStation-方法"><a href="#1-throughStation-方法" class="headerlink" title="1. throughStation 方法"></a>1. throughStation 方法</h2><p><strong>功能</strong>：计算出发站和终点站之间的所有可能路线（包含出发站和终点站）</p>
<p><strong>原理</strong>：</p>
<ol>
<li>首先找到出发站和终点站在站点列表中的索引位置</li>
<li>检查索引是否有效（都存在且出发站索引小于终点站索引）</li>
<li>使用双重循环生成所有可能的路线组合：<ul>
<li>外层循环从出发站开始到终点站前一个站</li>
<li>内层循环从外层当前站的下一个站开始到终点站</li>
</ul>
</li>
<li>将每对站点组合创建为 RouteDTO 对象并添加到结果列表</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stations = Arrays.asList(<span class="string">&quot;北京南&quot;</span>, <span class="string">&quot;济南西&quot;</span>, <span class="string">&quot;南京南&quot;</span>, <span class="string">&quot;杭州东&quot;</span>, <span class="string">&quot;宁波&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">startStation</span> <span class="operator">=</span> <span class="string">&quot;北京南&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">endStation</span> <span class="operator">=</span> <span class="string">&quot;南京南&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 北京南-&gt;济南西</span></span><br><span class="line"><span class="comment">// 北京南-&gt;南京南</span></span><br><span class="line"><span class="comment">// 济南西-&gt;南京南</span></span><br></pre></td></tr></table></figure>

<p><strong>详细过程</strong>：</p>
<ol>
<li>北京南(0)到南京南(2)</li>
<li>外层i&#x3D;0(北京南):<ul>
<li>j&#x3D;1: 北京南-&gt;济南西</li>
<li>j&#x3D;2: 北京南-&gt;南京南</li>
</ul>
</li>
<li>外层i&#x3D;1(济南西):<ul>
<li>j&#x3D;2: 济南西-&gt;南京南</li>
</ul>
</li>
<li>结束(i&#x3D;2不小于endIndex&#x3D;2)</li>
</ol>
<h2 id="2-takeoutStation-方法"><a href="#2-takeoutStation-方法" class="headerlink" title="2. takeoutStation 方法"></a>2. takeoutStation 方法</h2><p><strong>功能</strong>：计算需要扣减余票的站点组合（更复杂的路线组合）</p>
<p><strong>原理</strong>：</p>
<ol>
<li>同样先验证出发站和终点站索引的有效性</li>
<li>分两部分计算：<ul>
<li><strong>第一部分</strong>：处理出发站之前的所有站点与出发站之后站点的组合</li>
<li><strong>第二部分</strong>：处理出发站到终点站之间及之后的站点组合</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stations = Arrays.asList(<span class="string">&quot;北京南&quot;</span>, <span class="string">&quot;济南西&quot;</span>, <span class="string">&quot;南京南&quot;</span>, <span class="string">&quot;杭州东&quot;</span>, <span class="string">&quot;宁波&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">startStation</span> <span class="operator">=</span> <span class="string">&quot;济南西&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">endStation</span> <span class="operator">=</span> <span class="string">&quot;杭州东&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出包含：</span></span><br><span class="line"><span class="comment">// 北京南-&gt;南京南</span></span><br><span class="line"><span class="comment">// 北京南-&gt;杭州东</span></span><br><span class="line"><span class="comment">// 北京南-&gt;宁波</span></span><br><span class="line"><span class="comment">// 济南西-&gt;南京南</span></span><br><span class="line"><span class="comment">// 济南西-&gt;杭州东</span></span><br><span class="line"><span class="comment">// 济南西-&gt;宁波</span></span><br><span class="line"><span class="comment">// 南京南-&gt;杭州东</span></span><br><span class="line"><span class="comment">// 南京南-&gt;宁波</span></span><br></pre></td></tr></table></figure>

<p><strong>详细过程</strong>：</p>
<ol>
<li>济南西(1)到杭州东(3)</li>
<li>第一部分(startIndex!&#x3D;0):<ul>
<li>i&#x3D;0(北京南):<ul>
<li>j&#x3D;1: startIndex+j&#x3D;2 → 北京南-&gt;南京南</li>
<li>j&#x3D;2: startIndex+j&#x3D;3 → 北京南-&gt;杭州东</li>
<li>j&#x3D;3: startIndex+j&#x3D;4 → 北京南-&gt;宁波</li>
</ul>
</li>
</ul>
</li>
<li>第二部分(startIndex到endIndex):<ul>
<li>i&#x3D;1(济南西):<ul>
<li>j&#x3D;2: 济南西-&gt;南京南</li>
<li>j&#x3D;3: 济南西-&gt;杭州东</li>
<li>j&#x3D;4: 济南西-&gt;宁波</li>
</ul>
</li>
<li>i&#x3D;2(南京南):<ul>
<li>j&#x3D;3: 南京南-&gt;杭州东</li>
<li>j&#x3D;4: 南京南-&gt;宁波</li>
</ul>
</li>
<li>i&#x3D;3(杭州东):<ul>
<li>不满足i &lt; endIndex条件，跳过</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h2><table>
<thead>
<tr>
<th>方法</th>
<th>目的</th>
<th>生成路线范围</th>
<th>示例输入输出</th>
</tr>
</thead>
<tbody><tr>
<td>throughStation</td>
<td>生成两站间所有直达路线</td>
<td>仅出发站和终点站之间的组合</td>
<td>北京南-&gt;济南西,北京南-&gt;南京南,济南西-&gt;南京南</td>
</tr>
<tr>
<td>takeoutStation</td>
<td>生成需要扣减余票的路线</td>
<td>更广泛的范围，包含之前站点与之后站点的组合</td>
<td>包含之前站点与之后站点的更多组合</td>
</tr>
</tbody></table>
<p>这两个方法在铁路售票系统中非常有用，<code>throughStation</code>可能用于显示可选路线，而<code>takeoutStation</code>可能用于计算座位占用情况。</p>
</blockquote>
<p>之后我们就能通过这个方法，拿到扣减了哪些余票。</p>
<p>说了这么多，就为了解释一行代码。生成两站间所有直达路线，仅出发站和终点站之间站点的组合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RouteDTO&gt; routeDTOList = trainStationService.listTrainStationRoute(trainId, trainDO.getStartStation(), trainDO.getEndStation());</span><br></pre></td></tr></table></figure>

<p>我们要买一张从A-B的票，那就要保证AB之间，这个座位都是有票的状态</p>
<hr>
<p>接下来读取数据，读取两站之间直达路线的余票数量，并且构建缓存</p>
<p>涉及到type类型，在这里贴一个表格</p>
<table>
<thead>
<tr>
<th>type值</th>
<th>可能的座位类型</th>
<th>适用车型</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>硬座</td>
<td>普速列车</td>
</tr>
<tr>
<td>1</td>
<td>软座</td>
<td>普速列车</td>
</tr>
<tr>
<td>2</td>
<td>硬卧</td>
<td>普速列车</td>
</tr>
<tr>
<td>3</td>
<td>一等座</td>
<td>动车组</td>
</tr>
<tr>
<td>4</td>
<td>二等座</td>
<td>动车组</td>
</tr>
<tr>
<td>5</td>
<td>商务座</td>
<td>动车组</td>
</tr>
<tr>
<td>6</td>
<td>特等座</td>
<td>高铁</td>
</tr>
<tr>
<td>7</td>
<td>一等座</td>
<td>高铁</td>
</tr>
<tr>
<td>8</td>
<td>二等座</td>
<td>高铁</td>
</tr>
<tr>
<td>13</td>
<td>无座&#x2F;站票</td>
<td>所有车型</td>
</tr>
</tbody></table>
<p>不同车型座位的type也是不一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列车类型 0：高铁 1：动车 2：普通车</span><br></pre></td></tr></table></figure>

<p>以case0为例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span> -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (RouteDTO each : routeDTOList) &#123;</span><br><span class="line">        Map&lt;String, String&gt; trainStationRemainingTicket = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        trainStationRemainingTicket.put(<span class="string">&quot;0&quot;</span>, selectSeatMargin(trainId, <span class="number">0</span>, each.getStartStation(), each.getEndStation()));</span><br><span class="line">        trainStationRemainingTicket.put(<span class="string">&quot;1&quot;</span>, selectSeatMargin(trainId, <span class="number">1</span>, each.getStartStation(), each.getEndStation()));</span><br><span class="line">        trainStationRemainingTicket.put(<span class="string">&quot;2&quot;</span>, selectSeatMargin(trainId, <span class="number">2</span>, each.getStartStation(), each.getEndStation()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">actualKeySuffix</span> <span class="operator">=</span> CacheUtil.buildKey(trainId, each.getStartStation(), each.getEndStation());</span><br><span class="line">        trainStationRemainingTicketMaps.put(TRAIN_STATION_REMAINING_TICKET + actualKeySuffix, trainStationRemainingTicket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>selectSeatMargin</code>是从数据库当中查询余票数量的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">selectSeatMargin</span><span class="params">(String trainId, Integer type, String departure, String arrival)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeatDO&gt; queryWrapper = Wrappers.lambdaQuery(SeatDO.class)</span><br><span class="line">            .eq(SeatDO::getTrainId, trainId)</span><br><span class="line">            .eq(SeatDO::getSeatType, type)</span><br><span class="line">            .eq(SeatDO::getSeatStatus, SeatStatusEnum.AVAILABLE.getCode())</span><br><span class="line">            .eq(SeatDO::getStartStation, departure)</span><br><span class="line">            .eq(SeatDO::getEndStation, arrival);</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(seatMapper.selectCount(queryWrapper))</span><br><span class="line">            .map(String::valueOf)</span><br><span class="line">            .orElse(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>异常监察else块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; trainStationRemainingTicket = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    VehicleTypeEnum.findSeatTypesByCode(trainDO.getTrainType())</span><br><span class="line">            .forEach(each -&gt; trainStationRemainingTicket.put(String.valueOf(each), <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    trainStationRemainingTicketMaps.put(TRAIN_STATION_REMAINING_TICKET + keySuffix, trainStationRemainingTicket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个else其实就说明，我们没有在数据库当中维护这两个站点之间的路径信息，也就是说，要么这两个站点就是不可达的，要么就是数据有问题。为了防止超卖或者可能发生的数据异常情况，我们直接把站点之间的每个座位类型的余票写为0</p>
<hr>
<p><strong>将内存中的座位余量数据批量写入 Redis 缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainStationRemainingTicketMaps.forEach((cacheKey, cacheMap) -&gt; stringRedisTemplate.opsForHash().putAll(cacheKey, cacheMap));</span><br></pre></td></tr></table></figure>

<p><strong><code>forEach</code></strong>：遍历 Map 的每个键值对</p>
<ul>
<li><code>cacheKey</code>：Redis 的 Hash 结构键（如 <code>TRAIN_STATION_REMAINING_TICKET:G123_北京南_上海虹桥</code>）</li>
<li><code>cacheMap</code>：座位余量数据（如 <code>&#123;&quot;3&quot;:&quot;120&quot;, &quot;4&quot;:&quot;300&quot;, &quot;13&quot;:&quot;50&quot;&#125;</code></li>
</ul>
<p>当系统检测到以下情况时触发此操作：</p>
<ol>
<li><strong>缓存冷启动</strong>：首次加载列车余量数据</li>
<li><strong>数据修复</strong>：人工干预后重新计算余量</li>
<li><strong>定时同步</strong>：每日凌晨刷新余量</li>
</ol>
<p>这行代码是 <strong>高并发订票系统的核心缓存预热逻辑</strong>，直接关系到余量查询的性能和准确性</p>
<p>可以说我们上面的代码，都是为他服务的</p>
<hr>
<p>还记得我们在干什么吗？我们只是为了解释这一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int stock = Optional.ofNullable(stockObj).map(each -&gt; Integer.parseInt(each.toString())).orElseGet(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, String&gt; seatMarginMap = seatMarginCacheLoader.load(String.valueOf(requestParam.getTrainId()), String.valueOf(seatType), requestParam.getDeparture(), requestParam.getArrival());</span><br><span class="line">    return Optional.ofNullable(seatMarginMap.get(String.valueOf(seatType))).map(Integer::parseInt).orElse(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最终通过缓存重建的方式，拿到具体的stock数量</p>
<hr>
<p><code>假如stock &gt;= passengerSeatDetails.size()</code>皆大欢喜，校验通过</p>
<p>不然，地主家也没有余粮了</p>
<hr>
<p>到这一步，列车购票的责任链校验部分，结束了</p>
<p>我们解释了一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">purchaseTicketAbstractChainContext.handler(TicketChainMarkEnum.TRAIN_PURCHASE_TICKET_FILTER.name(), requestParam);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="购买车票V1"><a href="#购买车票V1" class="headerlink" title="购买车票V1"></a>购买车票V1</h2><p>先加锁，这个很重要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = environment.resolvePlaceholders(String.format(LOCK_PURCHASE_TICKETS, requestParam.getTrainId()));</span><br><span class="line">RLock lock = redissonClient.getLock(lockKey);</span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure>

<p>之后执行购买车票方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    return ticketService.executePurchaseTickets(requestParam);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="购买车票执行"><a href="#购买车票执行" class="headerlink" title="购买车票执行"></a>购买车票执行</h3><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Throwable.class)</span></span><br><span class="line"><span class="keyword">public</span> TicketPurchaseRespDTO <span class="title function_">executePurchaseTickets</span><span class="params">(PurchaseTicketReqDTO requestParam)</span> &#123;</span><br><span class="line">    List&lt;TicketOrderDetailRespDTO&gt; ticketOrderDetailResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">trainId</span> <span class="operator">=</span> requestParam.getTrainId();</span><br><span class="line">    <span class="comment">// 节假日高并发购票Redis能扛得住么？详情查看：https://nageoffer.com/12306/question</span></span><br><span class="line">    <span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">            TRAIN_INFO + trainId,</span><br><span class="line">            TrainDO.class,</span><br><span class="line">            () -&gt; trainMapper.selectById(trainId),</span><br><span class="line">            ADVANCE_TICKET_DAY,</span><br><span class="line">            TimeUnit.DAYS);</span><br><span class="line">    List&lt;TrainPurchaseTicketRespDTO&gt; trainPurchaseTicketResults = trainSeatTypeSelector.select(trainDO.getTrainType(), requestParam);</span><br><span class="line">    List&lt;TicketDO&gt; ticketDOList = trainPurchaseTicketResults.stream()</span><br><span class="line">            .map(each -&gt; TicketDO.builder()</span><br><span class="line">                    .username(UserContext.getUsername())</span><br><span class="line">                    .trainId(Long.parseLong(requestParam.getTrainId()))</span><br><span class="line">                    .carriageNumber(each.getCarriageNumber())</span><br><span class="line">                    .seatNumber(each.getSeatNumber())</span><br><span class="line">                    .passengerId(each.getPassengerId())</span><br><span class="line">                    .ticketStatus(TicketStatusEnum.UNPAID.getCode())</span><br><span class="line">                    .build())</span><br><span class="line">            .toList();</span><br><span class="line">    saveBatch(ticketDOList);</span><br><span class="line">    Result&lt;String&gt; ticketOrderResult;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;TicketOrderItemCreateRemoteReqDTO&gt; orderItemCreateRemoteReqDTOList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        trainPurchaseTicketResults.forEach(each -&gt; &#123;</span><br><span class="line">            <span class="type">TicketOrderItemCreateRemoteReqDTO</span> <span class="variable">orderItemCreateRemoteReqDTO</span> <span class="operator">=</span> TicketOrderItemCreateRemoteReqDTO.builder()</span><br><span class="line">                    .amount(each.getAmount())</span><br><span class="line">                    .carriageNumber(each.getCarriageNumber())</span><br><span class="line">                    .seatNumber(each.getSeatNumber())</span><br><span class="line">                    .idCard(each.getIdCard())</span><br><span class="line">                    .idType(each.getIdType())</span><br><span class="line">                    .phone(each.getPhone())</span><br><span class="line">                    .seatType(each.getSeatType())</span><br><span class="line">                    .ticketType(each.getUserType())</span><br><span class="line">                    .realName(each.getRealName())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">TicketOrderDetailRespDTO</span> <span class="variable">ticketOrderDetailRespDTO</span> <span class="operator">=</span> TicketOrderDetailRespDTO.builder()</span><br><span class="line">                    .amount(each.getAmount())</span><br><span class="line">                    .carriageNumber(each.getCarriageNumber())</span><br><span class="line">                    .seatNumber(each.getSeatNumber())</span><br><span class="line">                    .idCard(each.getIdCard())</span><br><span class="line">                    .idType(each.getIdType())</span><br><span class="line">                    .seatType(each.getSeatType())</span><br><span class="line">                    .ticketType(each.getUserType())</span><br><span class="line">                    .realName(each.getRealName())</span><br><span class="line">                    .build();</span><br><span class="line">            orderItemCreateRemoteReqDTOList.add(orderItemCreateRemoteReqDTO);</span><br><span class="line">            ticketOrderDetailResults.add(ticketOrderDetailRespDTO);</span><br><span class="line">        &#125;);</span><br><span class="line">        LambdaQueryWrapper&lt;TrainStationRelationDO&gt; queryWrapper = Wrappers.lambdaQuery(TrainStationRelationDO.class)</span><br><span class="line">                .eq(TrainStationRelationDO::getTrainId, trainId)</span><br><span class="line">                .eq(TrainStationRelationDO::getDeparture, requestParam.getDeparture())</span><br><span class="line">                .eq(TrainStationRelationDO::getArrival, requestParam.getArrival());</span><br><span class="line">        <span class="type">TrainStationRelationDO</span> <span class="variable">trainStationRelationDO</span> <span class="operator">=</span> trainStationRelationMapper.selectOne(queryWrapper);</span><br><span class="line">        <span class="type">TicketOrderCreateRemoteReqDTO</span> <span class="variable">orderCreateRemoteReqDTO</span> <span class="operator">=</span> TicketOrderCreateRemoteReqDTO.builder()</span><br><span class="line">                .departure(requestParam.getDeparture())</span><br><span class="line">                .arrival(requestParam.getArrival())</span><br><span class="line">                .orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                .source(SourceEnum.INTERNET.getCode())</span><br><span class="line">                .trainNumber(trainDO.getTrainNumber())</span><br><span class="line">                .departureTime(trainStationRelationDO.getDepartureTime())</span><br><span class="line">                .arrivalTime(trainStationRelationDO.getArrivalTime())</span><br><span class="line">                .ridingDate(trainStationRelationDO.getDepartureTime())</span><br><span class="line">                .userId(UserContext.getUserId())</span><br><span class="line">                .username(UserContext.getUsername())</span><br><span class="line">                .trainId(Long.parseLong(requestParam.getTrainId()))</span><br><span class="line">                .ticketOrderItems(orderItemCreateRemoteReqDTOList)</span><br><span class="line">                .build();</span><br><span class="line">        ticketOrderResult = ticketOrderRemoteService.createTicketOrder(orderCreateRemoteReqDTO);</span><br><span class="line">        <span class="keyword">if</span> (!ticketOrderResult.isSuccess() || StrUtil.isBlank(ticketOrderResult.getData())) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;订单服务调用失败，返回结果：&#123;&#125;&quot;</span>, ticketOrderResult.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;订单服务调用失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;远程调用订单服务创建错误，请求参数：&#123;&#125;&quot;</span>, JSON.toJSONString(requestParam), ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TicketPurchaseRespDTO</span>(ticketOrderResult.getData(), ticketOrderDetailResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>定义了一个车票订单详情返回参数实例，用来返回给前端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TicketOrderDetailRespDTO&gt; ticketOrderDetailResults = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<p>从请求当中拿到<code>trainId</code>，用<code>trainId</code>进行查询，也就是<code>safeGet</code>。总而言之查出数据来。校验已经为我们筛选了不合格的请求</p>
<hr>
<h4 id="购票时列车座位选择器"><a href="#购票时列车座位选择器" class="headerlink" title="购票时列车座位选择器"></a>购票时列车座位选择器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TrainPurchaseTicketRespDTO&gt; trainPurchaseTicketResults = trainSeatTypeSelector.select(trainDO.getTrainType(), requestParam);</span><br></pre></td></tr></table></figure>

<p>我们在这里，要解析<code>trainSeatTypeSelector.select(trainDO.getTrainType(), requestParam);</code>这个方法</p>
<hr>
<p>入参为列车类型，购票请求</p>
<p>因为不同的列车类型，有不同的座位类型。购票请求自不必多说，里面包含用户需要的座位类型</p>
<p>在这个座位选择器当中，我们首先关心的，应该是请求当中的passengers字段。通过查看购票请求入参，我们看到，乘车人字段是一个列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 乘车人</span><br><span class="line"> */</span><br><span class="line">private List&lt;PurchaseTicketPassengerDetailDTO&gt; passengers;</span><br></pre></td></tr></table></figure>

<p>再看看一个乘车人具体包含什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 购票乘车人详情实体</span></span><br><span class="line"><span class="comment"> * 公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseTicketPassengerDetailDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘车人 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String passengerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 座位类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer seatType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这样的设计，就自然实现了清爽的参数设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PurchaseTicketPassengerDetailDTO&gt; passengerDetails = requestParam.getPassengers();</span><br></pre></td></tr></table></figure>

<p>只需要这样就能提取出乘车人细节</p>
<hr>
<p>提取出乘车人细节，做座位和乘车人的映射和排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;PurchaseTicketPassengerDetailDTO&gt;&gt; seatTypeMap = passengerDetails.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType));</span><br></pre></td></tr></table></figure>

<p>后续可以按座位类型批量处理订单（如统一锁定同一类型的多个座位）</p>
<hr>
<p><code>actualResult</code> &#x3D; 同步包装的ArrayList，初始容量为座位类型数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TrainPurchaseTicketRespDTO&gt; actualResult = Collections.synchronizedList(new ArrayList&lt;&gt;(seatTypeMap.size()));</span><br></pre></td></tr></table></figure>

<hr>
<p>座位分配的操作是这个阶段做的事情</p>
<p>也就是<code>seatTypeMap.size() &gt; 1</code>的情况下，说明有不止一个座位类型需要购买。对于同时购买一等座和二等座这种情况，我们用线程池并行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Future列表，用于存储每个线程的异步任务结果</span></span><br><span class="line">         List&lt;Future&lt;List&lt;TrainPurchaseTicketRespDTO&gt;&gt;&gt; futureResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(seatTypeMap.size());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 遍历每种座位类型，提交任务到线程池</span></span><br><span class="line">         seatTypeMap.forEach((seatType, passengerSeatDetails) -&gt; &#123;</span><br><span class="line">             <span class="comment">// 提交任务到线程池，调用distributeSeats方法分配座位</span></span><br><span class="line">             Future&lt;List&lt;TrainPurchaseTicketRespDTO&gt;&gt; completableFuture = selectSeatThreadPoolExecutor</span><br><span class="line">                     .submit(() -&gt; distributeSeats(trainType, seatType, requestParam, passengerSeatDetails));</span><br><span class="line">             futureResults.add(completableFuture);</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 并行流处理所有Future任务，获取结果并合并到actualResult中</span></span><br><span class="line">         futureResults.parallelStream().forEach(completableFuture -&gt; &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 获取异步任务的结果，并将其添加到最终结果列表中</span></span><br><span class="line">                 actualResult.addAll(completableFuture.get());</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 <span class="comment">// 如果发生异常，抛出自定义的服务异常</span></span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;站点余票不足，请尝试更换座位类型或选择其它站点&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>

<p>分配座位的方法<code>distributeSeats</code>采用了抽象策略模板方法</p>
<hr>
<p>一直追溯到方法本身<code>executeResp</code>逻辑是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TrainPurchaseTicketRespDTO&gt; <span class="title function_">executeResp</span><span class="params">(SelectSeatDTO requestParam)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 分配座位  actualResult</span></span><br><span class="line">    List&lt;TrainPurchaseTicketRespDTO&gt; actualResult = selectSeats(requestParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 更新缓存（如果分配成功且缓存更新类型不是binlog）</span></span><br><span class="line">    <span class="keyword">if</span> (CollUtil.isNotEmpty(actualResult) &amp;&amp; !StrUtil.equals(ticketAvailabilityCacheUpdateType, <span class="string">&quot;binlog&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取列车ID、出发站和到达站</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">trainId</span> <span class="operator">=</span> requestParam.getRequestParam().getTrainId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">departure</span> <span class="operator">=</span> requestParam.getRequestParam().getDeparture();</span><br><span class="line">        <span class="type">String</span> <span class="variable">arrival</span> <span class="operator">=</span> requestParam.getRequestParam().getArrival();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Redis操作模板</span></span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">stringRedisTemplate</span> <span class="operator">=</span> (StringRedisTemplate) distributedCache.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询列车经过的所有站点路径</span></span><br><span class="line">        List&lt;RouteDTO&gt; routeDTOList = trainStationService.listTakeoutTrainStationRoute(trainId, departure, arrival);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个路径段，更新对应的余票缓存</span></span><br><span class="line">        routeDTOList.forEach(each -&gt; &#123;</span><br><span class="line">            <span class="comment">// 构建缓存Key后缀</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, trainId, each.getStartStation(), each.getEndStation());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扣减对应座位类型的余票数量</span></span><br><span class="line">            stringRedisTemplate.opsForHash().increment(</span><br><span class="line">                TRAIN_STATION_REMAINING_TICKET + keySuffix, <span class="comment">// 缓存Key</span></span><br><span class="line">                String.valueOf(requestParam.getSeatType()), <span class="comment">// 座位类型作为字段</span></span><br><span class="line">                -actualResult.size() <span class="comment">// 扣减值</span></span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回座位分配结果</span></span><br><span class="line">    <span class="keyword">return</span> actualResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>actualResult</code>是座位分配的结果，假如结果是存在的，那就执行缓存更新的逻辑</p>
<p><code>trainStationService.listTakeoutTrainStationRoute</code>查询列车经过的站点路径，但其实是扣减余票的具体路径，和买票的路径还是有区别的</p>
<p>之后就要遍历这些路径，更新该路径上的余票缓存</p>
<p>最后返回分配座位的结果，其实就是异步流程的线程执行结果</p>
<hr>
<p>再回到select方法当中，我们拿到了线程池当中的线程执行座位分配的结果，接下来就要处理这些分配的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并行流处理所有Future任务，获取结果并合并到actualResult中</span></span><br><span class="line">           futureResults.parallelStream().forEach(completableFuture -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 获取异步任务的结果，并将其添加到最终结果列表中</span></span><br><span class="line">                   actualResult.addAll(completableFuture.get());</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   <span class="comment">// 如果发生异常，抛出自定义的服务异常</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;站点余票不足，请尝试更换座位类型或选择其它站点&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>假如只有一种座位类型，那直接分配就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    seatTypeMap.forEach((seatType, passengerSeatDetails) -&gt; &#123;</span><br><span class="line">        List&lt;TrainPurchaseTicketRespDTO&gt; aggregationResult = distributeSeats(trainType, seatType, requestParam, passengerSeatDetails);</span><br><span class="line">        actualResult.addAll(aggregationResult);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>进行异常捕获，假如最终结果为空，或者结果数量与乘客数量不一致，则抛出异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (CollUtil.isEmpty(actualResult) || !Objects.equals(actualResult.size(), passengerDetails.size())) &#123;</span><br><span class="line">    throw new ServiceException(&quot;站点余票不足，请尝试更换座位类型或选择其它站点&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="选座后处理"><a href="#选座后处理" class="headerlink" title="选座后处理"></a>选座后处理</h4><p>到现在为止，我们只完成了座位分配的功能。而最终需要返回的，是TrainPurchaseTicketRespDTO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.opengoofy.index12306.biz.ticketservice.service.handler.ticket.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列车购票出参</span></span><br><span class="line"><span class="comment"> * 公众号：马丁玩编程，回复：加群，添加马哥微信（备注：12306）获取项目资料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainPurchaseTicketRespDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘车人 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String passengerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘车人姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘车人证件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer idType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘车人证件号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String idCard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘车人手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型 0：成人 1：儿童 2：学生 3：残疾军人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer userType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 席别类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer seatType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 车厢号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String carriageNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 座位号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String seatNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 座位金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还有很多字段，没有填充进去。但是购票服务和乘客服务是分离的，我们就需要进行远程调用</p>
<h5 id="远程调用收集乘客信息"><a href="#远程调用收集乘客信息" class="headerlink" title="远程调用收集乘客信息"></a>远程调用收集乘客信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 收集所有乘客ID，用于远程调用查询乘客详细信息</span><br><span class="line">        List&lt;String&gt; passengerIds = actualResult.stream()</span><br><span class="line">                .map(TrainPurchaseTicketRespDTO::getPassengerId)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        Result&lt;List&lt;PassengerRespDTO&gt;&gt; passengerRemoteResult;</span><br><span class="line">        List&lt;PassengerRespDTO&gt; passengerRemoteResultList;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    passengerRemoteResult = userRemoteService.listPassengerQueryByIds(UserContext.getUsername(), passengerIds);</span><br><span class="line">    <span class="keyword">if</span> (!passengerRemoteResult.isSuccess() || CollUtil.isEmpty(passengerRemoteResultList = passengerRemoteResult.getData())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;用户服务远程调用查询乘车人相关信息错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户服务远程调用查询乘车人相关信息错误，当前用户：&#123;&#125;，请求参数：&#123;&#125;&quot;</span>, UserContext.getUsername(), passengerIds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户服务远程调用查询乘车人相关信息错误，当前用户：&#123;&#125;，请求参数：&#123;&#125;&quot;</span>, UserContext.getUsername(), passengerIds, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>UserContext</code>进行username的get。在这里不多做赘述，总而言之在这一步拿到乘车人相关的详细信息</p>
<h5 id="构建返回"><a href="#构建返回" class="headerlink" title="构建返回"></a>构建返回</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历选座结果，填充乘客详细信息和票价信息</span></span><br><span class="line">        actualResult.forEach(each -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">passengerId</span> <span class="operator">=</span> each.getPassengerId();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据乘客ID匹配远程查询结果，填充乘客详细信息</span></span><br><span class="line">            passengerRemoteResultList.stream()</span><br><span class="line">                    .filter(item -&gt; Objects.equals(item.getId(), passengerId))</span><br><span class="line">                    .findFirst()</span><br><span class="line">                    .ifPresent(passenger -&gt; &#123;</span><br><span class="line">                        each.setIdCard(passenger.getIdCard()); <span class="comment">// 填充身份证信息</span></span><br><span class="line">                        each.setPhone(passenger.getPhone()); <span class="comment">// 填充手机号信息</span></span><br><span class="line">                        each.setUserType(passenger.getDiscountType()); <span class="comment">// 填充用户类型</span></span><br><span class="line">                        each.setIdType(passenger.getIdType()); <span class="comment">// 填充证件类型</span></span><br><span class="line">                        each.setRealName(passenger.getRealName()); <span class="comment">// 填充真实姓名</span></span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建查询条件，获取当前列车站点的票价信息</span></span><br><span class="line">            LambdaQueryWrapper&lt;TrainStationPriceDO&gt; lambdaQueryWrapper = Wrappers.lambdaQuery(TrainStationPriceDO.class)</span><br><span class="line">                    .eq(TrainStationPriceDO::getTrainId, requestParam.getTrainId()) <span class="comment">// 匹配列车ID</span></span><br><span class="line">                    .eq(TrainStationPriceDO::getDeparture, requestParam.getDeparture()) <span class="comment">// 匹配出发站</span></span><br><span class="line">                    .eq(TrainStationPriceDO::getArrival, requestParam.getArrival()) <span class="comment">// 匹配到达站</span></span><br><span class="line">                    .eq(TrainStationPriceDO::getSeatType, each.getSeatType()) <span class="comment">// 匹配座位类型</span></span><br><span class="line">                    .select(TrainStationPriceDO::getPrice); <span class="comment">// 只查询票价字段</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询票价信息并设置到结果对象中</span></span><br><span class="line">            <span class="type">TrainStationPriceDO</span> <span class="variable">trainStationPriceDO</span> <span class="operator">=</span> trainStationPriceMapper.selectOne(lambdaQueryWrapper);</span><br><span class="line">            each.setAmount(trainStationPriceDO.getPrice());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁定已选座位，防止重复购买</span></span><br><span class="line">        seatService.lockSeat(requestParam.getTrainId(), requestParam.getDeparture(), requestParam.getArrival(), actualResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最终选座结果</span></span><br><span class="line">        <span class="keyword">return</span> actualResult;</span><br></pre></td></tr></table></figure>

<hr>
<p>到这一步结束，我们又解决了一行代码，也就是购买车票执行当中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TrainPurchaseTicketRespDTO&gt; trainPurchaseTicketResults = trainSeatTypeSelector.select(trainDO.getTrainType(), requestParam);</span><br></pre></td></tr></table></figure>

<p>我们成功的把座位和乘车人绑定住了，但是这个时候我们还没有下单，只是说构建了一个合理的请求而已</p>
<p>后面创建订单，就需要我们买的票，也就是<code>trainPurchaseTicketResults</code></p>
<h4 id="调用订单远程方法创建订单"><a href="#调用订单远程方法创建订单" class="headerlink" title="调用订单远程方法创建订单"></a>调用订单远程方法创建订单</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的订单项请求DTO列表，用于存储批量创建订单项的请求数据</span></span><br><span class="line">List&lt;TicketOrderItemCreateRemoteReqDTO&gt; orderItemCreateRemoteReqDTOList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历选座结果列表（trainPurchaseTicketResults），为每个乘客生成订单项请求DTO和订单详情响应DTO</span></span><br><span class="line">trainPurchaseTicketResults.forEach(each -&gt; &#123;</span><br><span class="line">    <span class="comment">// 构建订单项请求DTO对象，封装每个乘客的购票信息</span></span><br><span class="line">    <span class="type">TicketOrderItemCreateRemoteReqDTO</span> <span class="variable">orderItemCreateRemoteReqDTO</span> <span class="operator">=</span> TicketOrderItemCreateRemoteReqDTO.builder()</span><br><span class="line">            .amount(each.getAmount()) <span class="comment">// 设置票价金额</span></span><br><span class="line">            .carriageNumber(each.getCarriageNumber()) <span class="comment">// 设置车厢号</span></span><br><span class="line">            .seatNumber(each.getSeatNumber()) <span class="comment">// 设置座位号</span></span><br><span class="line">            .idCard(each.getIdCard()) <span class="comment">// 设置身份证号码</span></span><br><span class="line">            .idType(each.getIdType()) <span class="comment">// 设置证件类型</span></span><br><span class="line">            .phone(each.getPhone()) <span class="comment">// 设置手机号码</span></span><br><span class="line">            .seatType(each.getSeatType()) <span class="comment">// 设置座位类型（如一等座、二等座）</span></span><br><span class="line">            .ticketType(each.getUserType()) <span class="comment">// 设置票种类型（如成人票、儿童票）</span></span><br><span class="line">            .realName(each.getRealName()) <span class="comment">// 设置乘客真实姓名</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建订单详情响应DTO对象，封装每个乘客的购票信息，用于返回给调用方</span></span><br><span class="line">    <span class="type">TicketOrderDetailRespDTO</span> <span class="variable">ticketOrderDetailRespDTO</span> <span class="operator">=</span> TicketOrderDetailRespDTO.builder()</span><br><span class="line">            .amount(each.getAmount()) <span class="comment">// 设置票价金额</span></span><br><span class="line">            .carriageNumber(each.getCarriageNumber()) <span class="comment">// 设置车厢号</span></span><br><span class="line">            .seatNumber(each.getSeatNumber()) <span class="comment">// 设置座位号</span></span><br><span class="line">            .idCard(each.getIdCard()) <span class="comment">// 设置身份证号码</span></span><br><span class="line">            .idType(each.getIdType()) <span class="comment">// 设置证件类型</span></span><br><span class="line">            .seatType(each.getSeatType()) <span class="comment">// 设置座位类型（如一等座、二等座）</span></span><br><span class="line">            .ticketType(each.getUserType()) <span class="comment">// 设置票种类型（如成人票、儿童票）</span></span><br><span class="line">            .realName(each.getRealName()) <span class="comment">// 设置乘客真实姓名</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将构建好的订单项请求DTO添加到订单项请求DTO列表中</span></span><br><span class="line">    orderItemCreateRemoteReqDTOList.add(orderItemCreateRemoteReqDTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将构建好的订单详情响应DTO添加到订单详情响应结果列表中</span></span><br><span class="line">    ticketOrderDetailResults.add(ticketOrderDetailRespDTO);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这两个DTO对象都是初步封装，并不能创建完整的请求或者响应。针对订单项请求DTO，把他假如到远程请求列表中，还需要其他字段参与这个远程请求调用，才能创建完整订单。而订单详情响应DTO，也不是完整的订单响应。但是是每个乘客的购票信息</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询列车站点关系表，获取列车在指定出发站和到达站的相关信息</span></span><br><span class="line">    LambdaQueryWrapper&lt;TrainStationRelationDO&gt; queryWrapper = Wrappers.lambdaQuery(TrainStationRelationDO.class)</span><br><span class="line">            .eq(TrainStationRelationDO::getTrainId, trainId) <span class="comment">// 列车ID</span></span><br><span class="line">            .eq(TrainStationRelationDO::getDeparture, requestParam.getDeparture()) <span class="comment">// 出发站</span></span><br><span class="line">            .eq(TrainStationRelationDO::getArrival, requestParam.getArrival()); <span class="comment">// 到达站</span></span><br><span class="line">    <span class="type">TrainStationRelationDO</span> <span class="variable">trainStationRelationDO</span> <span class="operator">=</span> trainStationRelationMapper.selectOne(queryWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建订单创建请求DTO，封装订单的全局信息</span></span><br><span class="line">    <span class="type">TicketOrderCreateRemoteReqDTO</span> <span class="variable">orderCreateRemoteReqDTO</span> <span class="operator">=</span> TicketOrderCreateRemoteReqDTO.builder()</span><br><span class="line">            .departure(requestParam.getDeparture()) <span class="comment">// 出发站</span></span><br><span class="line">            .arrival(requestParam.getArrival()) <span class="comment">// 到达站</span></span><br><span class="line">            .orderTime(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// 订单创建时间</span></span><br><span class="line">            .source(SourceEnum.INTERNET.getCode()) <span class="comment">// 订单来源（如互联网）</span></span><br><span class="line">            .trainNumber(trainDO.getTrainNumber()) <span class="comment">// 列车编号</span></span><br><span class="line">            .departureTime(trainStationRelationDO.getDepartureTime()) <span class="comment">// 出发时间</span></span><br><span class="line">            .arrivalTime(trainStationRelationDO.getArrivalTime()) <span class="comment">// 到达时间</span></span><br><span class="line">            .ridingDate(trainStationRelationDO.getDepartureTime()) <span class="comment">// 乘车日期</span></span><br><span class="line">            .userId(UserContext.getUserId()) <span class="comment">// 用户ID</span></span><br><span class="line">            .username(UserContext.getUsername()) <span class="comment">// 用户名</span></span><br><span class="line">            .trainId(Long.parseLong(requestParam.getTrainId())) <span class="comment">// 列车ID</span></span><br><span class="line">            .ticketOrderItems(orderItemCreateRemoteReqDTOList) <span class="comment">// 订单项列表</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用远程订单服务，创建订单并获取结果</span></span><br><span class="line">    ticketOrderResult = ticketOrderRemoteService.createTicketOrder(orderCreateRemoteReqDTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查订单创建是否成功，如果失败则记录日志并抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!ticketOrderResult.isSuccess() || StrUtil.isBlank(ticketOrderResult.getData())) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;订单服务调用失败，返回结果：&#123;&#125;&quot;</span>, ticketOrderResult.getMessage());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;订单服务调用失败&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的订单创建请求DTO，才是真正的开始远程调用的方式。我们可以看到上面产生的订单项列表，被加入到<code>ticketOrderItems</code>当中。封装订单的全局信息，并且远程服务创建订单</p>
<p>其实就是写数据库的过程</p>
<h4 id="返回购买车票执行结果"><a href="#返回购买车票执行结果" class="headerlink" title="返回购买车票执行结果"></a>返回购买车票执行结果</h4><p><code>TicketPurchaseRespDTO</code> 是一个数据传输对象（DTO），用于封装购票结果的所有信息。它的两个主要字段分别是：</p>
<ul>
<li><strong><code>ticketOrderResult.getData()</code></strong>：表示订单创建成功后返回的全局订单信息（如订单号、支付信息等）。</li>
<li><strong><code>ticketOrderDetailResults</code></strong>：表示每个乘客的订单详情信息（如座位号、身份证号码、票价金额等）。</li>
</ul>
<p>通过这两个字段，调用方可以同时获取到订单的全局信息和每个乘客的详细信息。</p>
<p>之后进行值的返回就可以了</p>
<h2 id="购买车票V2"><a href="#购买车票V2" class="headerlink" title="购买车票V2"></a>购买车票V2</h2><p>相对于上一种方案，拆分了一个令牌容器，其中存放的令牌就是列车余票数据。如果用户购买车票，需要先扣减令牌容器，扣减成功代表余票数量充足，扣减失败请求打回。</p>
<p>用户查询列表所看到的余票数量，通过余票缓存，而不是令牌容器。</p>
<p>扣减令牌容器后，对余票缓存并没有影响，只有在修改了座位表后，才会通过 Canal 形式监听并减少余票缓存。</p>
<h3 id="为什么要拆分令牌容器？"><a href="#为什么要拆分令牌容器？" class="headerlink" title="为什么要拆分令牌容器？"></a>为什么要拆分令牌容器？</h3><p>因为有个极端情况，比如说，扣减余票缓存容器成功后，然后应用宕机，导致余票缓存和余票数据库库存不一致。</p>
<p>如果有令牌容器，发现没有剩余可用令牌，那么我们可以进行兜底判断，即令牌余量为0，但余票缓存和数据库都正常，那么只要余票缓存不为0，即使令牌为空，用户仍可以发起下单请求，从而触发刷新令牌容器的操作。</p>
<h3 id="V1版本性能分析"><a href="#V1版本性能分析" class="headerlink" title="V1版本性能分析"></a>V1版本性能分析</h3><ul>
<li>粗粒度锁；V1版本锁的粒度是整个车次，也就是<ul>
<li><code>String lockKey = String.format(LOCK_PURCHASE_TICKETS, requestParam.getTrainId()); RLock lock = redissonClient.getLock(lockKey); // 整个车次一把锁</code><ul>
<li><strong>问题</strong>：所有购票请求（无论不同座位类型）串行处理，并发度极低</li>
<li><strong>影响</strong>：即使有余票，请求也必须排队，无法利用多核CPU</li>
</ul>
</li>
</ul>
</li>
<li>没有流量控制，可能分布式锁也算作流量控制机制，但我们刚才说锁的粒度太大了，性能并不是非常的高</li>
<li>锁抢占不公平</li>
<li>没有本地锁的使用，每次都要请求分布式锁，开销太大了</li>
</ul>
<h3 id="V2版本优化点1–添加令牌限流机制"><a href="#V2版本优化点1–添加令牌限流机制" class="headerlink" title="V2版本优化点1–添加令牌限流机制"></a>V2版本优化点1–添加令牌限流机制</h3><p>应对海量并发下，限流，防止超卖等场景，提供了一个快速错误机制。极端情况下提供可用性</p>
<p>接下来还是针对令牌限流代码的流程分析</p>
<h4 id="初始化令牌桶"><a href="#初始化令牌桶" class="headerlink" title="初始化令牌桶"></a>初始化令牌桶</h4><p>令牌桶的本质，也是一种缓存机制。所以涉及到缓存重建的部分，就要最先看一看缓存是不是已经被建立。但是在此之前，我们需要列车的基本信息和路径的信息，因为我们考虑的是余票数量的判断，所以这两个信息用来进行第一次的检索。同时把redis操作工具和令牌桶的Key都构建出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TrainDO</span> <span class="variable">trainDO</span> <span class="operator">=</span> distributedCache.safeGet(</span><br><span class="line">        TRAIN_INFO + requestParam.getTrainId(),</span><br><span class="line">        TrainDO.class,</span><br><span class="line">        () -&gt; trainMapper.selectById(requestParam.getTrainId()),</span><br><span class="line">        ADVANCE_TICKET_DAY,</span><br><span class="line">        TimeUnit.DAYS);</span><br><span class="line">List&lt;RouteDTO&gt; routeDTOList = trainStationService</span><br><span class="line">        .listTrainStationRoute(requestParam.getTrainId(), trainDO.getStartStation(), trainDO.getEndStation());</span><br><span class="line"><span class="type">StringRedisTemplate</span> <span class="variable">stringRedisTemplate</span> <span class="operator">=</span> (StringRedisTemplate) distributedCache.getInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">tokenBucketHashKey</span> <span class="operator">=</span> TICKET_AVAILABILITY_TOKEN_BUCKET + requestParam.getTrainId();</span><br></pre></td></tr></table></figure>



<p>之后真正进行令牌桶缓存的初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 检查令牌桶是否已存在 Boolean hasKey = distributedCache.hasKey(tokenBucketHashKey);</span><br></pre></td></tr></table></figure>

<p>假如不存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!hasKey）</span><br></pre></td></tr></table></figure>

<p>获取分布式锁；尝试锁快速返回错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redissonClient.getLock(String.format(LOCK_TICKET_AVAILABILITY_TOKEN_BUCKET, requestParam.getTrainId()));</span><br><span class="line">if (!lock.tryLock()) &#123;</span><br><span class="line">    throw new ServiceException(&quot;购票异常，请稍候再试&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重判定锁继续检查缓存构建情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 双重检查        Boolean hasKeyTwo = distributedCache.hasKey(tokenBucketHashKey);</span><br></pre></td></tr></table></figure>

<p>仍然没有构建出缓存的话，就进行令牌缓存的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasKeyTwo) &#123;</span><br><span class="line">    <span class="comment">//枚举类查询座位类型和数量</span></span><br><span class="line">    List&lt;Integer&gt; seatTypes = VehicleTypeEnum.findSeatTypesByCode(trainDO.getTrainType());</span><br><span class="line">    <span class="comment">//构建可用令牌Map</span></span><br><span class="line">    Map&lt;String, String&gt; ticketAvailabilityTokenMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//对每一个路径，构建令牌缓存</span></span><br><span class="line">    <span class="keyword">for</span> (RouteDTO each : routeDTOList) &#123;</span><br><span class="line">        <span class="comment">//底层用到mybatis的查询，在下面单独列一下动态sql语句，但这个方法就是能统计出来该列车，在路径上，座位类型的余票数量</span></span><br><span class="line">        List&lt;SeatTypeCountDTO&gt; seatTypeCountDTOList = seatService.listSeatTypeCount(Long.parseLong(requestParam.getTrainId()), each.getStartStation(), each.getEndStation(), seatTypes);</span><br><span class="line">        <span class="comment">//对每趟令牌，构建缓存。--为每个区间和座位类型初始化令牌</span></span><br><span class="line">        <span class="keyword">for</span> (SeatTypeCountDTO eachSeatTypeCountDTO : seatTypeCountDTOList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">buildCacheKey</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, each.getStartStation(), each.getEndStation(), eachSeatTypeCountDTO.getSeatType());</span><br><span class="line">            ticketAvailabilityTokenMap.put(buildCacheKey, String.valueOf(eachSeatTypeCountDTO.getSeatCount()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(TICKET_AVAILABILITY_TOKEN_BUCKET + requestParam.getTrainId(), ticketAvailabilityTokenMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取令牌–加载和初始化LUA脚本"><a href="#获取令牌–加载和初始化LUA脚本" class="headerlink" title="获取令牌–加载和初始化LUA脚本"></a>获取令牌–加载和初始化LUA脚本</h4><h5 id="脚本初始化（当前代码）"><a href="#脚本初始化（当前代码）" class="headerlink" title="脚本初始化（当前代码）"></a>脚本初始化（当前代码）</h5><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new DefaultRedisScript&lt;&gt;()</code></td>
<td>创建空脚本对象</td>
</tr>
<tr>
<td><code>setScriptSource()</code></td>
<td>绑定Lua脚本文件路径（如<code>classpath:lua/ticket_availability_token_bucket.lua</code>）</td>
</tr>
<tr>
<td><code>setResultType(String.class)</code></td>
<td>声明脚本返回值为JSON字符串</td>
</tr>
</tbody></table>
<p>LUA脚本方式获取令牌</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> inputString = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> actualKey = inputString</span><br><span class="line"><span class="keyword">local</span> colonIndex = <span class="built_in">string</span>.<span class="built_in">find</span>(actualKey, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> colonIndex ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    actualKey = <span class="built_in">string</span>.<span class="built_in">sub</span>(actualKey, colonIndex + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> jsonArrayStr = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> jsonArray = cjson.decode(jsonArrayStr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> result = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> tokenIsNull = <span class="literal">false</span></span><br><span class="line"><span class="keyword">local</span> tokenIsNullSeatTypeCounts = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, jsonObj <span class="keyword">in</span> <span class="built_in">ipairs</span>(jsonArray) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> seatType = <span class="built_in">tonumber</span>(jsonObj.seatType)</span><br><span class="line">    <span class="keyword">local</span> count = <span class="built_in">tonumber</span>(jsonObj.count)</span><br><span class="line">    <span class="keyword">local</span> actualInnerHashKey = actualKey .. <span class="string">&quot;_&quot;</span> .. seatType</span><br><span class="line">    <span class="keyword">local</span> ticketSeatAvailabilityTokenValue = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>], <span class="built_in">tostring</span>(actualInnerHashKey)))</span><br><span class="line">    <span class="keyword">if</span> ticketSeatAvailabilityTokenValue &lt; count <span class="keyword">then</span></span><br><span class="line">        tokenIsNull = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(tokenIsNullSeatTypeCounts, seatType .. <span class="string">&quot;_&quot;</span> .. count)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result[<span class="string">&#x27;tokenIsNull&#x27;</span>] = tokenIsNull</span><br><span class="line"><span class="keyword">if</span> tokenIsNull <span class="keyword">then</span></span><br><span class="line">    result[<span class="string">&#x27;tokenIsNullSeatTypeCounts&#x27;</span>] = tokenIsNullSeatTypeCounts</span><br><span class="line">    <span class="keyword">return</span> cjson.encode(result)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> alongJsonArrayStr = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> alongJsonArray = cjson.decode(alongJsonArrayStr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, jsonObj <span class="keyword">in</span> <span class="built_in">ipairs</span>(jsonArray) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> seatType = <span class="built_in">tonumber</span>(jsonObj.seatType)</span><br><span class="line">    <span class="keyword">local</span> count = <span class="built_in">tonumber</span>(jsonObj.count)</span><br><span class="line">    <span class="keyword">for</span> indexTwo, alongJsonObj <span class="keyword">in</span> <span class="built_in">ipairs</span>(alongJsonArray) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> startStation = <span class="built_in">tostring</span>(alongJsonObj.startStation)</span><br><span class="line">        <span class="keyword">local</span> endStation = <span class="built_in">tostring</span>(alongJsonObj.endStation)</span><br><span class="line">        <span class="keyword">local</span> actualInnerHashKey = startStation .. <span class="string">&quot;_&quot;</span> .. endStation .. <span class="string">&quot;_&quot;</span> .. seatType</span><br><span class="line">        redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], <span class="built_in">tostring</span>(actualInnerHashKey), -count)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cjson.encode(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个Lua脚本实现了列车余票令牌桶的核心操作逻辑，主要包含两个关键功能：令牌可用性检查和令牌扣减。下面我将详细解析这个脚本的执行流程和逻辑。</p>
<h2 id="脚本参数说明"><a href="#脚本参数说明" class="headerlink" title="脚本参数说明"></a>脚本参数说明</h2><ul>
<li><code>KEYS[1]</code>: 令牌桶的Redis Hash键名（如<code>ticket_availability_token_bucket:&#123;trainId&#125;</code>）</li>
<li><code>KEYS[2]</code>: 当前购票的出发站_到达站组合（如<code>北京_上海</code>）</li>
<li><code>ARGV[1]</code>: 座位类型需求量的JSON数组（如<code>[&#123;&quot;seatType&quot;:1,&quot;count&quot;:2&#125;]</code>）</li>
<li><code>ARGV[2]</code>: 受影响的区间路线JSON数组</li>
</ul>
<h2 id="执行流程解析"><a href="#执行流程解析" class="headerlink" title="执行流程解析"></a>执行流程解析</h2><h3 id="1-键名处理"><a href="#1-键名处理" class="headerlink" title="1. 键名处理"></a>1. 键名处理</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line"><span class="keyword">local</span> inputString = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> actualKey = inputString</span><br><span class="line"><span class="keyword">local</span> colonIndex = <span class="built_in">string</span>.<span class="built_in">find</span>(actualKey, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> colonIndex ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    actualKey = <span class="built_in">string</span>.<span class="built_in">sub</span>(actualKey, colonIndex + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>处理可能包含命名空间的键名，提取真正的区间标识（如从<code>route:北京_上海</code>提取<code>北京_上海</code>）</li>
</ul>
<h3 id="2-需求解析"><a href="#2-需求解析" class="headerlink" title="2. 需求解析"></a>2. 需求解析</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line"><span class="keyword">local</span> jsonArrayStr = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> jsonArray = cjson.decode(jsonArrayStr)</span><br></pre></td></tr></table></figure>

<ul>
<li>解析传入的座位需求JSON数组，转换为Lua table</li>
</ul>
<h3 id="3-令牌可用性检查"><a href="#3-令牌可用性检查" class="headerlink" title="3. 令牌可用性检查"></a>3. 令牌可用性检查</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line"><span class="keyword">for</span> index, jsonObj <span class="keyword">in</span> <span class="built_in">ipairs</span>(jsonArray) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> seatType = <span class="built_in">tonumber</span>(jsonObj.seatType)</span><br><span class="line">    <span class="keyword">local</span> count = <span class="built_in">tonumber</span>(jsonObj.count)</span><br><span class="line">    <span class="keyword">local</span> actualInnerHashKey = actualKey .. <span class="string">&quot;_&quot;</span> .. seatType</span><br><span class="line">    <span class="keyword">local</span> ticketSeatAvailabilityTokenValue = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>], <span class="built_in">tostring</span>(actualInnerHashKey)))</span><br><span class="line">    <span class="keyword">if</span> ticketSeatAvailabilityTokenValue &lt; count <span class="keyword">then</span></span><br><span class="line">        tokenIsNull = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(tokenIsNullSeatTypeCounts, seatType .. <span class="string">&quot;_&quot;</span> .. count)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>遍历每种座位类型需求</li>
<li>构造Redis Hash字段名（如<code>北京_上海_1</code>表示北京到上海的一等座）</li>
<li>检查剩余令牌是否足够满足需求</li>
<li>如果不足，记录不足的座位类型和数量</li>
</ul>
<h3 id="4-检查结果处理"><a href="#4-检查结果处理" class="headerlink" title="4. 检查结果处理"></a>4. 检查结果处理</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line">result[<span class="string">&#x27;tokenIsNull&#x27;</span>] = tokenIsNull</span><br><span class="line"><span class="keyword">if</span> tokenIsNull <span class="keyword">then</span></span><br><span class="line">    result[<span class="string">&#x27;tokenIsNullSeatTypeCounts&#x27;</span>] = tokenIsNullSeatTypeCounts</span><br><span class="line">    <span class="keyword">return</span> cjson.encode(result)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果有任何座位类型令牌不足，立即返回失败结果</li>
<li>返回格式示例：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;tokenIsNull&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;tokenIsNullSeatTypeCounts&quot;</span>: [<span class="string">&quot;1_2&quot;</span>] // 表示一等座缺<span class="number">2</span>张</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-令牌扣减（当令牌充足时）"><a href="#5-令牌扣减（当令牌充足时）" class="headerlink" title="5. 令牌扣减（当令牌充足时）"></a>5. 令牌扣减（当令牌充足时）</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line"><span class="keyword">local</span> alongJsonArrayStr = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> alongJsonArray = cjson.decode(alongJsonArrayStr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, jsonObj <span class="keyword">in</span> <span class="built_in">ipairs</span>(jsonArray) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> seatType = <span class="built_in">tonumber</span>(jsonObj.seatType)</span><br><span class="line">    <span class="keyword">local</span> count = <span class="built_in">tonumber</span>(jsonObj.count)</span><br><span class="line">    <span class="keyword">for</span> indexTwo, alongJsonObj <span class="keyword">in</span> <span class="built_in">ipairs</span>(alongJsonArray) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> startStation = <span class="built_in">tostring</span>(alongJsonObj.startStation)</span><br><span class="line">        <span class="keyword">local</span> endStation = <span class="built_in">tostring</span>(alongJsonObj.endStation)</span><br><span class="line">        <span class="keyword">local</span> actualInnerHashKey = startStation .. <span class="string">&quot;_&quot;</span> .. endStation .. <span class="string">&quot;_&quot;</span> .. seatType</span><br><span class="line">        redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], <span class="built_in">tostring</span>(actualInnerHashKey), -count)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解析受影响的区间路线数据</li>
<li>双重循环处理：<ul>
<li>外层循环：每种座位类型</li>
<li>内层循环：每个受影响的区间</li>
</ul>
</li>
<li>使用<code>hincrby</code>原子操作扣减令牌数量</li>
</ul>
<h3 id="6-返回成功结果"><a href="#6-返回成功结果" class="headerlink" title="6. 返回成功结果"></a>6. 返回成功结果</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lua</span><br><span class="line"><span class="keyword">return</span> cjson.encode(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回格式示例：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;tokenIsNull&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计亮点"><a href="#设计亮点" class="headerlink" title="设计亮点"></a>设计亮点</h2><ol>
<li><strong>原子性操作</strong>：整个检查-扣减流程在单个Lua脚本中完成，保证原子性</li>
<li><strong>细粒度控制</strong>：精确到具体区间和座位类型的令牌管理</li>
<li><strong>提前失败</strong>：在扣减前先检查可用性，避免部分扣减</li>
<li><strong>批量处理</strong>：支持同时处理多种座位类型的需求</li>
<li><strong>影响范围控制</strong>：通过<code>alongJsonArray</code>精确控制需要扣减的区间</li>
</ol>
<p>这个脚本是12306系统在高并发场景下保证车票不超卖的核心组件之一，通过Redis的原子特性和Lua脚本的能力，实现了高性能的余票控制</p>
</blockquote>
<p>通过单例模式获取Lua脚本实例（避免重复加载） </p>
<p>设置脚本路径为<code>lua/ticket_availability_token_bucket.lua</code> </p>
<p>指定返回类型为String（将返回JSON字符串）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultRedisScript&lt;String&gt; actual = Singleton.get(LUA_TICKET_AVAILABILITY_TOKEN_BUCKET_PATH, () -&gt; &#123;</span><br><span class="line">    DefaultRedisScript&lt;String&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    redisScript.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(LUA_TICKET_AVAILABILITY_TOKEN_BUCKET_PATH)));</span><br><span class="line">    redisScript.setResultType(String.class);</span><br><span class="line">    <span class="keyword">return</span> redisScript;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>假如token足够，返回成功结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> cjson.encode(&#123;</span><br><span class="line">    [<span class="string">&quot;tokenIsNull&quot;</span>] = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>但这段代码是没有真正执行LUA脚本的，我们还要在下面拿到takeout的票数</strong></p>
<h4 id="统计座位需求数量"><a href="#统计座位需求数量" class="headerlink" title="统计座位需求数量"></a>统计座位需求数量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Long&gt; seatTypeCountMap = requestParam.getPassengers().stream()</span><br><span class="line">        .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>如 <code>&#123;1: 2, 2: 3&#125;</code> 表示需要2张一等座，3张二等座</p>
<h4 id="构建座位需求JSON"><a href="#构建座位需求JSON" class="headerlink" title="构建座位需求JSON"></a>构建座位需求JSON</h4><p>将Map转换为Lua脚本可处理的JSON数组格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JSONArray</span> <span class="variable">seatTypeCountArray</span> <span class="operator">=</span> seatTypeCountMap.entrySet().stream()</span><br><span class="line">        .map(entry -&gt; &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            jsonObject.put(<span class="string">&quot;seatType&quot;</span>, String.valueOf(entry.getKey()));</span><br><span class="line">            jsonObject.put(<span class="string">&quot;count&quot;</span>, String.valueOf(entry.getValue()));</span><br><span class="line">            <span class="keyword">return</span> jsonObject;</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toCollection(JSONArray::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span>    <span class="punctuation">&#123;</span><span class="attr">&quot;seatType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span>    <span class="punctuation">&#123;</span><span class="attr">&quot;seatType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span><span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="获取takeout区间票"><a href="#获取takeout区间票" class="headerlink" title="获取takeout区间票"></a>获取takeout区间票</h4><p>我们一直说，余票的扣减不是简单的把出发站点和结束站点扣减就可以结束的，还有很多中间站点需要扣减</p>
<p>获取购票区间影响的所有子区间（如北京-上海会影响北京-济南、济南-上海等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RouteDTO&gt; takeoutRouteDTOList = trainStationService</span><br><span class="line">        .listTakeoutTrainStationRoute(requestParam.getTrainId(), requestParam.getDeparture(), requestParam.getArrival());</span><br></pre></td></tr></table></figure>

<h4 id="真正执行LUA脚本"><a href="#真正执行LUA脚本" class="headerlink" title="真正执行LUA脚本"></a>真正执行LUA脚本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">luaScriptKey</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;_&quot;</span>, requestParam.getDeparture(), requestParam.getArrival());</span><br><span class="line"><span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> stringRedisTemplate.execute(actual, Lists.newArrayList(tokenBucketHashKey, luaScriptKey), JSON.toJSONString(seatTypeCountArray), JSON.toJSONString(takeoutRouteDTOList));</span><br><span class="line"><span class="type">TokenResultDTO</span> <span class="variable">result</span> <span class="operator">=</span> JSON.parseObject(resultStr, TokenResultDTO.class);</span><br></pre></td></tr></table></figure>

<p>此时才会真正：</p>
<ol>
<li>将脚本发送到Redis服务端</li>
<li>执行原子化的令牌检查&#x2F;扣减逻辑</li>
<li>返回操作结果</li>
</ol>
<hr>
<p>现在我们又解释了一行代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TokenResultDTO</span> <span class="variable">tokenResult</span> <span class="operator">=</span> ticketAvailabilityTokenBucket.takeTokenFromBucket(requestParam);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="V2版本优化点2–令牌桶余票检查后的无票处理逻辑"><a href="#V2版本优化点2–令牌桶余票检查后的无票处理逻辑" class="headerlink" title="V2版本优化点2–令牌桶余票检查后的无票处理逻辑"></a>V2版本优化点2–<strong>令牌桶余票检查后的无票处理逻辑</strong></h3><p><strong>问题场景</strong>：当10万个并发请求同时发现令牌不足时，如果都去触发令牌刷新，会导致： Redis被击穿（大量重复查询余票） 数据库压力激增（查询真实库存）  </p>
<p><strong>解决方案</strong>：用内存标记（<code>tokenTicketsRefreshMap</code>）记录”已有线程在处理刷新”，后续请求直接返回无票</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TokenResultDTO</span> <span class="variable">tokenResult</span> <span class="operator">=</span> ticketAvailabilityTokenBucket.takeTokenFromBucket(requestParam);</span><br><span class="line"><span class="keyword">if</span> (tokenResult.getTokenIsNull()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">ifPresentObj</span> <span class="operator">=</span> tokenTicketsRefreshMap.getIfPresent(requestParam.getTrainId());</span><br><span class="line">    <span class="keyword">if</span> (ifPresentObj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TicketService.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokenTicketsRefreshMap.getIfPresent(requestParam.getTrainId()) == <span class="literal">null</span>) &#123;</span><br><span class="line">                ifPresentObj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                tokenTicketsRefreshMap.put(requestParam.getTrainId(), ifPresentObj);</span><br><span class="line">                tokenIsNullRefreshToken(requestParam, tokenResult);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServiceException</span>(<span class="string">&quot;列车站点已无余票&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们拿到token令牌桶处理的结果，在这里我们认为是无票情况。进入第一层IF逻辑</p>
<p>对于无票的请求，直接通过<code>Object ifPresentObj = tokenTicketsRefreshMap.getIfPresent(requestParam.getTrainId());</code>标记为刷新。</p>
<p>用内存标记（<code>tokenTicketsRefreshMap</code>）记录”已有线程在处理刷新”，后续请求直接返回无票</p>
<p>假设G123次列车余票归零：</p>
<ol>
<li>第一请求（线程A）<ul>
<li>令牌桶检查→无票</li>
<li><code>getIfPresent(&quot;G123&quot;)</code>→null</li>
<li>加锁→设置标记→触发异步刷新</li>
</ul>
</li>
<li>第2-10万请求<ul>
<li>令牌桶检查→无票</li>
<li><code>getIfPresent(&quot;G123&quot;)</code>→存在Object实例</li>
<li>直接抛出”无票”异常（耗时&lt;1μs）</li>
</ul>
</li>
</ol>
<p><strong>那为什么还需要判断一次呢</strong>。再判断<code>ifPresentObj == null</code>呢–我们都刷新了ifPresentObj ，怎么还会有空请求呢</p>
<p>原因就在于<strong>高并发场景下的竞态条件处理</strong></p>
<p>即使设置了刷新标记，仍可能有少量请求进入同步块，这是由以下时序关系决定的：</p>
<p>理想的时序图：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE5OwE4"><img src="https://s21.ax1x.com/2025/04/22/pE5OwE4.png" alt="pE5OwE4.png"></a></p>
<p>高并发下经过二次判断限制出现的时序图</p>
<blockquote>
<h3 id="三个关键时间点解释"><a href="#三个关键时间点解释" class="headerlink" title="三个关键时间点解释"></a><strong>三个关键时间点解释</strong></h3><ol>
<li><strong>第一重检查时刻</strong><ul>
<li>多个线程<strong>几乎同时</strong>执行<code>getIfPresent()</code>，此时缓存中确实没有标记</li>
<li>这些线程都会看到<code>ifPresentObj == null</code>的结果</li>
</ul>
</li>
<li><strong>锁竞争阶段</strong><ul>
<li>这些线程会<strong>串行进入</strong>同步块</li>
<li>但只有第一个获得锁的线程会看到真实的null状态</li>
</ul>
</li>
<li><strong>第二重检查时刻</strong><ul>
<li>后续获得锁的线程会发现标记<strong>已被第一个线程写入</strong></li>
<li>通过<code>synchronized</code>+双重检查保证最终只有<strong>一个线程</strong>执行初始化</li>
</ul>
</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE5XdQP"><img src="https://s21.ax1x.com/2025/04/22/pE5XdQP.png" alt="pE5XdQP.png"></a></p>
<p>那假如没有二次判断呢</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE5XfyV"><img src="https://s21.ax1x.com/2025/04/22/pE5XfyV.png" alt="pE5XfyV.png"></a></p>
<p>这样就要重复初始化了</p>
<h4 id="优化点总结"><a href="#优化点总结" class="headerlink" title="优化点总结"></a>优化点总结</h4><blockquote>
<p>这段代码通过<strong>三级防御体系</strong>实现高并发下的无票处理优化，其核心优化策略可总结为：</p>
<hr>
<h3 id="1-令牌桶快速熔断（第一级）"><a href="#1-令牌桶快速熔断（第一级）" class="headerlink" title="1. 令牌桶快速熔断（第一级）"></a><strong>1. 令牌桶快速熔断（第一级）</strong></h3><ul>
<li><strong>作用</strong>：通过Redis令牌桶预检查余票状态</li>
<li>优化点<ul>
<li>无票请求直接终止，避免进入核心逻辑</li>
<li>性能：纳秒级判断，拦截99%无效请求</li>
</ul>
</li>
</ul>
<h3 id="2-内存标记防击穿（第二级）"><a href="#2-内存标记防击穿（第二级）" class="headerlink" title="2. 内存标记防击穿（第二级）"></a><strong>2. 内存标记防击穿（第二级）</strong></h3><ul>
<li><strong>作用</strong>：用Guava Cache标记”无票状态”</li>
<li>优化点<ul>
<li>双重检查锁（DCL）保证标记只写入一次</li>
<li>拦截99.9%的重复无票请求，避免锁竞争</li>
<li>性能：单次内存访问约10ns</li>
</ul>
</li>
</ul>
<h3 id="3-异步刷新解耦（第三级）"><a href="#3-异步刷新解耦（第三级）" class="headerlink" title="3. 异步刷新解耦（第三级）"></a><strong>3. 异步刷新解耦（第三级）</strong></h3><ul>
<li><strong>作用</strong>：通过<code>tokenIsNullRefreshToken</code>异步更新令牌桶</li>
<li>优化点<ul>
<li>后台线程刷新数据，不阻塞请求线程。<strong>流量限制之后的请求线程还是会访问余票缓存的。</strong></li>
<li>保证最终一致性，避免同步等待</li>
</ul>
</li>
</ul>
<hr>
<h3 id="优化效果对比"><a href="#优化效果对比" class="headerlink" title="优化效果对比"></a><strong>优化效果对比</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th>传统方式</th>
<th>本优化方式</th>
<th>提升倍数</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无票请求处理耗时</strong></td>
<td>10ms（查DB+锁竞争）</td>
<td>0.01ms（内存访问）</td>
<td>1000x</td>
</tr>
<tr>
<td><strong>Redis QPS</strong></td>
<td>10万（全走缓存查询）</td>
<td>1（仅首请求触发刷新）</td>
<td>10万x</td>
</tr>
<tr>
<td><strong>锁竞争次数</strong></td>
<td>10万次（全局锁）</td>
<td>1次（单线程初始化）</td>
<td>10万x</td>
</tr>
</tbody></table>
<hr>
<h3 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a><strong>设计哲学</strong></h3><ul>
<li><strong>快速失败</strong>：让无效请求以最小开销退出</li>
<li><strong>空间换时间</strong>：用内存标记避免分布式锁竞争</li>
<li><strong>最终一致</strong>：容忍短暂状态不一致，换取吞吐量</li>
</ul>
<p>这种模式完美平衡了性能与正确性，是亿级并发场景的经典解决方案。</p>
</blockquote>
<h4 id="V2版本优化点3-锁逻辑优化"><a href="#V2版本优化点3-锁逻辑优化" class="headerlink" title="V2版本优化点3-锁逻辑优化"></a>V2版本优化点3-锁逻辑优化</h4><blockquote>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ol>
<li><strong>按座位类型分段加锁</strong><ul>
<li>将同一车次的购票请求按座位类型（如一等座、二等座）分组，不同座位类型的购票操作<strong>并行处理</strong></li>
<li>避免全局锁导致的性能瓶颈</li>
</ul>
</li>
<li><strong>双重锁机制</strong><ul>
<li><strong>本地锁（ReentrantLock）</strong>：解决单机JVM内的线程竞争</li>
<li><strong>分布式锁（Redisson RLock）</strong>：保证集群环境下跨节点的数据一致性</li>
</ul>
</li>
<li><strong>动态锁管理</strong><ul>
<li>根据车次+座位类型动态创建&#x2F;复用锁对象，避免内存泄漏</li>
</ul>
</li>
</ol>
<hr>
<h3 id="关键优化点"><a href="#关键优化点" class="headerlink" title="关键优化点"></a><strong>关键优化点</strong></h3><h4 id="1-细粒度锁拆分"><a href="#1-细粒度锁拆分" class="headerlink" title="1. 细粒度锁拆分"></a>1. <strong>细粒度锁拆分</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;Integer, List&lt;PurchaseTicketPassengerDetailDTO&gt;&gt; seatTypeMap = </span><br><span class="line">    requestParam.getPassengers().stream()</span><br><span class="line">        .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优化效果</p>
<p>：</p>
<ul>
<li>假设车次有3种座位类型，并发度提升<strong>3倍</strong></li>
<li>不同座位类型的购票请求完全并行</li>
</ul>
</li>
</ul>
<h4 id="2-本地锁优先"><a href="#2-本地锁优先" class="headerlink" title="2. 本地锁优先"></a>2. <strong>本地锁优先</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">localLock</span> <span class="operator">=</span> localLockMap.getIfPresent(lockKey);</span><br><span class="line"><span class="keyword">if</span> (localLock == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (TicketService.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((localLock = localLockMap.getIfPresent(lockKey)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            localLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">// 公平锁</span></span><br><span class="line">            localLockMap.put(lockKey, localLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优化设计</p>
<p>：</p>
<ul>
<li><strong>Guava Cache缓存锁对象</strong>：自动清理闲置锁</li>
<li><strong>双重检查锁</strong>：避免重复创建锁</li>
<li><strong>公平锁模式</strong>：防止线程饥饿，保证先到先得</li>
</ul>
</li>
</ul>
<h4 id="3-锁获取顺序优化"><a href="#3-锁获取顺序优化" class="headerlink" title="3. 锁获取顺序优化"></a>3. <strong>锁获取顺序优化</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">localLockList.forEach(ReentrantLock::lock);   <span class="comment">// 先获取所有本地锁</span></span><br><span class="line">distributedLockList.forEach(RLock::lock);     <span class="comment">// 再获取所有分布式锁</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>避免死锁</strong>：固定获取顺序（先本地后分布式）</li>
<li><strong>减少网络开销</strong>：本地锁检查通过后再尝试分布式锁</li>
</ul>
<h4 id="4-防御性释放锁"><a href="#4-防御性释放锁" class="headerlink" title="4. 防御性释放锁"></a>4. <strong>防御性释放锁</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    localLockList.forEach(localLock -&gt; &#123; <span class="comment">/* 释放逻辑 */</span> &#125;);</span><br><span class="line">    distributedLockList.forEach(distributedLock -&gt; &#123; <span class="comment">/* 释放逻辑 */</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>保证可靠性</strong>：即使业务逻辑抛出异常，锁必定释放</li>
<li><strong>健壮性处理</strong>：忽略释放时的异常（如锁已自动过期）</li>
</ul>
<hr>
<h3 id="性能收益对比"><a href="#性能收益对比" class="headerlink" title="性能收益对比"></a><strong>性能收益对比</strong></h3><table>
<thead>
<tr>
<th>场景</th>
<th>传统全局锁方案</th>
<th>本方案</th>
<th>提升倍数</th>
</tr>
</thead>
<tbody><tr>
<td>同一车次不同座位类型</td>
<td>完全串行</td>
<td>完全并行</td>
<td>N倍（N&#x3D;座位类型数）</td>
</tr>
<tr>
<td>锁竞争范围</td>
<td>所有购票请求</td>
<td>同座位类型请求</td>
<td>1&#x2F;M（M&#x3D;并发请求数）</td>
</tr>
<tr>
<td>分布式锁调用次数</td>
<td>每次购票都调用</td>
<td>本地锁过滤后减少60%+</td>
<td>2.5x</td>
</tr>
</tbody></table>
<hr>
<h3 id="设计哲学-1"><a href="#设计哲学-1" class="headerlink" title="设计哲学"></a><strong>设计哲学</strong></h3><ol>
<li>分层控制<ul>
<li>本地锁解决单机并发 → 分布式锁解决集群一致</li>
</ul>
</li>
<li>最小化临界区<ul>
<li>仅对必须同步的资源加锁</li>
</ul>
</li>
<li>失败友好性<ul>
<li>快速失败（本地锁竞争失败立即返回）</li>
<li>优雅降级（分布式锁超时自动放弃）</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="动态创建本地可重入锁–线程安全实现"><a href="#动态创建本地可重入锁–线程安全实现" class="headerlink" title="动态创建本地可重入锁–线程安全实现"></a>动态创建本地可重入锁–线程安全实现</h4><p>通过<code>车次ID+座位类型</code>生成唯一锁键（如<code>LOCK_TICKET:G123_1</code>表示G123次列车一等座锁），缩小锁的粒度，提高并发性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> String.format(LOCK_PURCHASE_TICKETS_V2, trainId, seatType);</span><br></pre></td></tr></table></figure>

<p>不同车次的购票操作完全并行 同一车次不同座位类型的购票操作也并行 只有同一车次同一座位类型的请求会竞争同一把锁</p>
<hr>
<p>双重检查锁模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (localLock == <span class="literal">null</span>) &#123;                      <span class="comment">// 第一重检查（无锁）</span></span><br><span class="line">    <span class="keyword">synchronized</span> (TicketService.class) &#123;      <span class="comment">// 加类锁</span></span><br><span class="line">        <span class="keyword">if</span> ((localLock = cache.get()) == <span class="literal">null</span>) &#123; <span class="comment">// 第二重检查（有锁）</span></span><br><span class="line">            <span class="comment">// 创建新锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有非常少（非常高并发的情况下）不止一个的线程才能看到<code>localLock == null</code>这个条件，进入条件判断的内部。但这样我们也进行了限制，进行同步块的修饰</p>
<p>避免多个线程同时通过第一重检查后，重复创建锁对象</p>
<p>99.9%的请求只需无锁的第一重检查</p>
<hr>
<p>同步块内部实现公平锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((localLock = localLockMap.getIfPresent(lockKey)) == <span class="literal">null</span>) &#123;</span><br><span class="line">    localLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    localLockMap.put(lockKey, localLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照线程请求锁的顺序（FIFO）获取锁 防止线程饥饿现象</p>
<p>实现顺序购买倒不是看这个，公平锁有效避免线程饥饿</p>
<blockquote>
<p>V1版本加锁代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ticketService.executePurchaseTickets(requestParam);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<p>获取本地锁和分布式锁</p>
<p><strong>严格顺序</strong>：先本地锁后分布式锁，避免死锁 <strong>原子性保证</strong>：只有所有锁都获取成功才会继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localLockList.add(localLock);</span><br><span class="line">RLock distributedLock = redissonClient.getFairLock(lockKey);</span><br><span class="line">distributedLockList.add(distributedLock);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>指标</th>
<th>V1（非公平）</th>
<th>V2（公平+细粒度）</th>
</tr>
</thead>
<tbody><tr>
<td>线程最大等待时间</td>
<td>5秒</td>
<td>200毫秒</td>
</tr>
<tr>
<td>线程等待时间方差</td>
<td>高（不稳定）</td>
<td>低（稳定）</td>
</tr>
<tr>
<td>10万QPS下超时请求数</td>
<td>约1%</td>
<td>&lt;0.01%</td>
</tr>
</tbody></table>
<h3 id="执行购票逻辑，释放锁"><a href="#执行购票逻辑，释放锁" class="headerlink" title="执行购票逻辑，释放锁"></a>执行购票逻辑，释放锁</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pE5zRNF"><img src="https://s21.ax1x.com/2025/04/22/pE5zRNF.png" alt="pE5zRNF.png"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    localLockList.forEach(ReentrantLock::lock);</span><br><span class="line">    distributedLockList.forEach(RLock::lock);</span><br><span class="line">    <span class="keyword">return</span> ticketService.executePurchaseTickets(requestParam);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>业务执行，这个方法还是没变化的，我们往上看看就有了</p>
<hr>
<p>释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    localLockList.forEach(localLock -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            localLock.unlock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    distributedLockList.forEach(distributedLock -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            distributedLock.unlock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆序释放</strong>：与获取顺序相反（分布式锁→本地锁） <strong>异常保护</strong>：<code>try-catch</code>确保释放失败不影响其他锁 <strong>可靠性</strong>：无论业务成功&#x2F;失败都保证释放</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Allimac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/22/12306Business-2/">http://example.com/2025/04/22/12306Business-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">AllimacBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/12306%E4%B8%9A%E5%8A%A1%E6%A2%B3%E7%90%86/">12306业务梳理</a><a class="post-meta__tags" href="/tags/%E7%A7%92%E6%9D%80%E6%9E%B6%E6%9E%84%E9%80%89%E5%9E%8B/">秒杀架构选型</a><a class="post-meta__tags" href="/tags/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%BC%93%E5%AD%98%E9%99%90%E6%B5%81/">令牌桶缓存限流</a><a class="post-meta__tags" href="/tags/%E4%B8%8B%E5%8D%95%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">下单过程解析</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/22/12306Business-1/" title="12306Business-1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">12306Business-1</div></div><div class="info-2"><div class="info-item-1">用户注册流程解析；列车信息查询V1;列车信息查询V2</div></div></div></a><a class="pagination-related" href="/2025/04/22/TechDuck200/" title="TechDuck200"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">TechDuck200</div></div><div class="info-2"><div class="info-item-1">两百java热门题目，五到六天结束，今天是第一天 2025年4月13日 Java当中HashMap的原理底层实现是数组加链表或者红黑树的形式。可以从如何将一个键值对放进哈希map当中来解释它的原理。首先通过hashcode计算key的哈希值，判断他要放入的数组位置，哈希值经过一定的哈希扰动处理避免高频率的哈希碰撞。假如哈希碰撞了，会使用链接法来解决。碰撞的位置会链接出链表来存储碰撞的元素。假如链表长度大于八，会转换成红黑树。同时，插入元素之后会检测整个哈希表的元素是不是到了负载因子规定的0.75这个阈值，如果到达了阈值，那就需要扩容到原来的二倍并且重新哈希 插入的具体操作是什么样的答案连接 我就不再详细整理一遍，之前的拾遗里面应该写过 Java当中ConcurrentHashMap...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/22/12306Business-1/" title="12306Business-1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-22</div><div class="info-item-2">12306Business-1</div></div><div class="info-2"><div class="info-item-1">用户注册流程解析；列车信息查询V1;列车信息查询V2</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Allimac</div><div class="author-info-description">华丽的仓库存放着我简陋的思想</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AillemaCc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AillemaCc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="http://www.swindle.icu/#/Home" target="_blank" title="曾经的博客"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是小梦一场的大床</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%B7%E9%87%8F%E4%B8%8B%E5%8D%95%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.</span> <span class="toc-text">如何解决海量下单并发压力</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%A7%92%E6%9D%80%E6%9E%B6%E6%9E%84%E2%80%93%E7%BC%93%E5%AD%98-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">传统秒杀架构–缓存+数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%BA%93%E5%AD%98%E4%BB%A4%E7%89%8C%E5%AE%B9%E5%99%A8%EF%BC%8C%E6%8B%86%E5%88%86%E9%99%90%E6%B5%81%E5%92%8C%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">构建库存令牌容器，拆分限流和缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%86%E5%88%86%E4%BB%A4%E7%89%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">为什么拆分令牌容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B%E5%8D%95%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">下单过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.</span> <span class="toc-text">责任链校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">非空校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%90%88%E6%B3%95%E6%80%A7%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">参数合法性校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E9%AA%8C%E8%AF%81%E4%B8%AD%E9%97%B4%E7%AB%99%E7%82%B9%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">为什么不需要验证中间站点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">当前设计的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E5%AD%98%E9%AA%8C%E8%AF%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">库存验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">遍历逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E8%8E%B7%E5%8F%96%E7%BC%93%E5%AD%98%E5%BD%93%E4%B8%AD%E7%9A%84%E4%BD%99%E7%A5%A8%E6%95%B0%E9%87%8F"><span class="toc-number">2.3.1.2.1.</span> <span class="toc-text">首先获取缓存当中的余票数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E4%BD%99%E7%A5%A8%E6%95%B0%E9%87%8F"><span class="toc-number">2.3.1.2.2.</span> <span class="toc-text">解析余票数量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%87%8D%E5%BB%BA"><span class="toc-number">2.3.1.2.2.1.</span> <span class="toc-text">缓存重建</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StationCalculateUtil-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">StationCalculateUtil 方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-throughStation-%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1. throughStation 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-takeoutStation-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2. takeoutStation 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-number">3.3.</span> <span class="toc-text">方法对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E4%B9%B0%E8%BD%A6%E7%A5%A8V1"><span class="toc-number">3.4.</span> <span class="toc-text">购买车票V1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AD%E4%B9%B0%E8%BD%A6%E7%A5%A8%E6%89%A7%E8%A1%8C"><span class="toc-number">3.4.1.</span> <span class="toc-text">购买车票执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AD%E7%A5%A8%E6%97%B6%E5%88%97%E8%BD%A6%E5%BA%A7%E4%BD%8D%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">购票时列车座位选择器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E5%BA%A7%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">选座后处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%94%B6%E9%9B%86%E4%B9%98%E5%AE%A2%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.1.3.1.</span> <span class="toc-text">远程调用收集乘客信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%94%E5%9B%9E"><span class="toc-number">3.4.1.3.2.</span> <span class="toc-text">构建返回</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%AE%A2%E5%8D%95%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E8%AE%A2%E5%8D%95"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">调用订单远程方法创建订单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E8%B4%AD%E4%B9%B0%E8%BD%A6%E7%A5%A8%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">返回购买车票执行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E4%B9%B0%E8%BD%A6%E7%A5%A8V2"><span class="toc-number">3.5.</span> <span class="toc-text">购买车票V2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8B%86%E5%88%86%E4%BB%A4%E7%89%8C%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">3.5.1.</span> <span class="toc-text">为什么要拆分令牌容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V1%E7%89%88%E6%9C%AC%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.5.2.</span> <span class="toc-text">V1版本性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V2%E7%89%88%E6%9C%AC%E4%BC%98%E5%8C%96%E7%82%B91%E2%80%93%E6%B7%BB%E5%8A%A0%E4%BB%A4%E7%89%8C%E9%99%90%E6%B5%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.3.</span> <span class="toc-text">V2版本优化点1–添加令牌限流机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">初始化令牌桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%A4%E7%89%8C%E2%80%93%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96LUA%E8%84%9A%E6%9C%AC"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">获取令牌–加载和初始化LUA脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%BD%93%E5%89%8D%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">3.5.3.2.1.</span> <span class="toc-text">脚本初始化（当前代码）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">3.6.</span> <span class="toc-text">脚本参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">执行流程解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%AE%E5%90%8D%E5%A4%84%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text">1. 键名处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9C%80%E6%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-number">3.7.2.</span> <span class="toc-text">2. 需求解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A4%E7%89%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">3.7.3.</span> <span class="toc-text">3. 令牌可用性检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A3%80%E6%9F%A5%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="toc-number">3.7.4.</span> <span class="toc-text">4. 检查结果处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A4%E7%89%8C%E6%89%A3%E5%87%8F%EF%BC%88%E5%BD%93%E4%BB%A4%E7%89%8C%E5%85%85%E8%B6%B3%E6%97%B6%EF%BC%89"><span class="toc-number">3.7.5.</span> <span class="toc-text">5. 令牌扣减（当令牌充足时）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%94%E5%9B%9E%E6%88%90%E5%8A%9F%E7%BB%93%E6%9E%9C"><span class="toc-number">3.7.6.</span> <span class="toc-text">6. 返回成功结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9"><span class="toc-number">3.8.</span> <span class="toc-text">设计亮点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%BA%A7%E4%BD%8D%E9%9C%80%E6%B1%82%E6%95%B0%E9%87%8F"><span class="toc-number">3.8.0.1.</span> <span class="toc-text">统计座位需求数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%BA%A7%E4%BD%8D%E9%9C%80%E6%B1%82JSON"><span class="toc-number">3.8.0.2.</span> <span class="toc-text">构建座位需求JSON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96takeout%E5%8C%BA%E9%97%B4%E7%A5%A8"><span class="toc-number">3.8.0.3.</span> <span class="toc-text">获取takeout区间票</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8CLUA%E8%84%9A%E6%9C%AC"><span class="toc-number">3.8.0.4.</span> <span class="toc-text">真正执行LUA脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V2%E7%89%88%E6%9C%AC%E4%BC%98%E5%8C%96%E7%82%B92%E2%80%93%E4%BB%A4%E7%89%8C%E6%A1%B6%E4%BD%99%E7%A5%A8%E6%A3%80%E6%9F%A5%E5%90%8E%E7%9A%84%E6%97%A0%E7%A5%A8%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">3.8.1.</span> <span class="toc-text">V2版本优化点2–令牌桶余票检查后的无票处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E6%97%B6%E9%97%B4%E7%82%B9%E8%A7%A3%E9%87%8A"><span class="toc-number">3.8.2.</span> <span class="toc-text">三个关键时间点解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.2.1.</span> <span class="toc-text">优化点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A4%E7%89%8C%E6%A1%B6%E5%BF%AB%E9%80%9F%E7%86%94%E6%96%AD%EF%BC%88%E7%AC%AC%E4%B8%80%E7%BA%A7%EF%BC%89"><span class="toc-number">3.8.3.</span> <span class="toc-text">1. 令牌桶快速熔断（第一级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%A0%87%E8%AE%B0%E9%98%B2%E5%87%BB%E7%A9%BF%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%BA%A7%EF%BC%89"><span class="toc-number">3.8.4.</span> <span class="toc-text">2. 内存标记防击穿（第二级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0%E8%A7%A3%E8%80%A6%EF%BC%88%E7%AC%AC%E4%B8%89%E7%BA%A7%EF%BC%89"><span class="toc-number">3.8.5.</span> <span class="toc-text">3. 异步刷新解耦（第三级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94"><span class="toc-number">3.8.6.</span> <span class="toc-text">优化效果对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">3.8.7.</span> <span class="toc-text">设计哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#V2%E7%89%88%E6%9C%AC%E4%BC%98%E5%8C%96%E7%82%B93-%E9%94%81%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96"><span class="toc-number">3.8.7.1.</span> <span class="toc-text">V2版本优化点3-锁逻辑优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">3.8.8.</span> <span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BC%98%E5%8C%96%E7%82%B9"><span class="toc-number">3.8.9.</span> <span class="toc-text">关键优化点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E6%8B%86%E5%88%86"><span class="toc-number">3.8.9.1.</span> <span class="toc-text">1. 细粒度锁拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%AC%E5%9C%B0%E9%94%81%E4%BC%98%E5%85%88"><span class="toc-number">3.8.9.2.</span> <span class="toc-text">2. 本地锁优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%94%81%E8%8E%B7%E5%8F%96%E9%A1%BA%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">3.8.9.3.</span> <span class="toc-text">3. 锁获取顺序优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%98%B2%E5%BE%A1%E6%80%A7%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">3.8.9.4.</span> <span class="toc-text">4. 防御性释放锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%94%B6%E7%9B%8A%E5%AF%B9%E6%AF%94"><span class="toc-number">3.8.10.</span> <span class="toc-text">性能收益对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6-1"><span class="toc-number">3.8.11.</span> <span class="toc-text">设计哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E2%80%93%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.11.1.</span> <span class="toc-text">动态创建本地可重入锁–线程安全实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%B4%AD%E7%A5%A8%E9%80%BB%E8%BE%91%EF%BC%8C%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">3.8.12.</span> <span class="toc-text">执行购票逻辑，释放锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/JavaBasic8Gu/" title="JavaBasic8Gu">JavaBasic8Gu</a><time datetime="2025-04-22T10:30:18.000Z" title="发表于 2025-04-22 18:30:18">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/Hot100-1/" title="Hot100-1">Hot100-1</a><time datetime="2025-04-22T10:22:09.000Z" title="发表于 2025-04-22 18:22:09">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/TechDuck200/" title="TechDuck200">TechDuck200</a><time datetime="2025-04-22T10:20:48.000Z" title="发表于 2025-04-22 18:20:48">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-2/" title="12306Business-2">12306Business-2</a><time datetime="2025-04-22T10:14:27.000Z" title="发表于 2025-04-22 18:14:27">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-1/" title="12306Business-1">12306Business-1</a><time datetime="2025-04-22T10:10:07.000Z" title="发表于 2025-04-22 18:10:07">2025-04-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Allimac</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>