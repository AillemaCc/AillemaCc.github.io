<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>A-First-Look-At-Kafka | AllimacBlog</title><meta name="author" content="Allimac"><meta name="copyright" content="Allimac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="初探Kafka，一些关于Kafka的问题">
<meta property="og:type" content="article">
<meta property="og:title" content="A-First-Look-At-Kafka">
<meta property="og:url" content="http://example.com/2025/03/15/A-First-Look-At-Kafka/index.html">
<meta property="og:site_name" content="AllimacBlog">
<meta property="og:description" content="初探Kafka，一些关于Kafka的问题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2025/03/15/pEaUHDP.png">
<meta property="article:published_time" content="2025-03-15T05:08:55.000Z">
<meta property="article:modified_time" content="2025-03-15T05:12:31.249Z">
<meta property="article:author" content="Allimac">
<meta property="article:tag" content="消息队列">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2025/03/15/pEaUHDP.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "A-First-Look-At-Kafka",
  "url": "http://example.com/2025/03/15/A-First-Look-At-Kafka/",
  "image": "https://s21.ax1x.com/2025/03/15/pEaUHDP.png",
  "datePublished": "2025-03-15T05:08:55.000Z",
  "dateModified": "2025-03-15T05:12:31.249Z",
  "author": [
    {
      "@type": "Person",
      "name": "Allimac",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/faviconcute.png"><link rel="canonical" href="http://example.com/2025/03/15/A-First-Look-At-Kafka/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'A-First-Look-At-Kafka',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s21.ax1x.com/2025/03/15/pEaUHDP.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">AllimacBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">A-First-Look-At-Kafka</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">A-First-Look-At-Kafka</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-15T05:08:55.000Z" title="发表于 2025-03-15 13:08:55">2025-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-15T05:12:31.249Z" title="更新于 2025-03-15 13:12:31">2025-03-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="什么是kafka"><a href="#什么是kafka" class="headerlink" title="什么是kafka"></a>什么是kafka</h1><p>Kafka 是由 <code>Linkedin</code> 公司开发的，它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的<strong>基于发布订阅模式的消息引擎系统</strong>。</p>
<h1 id="为什么是Kafka"><a href="#为什么是Kafka" class="headerlink" title="为什么是Kafka"></a>为什么是Kafka</h1><blockquote>
<p>目前市面上比较主流的开源消息队列包括 Kafka、RocketMQ、RabbtiMQ 等，要从中选择出一个最合适的消息队列，则需要根据公司的业务，并结合<strong>功能、性能、可靠性、可用性以及社区和生态</strong>等方面进行综合考量。</p>
<p>从这些角度来说，Kafka 很好的满足了这些需求：</p>
<ul>
<li><strong>功能丰富</strong>：Kafka 提供了丰富的功能，其特性包括消息堆积、可靠性、消息顺序性、幂等性和消息回溯等，可以很好的满足各种业务场景的需求。</li>
<li><strong>高性能</strong>：作为为大数据而生的消息队列，Kafka 在处理高吞吐量和大规模数据传输方面表现非凡，具有很高的性能表现。</li>
<li><strong>可靠性</strong>：Kafka 通过多副本机制保证消息的可靠性，包括生产者端、Broker 和消费者端，确保消息不丢失并提供高度的数据一致性。</li>
<li><strong>高可用性</strong>：Kafka 通过分区多副本机制提升容灾能力，即使集群中的某个 Broker 失效，系统仍然能够保持高可用性。</li>
<li><strong>社区和生态</strong>：Kafka 拥有活跃的社区和丰富的生态系统，用户可以及时获取支持和反馈，同时有大量开源运维工具和其他大数据组件对 Kafka 提供支持和集成。</li>
</ul>
</blockquote>
<h2 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h2><p>消息队列通常用于两个业务场景：</p>
<ul>
<li><strong>应用解耦</strong>：在许多情况下，多个系统可能需要同一份数据。如果由发送方直接调用所有依赖系统，随着系统数量的增加，发送方代码需要频繁修改。而使用消息队列可以将发送方和接收方解耦。发送方将数据放入消息队列，依赖方根据实际需求按需进行订阅消费即可。</li>
<li><strong>流量削峰</strong>：传统的跨服务调用通常是实时的，即上游发起请求，下游需要立即处理并响应。然而，在某些特殊的业务场景中 —— 例如秒杀或抢购 ——  可能会出现流量激增的情况，此时下游服务可能无法承受如此大的请求量，导致大量请求失败。此时，消息队列就可以作为缓冲区来协调生产和消费速度。当下游的消费能力跟不上时，上游的消息可以暂存在消息队列中，避免直接导致下游服务崩溃。</li>
</ul>
<p>而作为一个老牌的消息队列，Kafka 的很多特性都可以很好的支持这两种场景：</p>
<ul>
<li><strong>消息堆积</strong>：Kafka 可以处理大量的消息堆积，适用于流量削峰场景。</li>
<li><strong>可靠性</strong>：Kafka 支持消息的持久化存储，并且还有着多副本机制来保证消息的可靠性，即使在节点故障的情况下也不会丢失消息。</li>
<li><strong>单分区消息顺序性</strong>：Kafka 保证在单个分区内消息的顺序性，适用于需要顺序处理的场景。</li>
<li><strong>单分区单会话的幂等</strong>：Kafka 支持生产者的幂等性，即在同一会话中，同一分区的消息即使重复发送也只会被处理一次，确保消息处理的准确性。</li>
<li><strong>消息回溯</strong>：Kafka 允许消费端根据需求回溯到任意时间点重新消费消息，适用于数据恢复和重新处理的场景。</li>
</ul>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>作为一款为大数据而生的消息队列，Kafka 在处理高吞吐量和大规模数据传输方面表现非凡，它的单机 TPS 在几十万级别，而集群环境可以轻易达到百万级别。</p>
<p>不过，与 RabbitMQ 或 RocketMQ 相比，Kafka 其实在某些功能方面是有所欠缺的，例如 Kafka  没有死信队列和延迟消息，因此在使用时一些功能无法做到开箱即用。然而 Kafka  的性能优势可以在一定程度上弥补这些不足，毕竟虽然我们总会希望有一款消息队列功能与性能兼顾，但是有时候二者确实不可兼得，这种情况下我们还是会以性能优先。</p>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>消息队列的可靠性通常指的是对消息不丢失的保障程度，这是消息队列最重要的指标之一。Kafka 则从生产者、Broker 和消费者三个方面一起保证了其可靠性。</p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>Kafka 在生产者端提供了可选的三种 ACK 策略，每种策略都对应着不同的可靠级别，我们可以根据自己的业务需要进行选择：</p>
<ul>
<li>0：生产者发送过来的数据，不需要等数据落盘应答。<strong>该方式可靠性差，效率高</strong>。</li>
<li>1（默认）：生产者发送过来的数据，Leader 副本收到数据后应答（不包含 ISR 集合中的其他副本）。<strong>该方式可靠性中等，效率中等</strong>。</li>
<li>-1：生产者发送过来的数据，Leader 和 ISR 集合里面的所有节点收齐数据后应答。<strong>该方式可靠性高，效率低</strong>。</li>
</ul>
<blockquote>
<ul>
<li>在生产环境中，0 方式基本不用； 1 方式一般用于传输普通日志，允许丢个别数据；-1 方式一般用于对可靠性要求比较高的场景。</li>
<li>关于 ISR 集合，你可以先简单的认为它是一个由 Leader 副本和有效 Follower 副本共同组成一个集合</li>
</ul>
</blockquote>
<h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>当消息到达 Broker 时，首先会存储到 Page Cache，然后通过操作系统的刷盘机制将数据持久化到硬盘上。此外，在集群环境中，Kafka 还会通过数据同步机制，将数据同步到分布在多个节点的副本中，并保证它们的一致性。这些措施都提高了消息的可靠性。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者端的可靠性通过消息的 Commit 机制来保证。与生产者端一样，Kafka 也提供了两种 Commit 策略供我们根据业务场景进行选择：</p>
<ul>
<li>手动 Commit：消费者在处理完消息后再提交，从而确保消息处理的可靠性。</li>
<li>自动 Commit 则可以简化操作，但可能在某些情况下导致消息的重复处理或丢失。</li>
</ul>
<blockquote>
<p>这里需要强调一下，对于 Broker 端来说，两者其实是没有区别的，这只是我们在代码里面引入的客户端提供的可选配置。</p>
</blockquote>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>可用性是指系统无故障运行的时间百分比，通常用几个 “9” 来衡量（如 99.9%、99.99%）。Kafka 通过引入分区多副本（Replica）机制提升容灾能力，从而实现高可用性。</p>
<p>简单来说，在集群环境下，Kafka 会为同一个分区内创建多个副本，并将这些副本分布在不同的 Broker 节点上。其中，这些副本又会分为处理所有的读写请求 Leader 副本和从 Leader 副本同步消息 Follower 副本，它们最终会在集群中形成一主多从的关系。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEapMJ1"><img src="https://s21.ax1x.com/2025/03/14/pEapMJ1.png" alt="pEapMJ1.png"></a></p>
<p>比如b1挂掉了，我们也能在b2，b3里面找到他的副本。这种机制结合副本的故障自动转移机制，最终使得 Kafka 具有极高的容错率，即使集群中的某个 Broker 失效，系统仍然能够保持高可用性。</p>
<h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p>消息：Kafka 中的数据单元被称为<code>消息</code>，也被称为记录，可以把它看作数据库表中某一行的记录。</p>
<p>批次：为了提高效率， 消息会<code>分批次</code>写入 Kafka，批次就代指的是一组消息。</p>
<p>主题：消息的种类称为 <code>主题</code>（Topic）,可以说一个主题代表了一类消息。相当于是对消息进行分类。主题就像是数据库中的表。</p>
<p>分区：主题可以被分为若干个分区（partition），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的<code>伸缩性</code>，单一主题中的分区有序，但是无法保证主题中所有的分区有序</p>
<p>生产者：向主题发布消息的客户端应用程序称为<code>生产者</code>（Producer），生产者用于持续不断的向某个主题发送消息。</p>
<p>消费者：订阅主题消息的客户端程序称为<code>消费者</code>（Consumer），消费者用于处理生产者产生的消息。</p>
<p>消费者群组：生产者与消费者的关系就如同餐厅中的厨师和顾客之间的关系一样，一个厨师对应多个顾客，也就是一个生产者对应多个消费者，<code>消费者群组</code>（Consumer Group）指的就是由一个或多个消费者组成的群体。</p>
<p>偏移量：<code>偏移量</code>（Consumer Offset）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生重平衡时的位置，以便用来恢复数据。</p>
<p>broker: 一个独立的 Kafka 服务器就被称为 <code>broker</code>，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</p>
<p>broker 集群：broker 是<code>集群</code> 的组成部分，broker 集群由一个或多个 broker 组成，每个集群都有一个 broker 同时充当了<code>集群控制器</code>的角色（自动从集群的活跃成员中选举出来）。</p>
<p>副本：Kafka 中消息的备份又叫做 <code>副本</code>（Replica），副本的数量是可以配置的，Kafka 定义了两类副本：领导者副本（Leader Replica） 和 追随者副本（Follower Replica），前者对外提供服务，后者只是被动跟随。</p>
<p>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。有点像重新选举的过程</p>
<p>像这么多概念我们基本都在之前的两篇文章进行解析过，假如看过RocketMQ或者Zookeeper这种消息队列的文章，其实很容易理解上面这些概念</p>
<h1 id="特性-设计原则"><a href="#特性-设计原则" class="headerlink" title="特性&amp;设计原则"></a>特性&amp;设计原则</h1><ul>
<li><code>高吞吐、低延迟</code>：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。</li>
<li><code>高伸缩性</code>：每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。</li>
<li><code>持久性、可靠性</code>：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。</li>
<li><code>容错性</code>：允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作</li>
<li><code>高并发</code>：支持数千个客户端同时读写</li>
</ul>
<p>像容错性，高并发，基本都是这种分布式的消息队列共同的特点</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li>活动跟踪：Kafka 可以用来跟踪用户行为，比如我们经常回去淘宝购物，你打开淘宝的那一刻，你的登陆信息，登陆次数都会作为消息传输到 Kafka ，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 Kafka ，这样就可以生成报告，可以做智能推荐，购买喜好等。</li>
<li>传递消息：Kafka 另外一个基本用途是传递消息，应用程序向用户发送通知就是通过传递消息来实现的，这些应用组件可以生成消息，而不需要关心消息的格式，也不需要关心消息是如何发送的。</li>
<li>度量指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
<li>日志记录：Kafka 的基本概念来源于提交日志，比如我们可以把数据库的更新发送到 Kafka 上，用来记录数据库的更新时间，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>
<li>流式处理：流式处理是有一个能够提供多种应用程序的领域。</li>
<li>限流削峰：Kafka 多用于互联网领域某一时刻请求特别多的情况下，可以把请求写入Kafka 中，避免直接请求后端程序导致服务崩溃。</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>Kafka 的消息队列一般分为两种模式：点对点模式和发布订阅模式</p>
<p>Kafka 是支持消费者群组的，也就是说 Kafka 中会有一个或者多个消费者，如果一个生产者生产的消息由一个消费者进行消费的话，那么这种模式就是点对点模式</p>
<p>如果一个生产者或者多个生产者产生的消息能够被多个消费者同时消费的情况，这样的消息队列成为发布订阅模式的消息队列</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaS4qe"><img src="https://s21.ax1x.com/2025/03/14/pEaS4qe.png" alt="pEaS4qe.png"></a></p>
<p>如上图所示，一个典型的 Kafka 集群中包含若干Producer（可以是web前端产生的Page  View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer  Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息</p>
<h1 id="为什么这么快"><a href="#为什么这么快" class="headerlink" title="为什么这么快"></a>为什么这么快</h1><p>Kafka 之所以受到众多人的青睐，其中一个重要原因无疑是 Kafka 非常“快”。一般来说，决定一个消息队列性能“快”还是“慢”最关键的两点在于<strong>磁盘 IO 和网络传输</strong>，那么 Kafka 是怎么解决这两个问题的呢？</p>
<blockquote>
<p>Kafka 实现了<code>零拷贝</code>原理来快速移动数据，避免了内核之间的切换。Kafka 可以将数据记录分批发送，从生产者到文件系统再到消费者，我们都可以实现端到端的查看这些批次的数据</p>
<p>批处理能够进行更有效的数据压缩并减少 I&#x2F;O 延迟，Kafka 采取顺序写入磁盘的方式，避免了随机磁盘寻址的浪费</p>
<p>总结一下其实就是四个要点</p>
<ul>
<li>顺序读写</li>
<li>零拷贝</li>
<li>消息压缩</li>
<li>分批发送</li>
</ul>
</blockquote>
<h2 id="磁盘部分"><a href="#磁盘部分" class="headerlink" title="磁盘部分"></a>磁盘部分</h2><p>众所周知，磁盘在计算机领域的操作性能是很慢的。因为正常的机械硬盘写入是需要通过<strong>寻址、旋转和数据传输</strong>三个步骤，固态硬盘需要寻址和数据传输两个步骤。</p>
<p>为此，Kafka 利用<strong>顺序写和零拷贝</strong>两大技术提升读写速度。</p>
<h3 id="顺序写"><a href="#顺序写" class="headerlink" title="顺序写"></a>顺序写</h3><p>在 Java 中，我们经常说顺序写比随机写快，是因为<strong>顺序写可以减少寻址和旋转</strong>，基本上只剩下数据传输，所以顺序写可以大幅度提升写入的性能。</p>
<p>那么在 Kafka 中，什么场景下使用顺序写呢？</p>
<p>在 Kafka 中，我们知道单个 Partition(分区) 是有序的、不可变的序列，<strong>新的消息会不断追加到 Partition 的末尾</strong>。但实际上 Partition 是一个逻辑概念，新的消息是写入到 Segment 中，一个 Partition 拥有多个 Segment，每个  Segment 由一个存储消息的消息日志 Log 文件和两个索引文件组成，Kafka 对 Segment 相关文件的写入，这就是顺序写文件。</p>
<p>当满足日志文件或索引文件超过一定大小，或当前时间-文件创建时间大于规定的时间间隔时（这些条件都是参数设置的），就会切分日志文件和索引文件，产生一个新的 Segment，新的 Segment 用当前最新的 Offset 作为名称。第一个 Segment 存储的第一条消息的起始序号为  0，因此文件名为 20 位长度的 0 来命名。</p>
<p>下图中，Partition0 的 Segment0 存储的第一条消息的 Offset 为 0，最后一条消息的 Offset 为 1234567890，第二个 Segment 的初始消息的 Offset 为 1234567890。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEapdJI"><img src="https://s21.ax1x.com/2025/03/14/pEapdJI.png" alt="pEapdJI.png"></a></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>如果应用程序不对数据做修改，从内核缓冲区到用户缓冲区，再从用户缓冲区到内核缓冲区。两次数据拷贝都需要CPU的参与，并且涉及用户态与内核态的多次切换，加重了CPU负担。</p>
<p>我们需要降低冗余数据拷贝、解放CPU，这也就是零拷贝Zero-Copy技术。零拷贝并不是不需要拷贝，而是减少不必要的拷贝次数。通常是说在IO读写过程中。减少了上下文切换与cpu拷贝的次数</p>
<p>Kafka的两个过程</p>
<ol>
<li>Producer生产数据到broker -&gt;数据持久化到磁盘 -&gt; 使用了mmp(基于虚拟内存实现)</li>
<li>Consumer从broker获取数据 -&gt;磁盘文件发送到网卡 -&gt; 使用了sendfile(整个读文件 - 网络发送由一个 sendfile 调用完成)</li>
</ol>
<p>下图左边是传统方式的一个消费流程，下图右边是零拷贝的一个消费方式。我们可以发现在零拷贝技术的情况下，正常的一次消费，可以比传统方式减少两次 CPU 拷贝，<strong>在高并发的情况下，就可以减少大量的 CPU 拷</strong>贝，进而降低 CPU 使用率提高性能。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEapcwQ"><img src="https://s21.ax1x.com/2025/03/14/pEapcwQ.png" alt="pEapcwQ.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78335525">相关文章-Kafka零拷贝</a></p>
<h3 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h3><p>页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘 I&#x2F;O 的操作。说白了就是，<strong>把磁盘中的数据缓存在内存中，把磁盘的访问变成对内存的访问</strong>。</p>
<p>在 Kafka 中，当 Producer 发送消息到 Broker 时，Broker 会按 Offset 写入数据，此时数据都会先写入 Page  Cache。Consumer 消费消息时，Broker 使用零拷贝将数据从 Page Cache 传输到 Broker 的 Socket  Buffer，再通过网络传输。</p>
<blockquote>
<p>Leader 与 Follower 之间的同步，和 Consumer 消费数据的过程是同理的。</p>
</blockquote>
<p>Page Cache 中的数据会随着操作系统的刷盘任务写回到磁盘。</p>
<blockquote>
<p>Kafka 支持同步刷盘和间断性强制刷盘，同步刷盘可提提高消息的可靠性。</p>
</blockquote>
<p>另外，如果 Consumer 要消费的消息不在 Page Cache 里，才会去磁盘读取，并且会顺便预读出一些相邻的块放入 Page cache，以方便下一次读取。</p>
<p>如果 Producer 的生产速率与 Consumer 的消费速率相差不大，那么就能几乎只靠对 Broker 的 Page Cache 的读写完成整个生产和消费过程，磁盘访问非常少。</p>
<h2 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h2><p>Kafka 在网络方面也做了很多优化，例如：<strong>支持 Reactor 模式的网络模型、客户端支持批量处理和压缩处理等</strong>。</p>
<p>在 Kafka 的 Producer 向 Broker 发送消息时，<strong>并不是一条消息一条消息的发送，而是批量发送</strong>。</p>
<p>Producer 会将消息放到 RecordAccumulator（消息累加器）中， RecordAccumulator  中针对每个分区都有对应的一个双端队列，队列中放的是 ProducerBatch ，每当有消息来的时候，追加到队列尾部， Sender 线程<strong>从队列头部读取消息，并发送到对应的 Broker 中</strong>。</p>
<p>Kafka 在很多地方都可以利用压缩算法对数据进行压缩，进而减少磁盘和网络消耗。</p>
<p>例如在 Producer 向 Broker  写入数据时，Consumer 向 Broker 读取数据时。在 Producer、Broker、Consumer  使用同一种压缩算法的场景下，Kafka 甚至可以不用解压缩，最终在 Consumer 拉取到消息时才解压，这样节省了大量的  CPU、网络和磁盘开销。</p>
<p>Kafka 支持多种压缩算法：<code>gzip</code>、<code>snappy</code>、<code>lz4</code>、<code>ZStandard</code>。</p>
<h2 id="分区并发"><a href="#分区并发" class="headerlink" title="分区并发"></a>分区并发</h2><p>在 Kafka 中，一个 Topic 可以分成多个 Partition（分区），每个 Paritition 类似于一个队列，保证数据有序。在同一个消费者分组下的不同 Consumer 并发消费 Paritition，<strong>一个 Paritition 最多只能有一个消费者</strong>（不然没法保证单 Paritition 有序），所以 Paritition 是调优 Kafka 消费性能的最小单元，每增加一个 Paritition 就增加了一个消费并发。</p>
<p>由于不同消费者组中的消费者可以并发消费 Paritition** <strong>中的消息，因此我们</strong>可通过提高并发度来提高消费效率**。</p>
<p>那是不是 Paritition 越多越好？并不是，<strong>Paritition 越多需要的资源越多</strong>，当 Broker 出现问题的时候，恢复的时间越久。</p>
<p>例如，假设某个 Partition 的最大传输速度为 1，且整个 Kafka 集群共有 3 个 Broker，每个 Broker 最多支持 3 个 Partition 的最大传输速度，因此整个集群的最大传输速度为 3 * 3 &#x3D; 9。如果在不增加资源的情况下，将 Partition 的数量增加到 18 个，那么每个 Broker 将负责 6 个  Partition，每个 Partition 无法达到最大传输速度，只能以 1&#x2F;2 的传输速度进行传输，因此无法再提升整个集群的传输速度。因此，<strong>在增加 Partition 数量时，需要考虑到每个 Broker 的资源上限，以避免达不到最大传输速度</strong>。</p>
<blockquote>
<p>随着在每个 Broker 上使用的 Partition 数量增加，需要打开的文件句柄数也会增加（受操作系统限制），同时磁盘的读取速度存在上限，甚至可能因 Partition 增多而导致原本的顺序读写转变为随机读写。</p>
</blockquote>
<h1 id="怎么发送一条消息"><a href="#怎么发送一条消息" class="headerlink" title="怎么发送一条消息"></a>怎么发送一条消息</h1><p>Kafka 消息发送涉及两个关键流程：第一个是消息在生产者客户端的发送流程，第二个则是消息到达 Broker 后，Broker 将对消息的处理流程。</p>
<h2 id="发送流程-Producer"><a href="#发送流程-Producer" class="headerlink" title="发送流程-Producer"></a>发送流程-Producer</h2><p>当我们使用 Kafka 客户端发送消息时，表面上我们只是调用了一个方法，但是背后是一条复杂的消息推送流程。这个流程由包括生产者  KafkaProducer、生产者拦截器 ProducerInterceptor、序列化 Serializer、分区器  Partitioner、消息累加器 RecordAccumulator 和消息发送线程 Sender 在内的多个核心组件共同完成。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaSIVH"><img src="https://s21.ax1x.com/2025/03/14/pEaSIVH.png" alt="pEaSIVH.png"></a></p>
<h2 id="处理流程-Broker"><a href="#处理流程-Broker" class="headerlink" title="处理流程-Broker"></a>处理流程-Broker</h2><p>消息到达 Broker 后，其处理流程会根据生产者中 <code>acks</code> 的配置而异。生产者的 <code>acks</code> 配置有三种策略，具体如下：</p>
<ul>
<li><strong>acks&#x3D;0</strong>：无需等待生产者发送数据在 Broker 落盘即返回响应，<strong>该方案可靠性较差，但效率高</strong>。</li>
<li><strong>acks&#x3D;1</strong>：需要等待 Leader 副本收到数据后返回响应，<strong>该方案可靠性一般，效率一般</strong>。</li>
<li><strong>acks&#x3D;-1 或 all</strong>：需要等待 Leader 和 ISR（In-Sync-Replica）集合中的所有节点对齐数据后返回响应，<strong>该方案可靠性高，但效率低</strong>。</li>
</ul>
<p>在默认情况下，Kafka 的 <code>acks</code> 参数为 1，也就是默认使用第二种策略，在可靠性和效率方面较为均衡。前两种策略比较好理解，因此暂时略过，我们重点介绍一下第三种策略的实现流程：</p>
<ol>
<li><strong>Producer 客户端发送消息至 Leader 副本</strong>：生产者将消息发送到指定主题的 Leader 副本；</li>
<li><strong>消息被追加到 Leader 副本的本地日志，并更新日志的偏移量 Offset 值</strong>：Leader 副本将消息追加到本地日志中，同时更新 Leader 副本的偏移量 Offset；</li>
<li><strong>Leader 副本应答给生产者</strong>：Leader 副本将应答（ACK）发送给生产者，表示消息已成功追加到本地日志；</li>
<li><strong>Leader 副本等待 ISR 中所有副本的应答</strong>：Leader 副本等待 ISR 中的所有副本，包括 Leader 本身，都应答成功；</li>
<li><strong>Follower 副本同步消息数据</strong>：Leader 副本将消息发送给 ISR 中的所有 Follower 副本，并等待它们同步消息数据；</li>
<li><strong>ISR 中所有副本应答给 Leader</strong>：ISR 中的所有副本都成功同步消息数据后，它们向 Leader 副本发送应答；</li>
<li><strong>Leader 副本应答给生产者</strong>：Leader 副本收到 ISR 中所有副本的应答后，再次向生产者发送应答，表示消息在 ISR 中的所有副本都已同步完成；</li>
<li><strong>生产者继续发送下一条消息</strong>：生产者收到 Leader 副本的最终应答后，可以继续发送下一条消息。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaSqRP"><img src="https://s21.ax1x.com/2025/03/14/pEaSqRP.png" alt="pEaSqRP.png"></a></p>
<h1 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="headerlink" title="如何保证数据不丢失"></a>如何保证数据不丢失</h1><p>Kafka 为分区引入了多副本（Replica）机制，<strong>通过增加副本数量提升容灾能力</strong>，从而做到高可用。简单的来说，在同一分区中，相同的数据会同时被分步在不同 Broker 中的多份副本保存。</p>
<p>在此基础上，副本又分为 Leader 副本和 Follower 副本，它们会构成一主多从关系。其中，Leader 副本负责读写，而 Follower 副本只负责从  Leader 副本同步消息。当 Leader 副本出现故障时，Kafka 会从 Follower 副本中重新选举新的 Leader  副本对外提供服务。Kafak 通过多副本机制实现了故障转移，当 Kafka 集群中的某个 Broker 失效时仍然能保证服务可用。</p>
<p>不过由于副本之间同步有延迟，因此在同一时刻副本间的数据是不能保证完全一致的，为此，Producter 端提供了可选的 ACK 策略，我们可以自己决定是否要等待所有副本都同步完数据才认定消息发送成功。此外，并且为了避免 Consumer  端消费到没有同步到所有副本的消息，Kafka 还引入了 HW（高水位）以及 Leader Epoch 等机制。</p>
<h2 id="多副本机制"><a href="#多副本机制" class="headerlink" title="多副本机制"></a>多副本机制</h2><p>与我们熟悉的 MySQL 或者 Redis 等中间件一样，Kafka 同样采用了增加副本的方式来保证高可用。</p>
<p>首先，我们知道  kafka 中每个 Topic 都分为多个 Partition，在默认的集群环境下，同一个 Topic 下的 Partition 会分布到不同的 Broker 上，在这种情况下，如果某个 Broker 挂了，那么它拥有的 Partition 中的所有数据都会丢失。</p>
<p>为了避免这个问题，从 0.8 版本开始，Kafka 引入了多副本（Replication）机制，简单的来说，就是<strong>让集群中的多个 Broker 节点同时持有 Partition 的副本</strong>。与 Redis 的主从类似，<strong>Partition 副本也分为负责读写的 Leader 副本，与只负责同步数据的 Follower 副本</strong>，如此一来，即使某一个 Broker 挂了，也只会导致其中的一个副本丢失数据，而其他的副本依然可以正常运行。</p>
<h2 id="ISR集合与OSR集合"><a href="#ISR集合与OSR集合" class="headerlink" title="ISR集合与OSR集合"></a>ISR集合与OSR集合</h2><p>在 Kafka 中，<strong>同一个 Partition 分布在不同 Broker 的所有副本构成的集合被称为 AR</strong>（Assigned Replicas）。</p>
<p>其中，<strong>在指定时间范围内与 Leader 副本进行过数据同步的副本锁构成的集合又称为 ISR</strong>（In-Syn-Replicas）。这个“时间范围”即为配置文件中的 <code>replica.lag.time.max.ms</code> 配置，默认为 10 秒。</p>
<p>简单的来说，如果一个 Follower 副本 10 秒内没有试图从 Leader 副本同步过数据（只要发起了请求就行，不一定真要同步到数据），那么就会被踢出  ISR，换而言之，ISR 中的所有副本，都是最近 10 秒从 Leader 副本同步过数据的，它们都是可信赖的同志。</p>
<p>与 ISR 对应的，<strong>所有被踢出 ISR 的副本构成的结合被称为 OSR</strong>（Out-of-Sync-Replica）</p>
<p>也就是说，<strong>OSR 中的副本的同步进度实际上都是落后 Leader 比较多的</strong>，因此不管是选举还是消费，我们都需要优先选择 ISR 中的副本。</p>
<blockquote>
<p>注意，在 0.9 版本之前，ISR 的判定标准是落后的消息条数，即 <code>replica.lag.max.message</code> 参数，在生产中这个条数实际上很难定一个合理的值 —— 尤其是在 Kafka 本身通常被用在大数据场景。这个值过小会导致副本被频繁踢出 ISR，而过大又会导致形同虚设。因此从 0.9 开始这个判断条件被换为了时间，也就是 <code>replica.lag.time.max.ms</code>。</p>
</blockquote>
<h1 id="如何做到消息的有序性"><a href="#如何做到消息的有序性" class="headerlink" title="如何做到消息的有序性"></a>如何做到消息的有序性</h1><p>Kafka 只保证 Topic 的分区内消息有序，不保证整个 Topic 中的消息有序，除非只有一个分区。</p>
<blockquote>
<ol>
<li><strong>Topic</strong>：这是Kafka中消息的类别或名称。生产者将消息发布到特定的主题，消费者则订阅一个或多个主题以接收消息。</li>
<li><strong>Partition</strong>：每个topic可以分为多个partitions。分区是Kafka实现高吞吐量和水平扩展性的核心机制。每条发送到Kafka集群的消息都属于某一个topic，并且会分配给该topic下的一个partition。正如你所提到的，Kafka仅保证在一个分区内消息的顺序性，而不是整个topic级别的顺序性。</li>
<li><strong>Broker</strong>：Kafka集群由一个或多个服务器组成，这些服务器被称为broker。每个broker可以容纳多个topic的多个partition。这意味着一个broker上可以存放来自不同topic的多个分区，同时一个topic的各个分区也可能分布在不同的broker上。</li>
</ol>
</blockquote>
<p>Kafka 的一个 Topic 是由多个 Partition 组成，一个 Topic 下的不同 Partition  包含的消息是不同的，Partition 中的每个消息都会有个特定的偏移量 offset，Kafka 利用 offset 来保证分区内的顺序性。</p>
<p>下图中有三个 Partition ，每个 Partition 的 offset 都是从 0 开始，生产者每次投递消息时，offset 按照顺序追加。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaCIZF"><img src="https://s21.ax1x.com/2025/03/14/pEaCIZF.png" alt="pEaCIZF.png"></a></p>
<p>正常情况下，Kafka 一个分区同一个消费组只能有一个消费者。</p>
<p>消费者在消费 Kafka 消息时，需要维护一个当前消费的 offset 值，以及一个已提交的 offset 值。</p>
<p>当前消费的 offset 值表示消费者正在消费的消息的位置，已提交的 offset 值表示消费者已经确认消费过的消息的位置。消费者在消费完一条消息后，需要提交 offset 来更新已提交的 offset 值。</p>
<p>提交 offset 的目的是为了记录消费进度，以便在消费者发生故障或重启时，默认情况下能够从上次消费的位置继续消费，也可选从最开始的位置开始消费。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaCTIJ"><img src="https://s21.ax1x.com/2025/03/14/pEaCTIJ.png" alt="pEaCTIJ.png"></a></p>
<p>因为 Kafka 一个分区同一个消费组只能有一个消费者，所以消费者正常消费即可做到顺序性。</p>
<p>为什么单个分区不能并行消费呢</p>
<p>正常情况，一个分区只接受同消费组的一个消费者，当消费者数量大于分区数量时，会导致消费者闲置。</p>
<p>我们举个例子，假设 Consumer0、Consumer1、Consumer2 共同消费 Partition0，当 Consumer0 提交  offset 为 12，Consumer2 提交 offset 为 8，Consumer3 从 Partition0 中获取的 offset 是 8，这就会导致出现重复消费。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Allimac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/15/A-First-Look-At-Kafka/">http://example.com/2025/03/15/A-First-Look-At-Kafka/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">AllimacBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a><a class="post-meta__tags" href="/tags/Kafka/">Kafka</a></div><div class="post-share"><div class="social-share" data-image="https://s21.ax1x.com/2025/03/15/pEaUHDP.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/12/NetWork-5/" title="NetWork-5"><img class="cover" src="https://s21.ax1x.com/2025/03/12/pEU3ljS.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NetWork-5</div></div><div class="info-2"><div class="info-item-1">创建套接字的过程</div></div></div></a><a class="pagination-related" href="/2025/03/15/A-First-Look-At-RocketMQ/" title="A-First-Look-At-RocketMQ"><img class="cover" src="https://s21.ax1x.com/2025/03/15/pEaULE8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">A-First-Look-At-RocketMQ</div></div><div class="info-2"><div class="info-item-1">初探RocketMQ，一些关于RocketMQ的问题</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/15/A-First-Look-At-Zookeeper/" title="A-First-Look-At-Zookeeper"><img class="cover" src="https://s21.ax1x.com/2025/03/15/pEaaHz9.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">A-First-Look-At-Zookeeper</div></div><div class="info-2"><div class="info-item-1">初探Zookeeper，一些关于Zookeeper的问题</div></div></div></a><a class="pagination-related" href="/2025/03/15/A-First-Look-At-RocketMQ/" title="A-First-Look-At-RocketMQ"><img class="cover" src="https://s21.ax1x.com/2025/03/15/pEaULE8.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">A-First-Look-At-RocketMQ</div></div><div class="info-2"><div class="info-item-1">初探RocketMQ，一些关于RocketMQ的问题</div></div></div></a><a class="pagination-related" href="/2025/03/15/Push-Pull-ModeInMQ/" title="Push-Pull-ModeInMQ"><img class="cover" src="https://s21.ax1x.com/2025/03/15/pEaaqMR.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">Push-Pull-ModeInMQ</div></div><div class="info-2"><div class="info-item-1">消息队列当中的推拉模式</div></div></div></a><a class="pagination-related" href="/2025/04/22/12306Impl-4/" title="12306Impl-4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-22</div><div class="info-item-2">12306Impl-4</div></div><div class="info-2"><div class="info-item-1">防止库存超卖；布隆过滤器快速返回；抗节假日高并发；中间站点余票如何更新；Binlog更新延迟问题怎么解决；如何保证消息顿列顺序性</div></div></div></a><a class="pagination-related" href="/2025/03/22/BloomFilter/" title="BloomFilter"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-22</div><div class="info-item-2">BloomFilter</div></div><div class="info-2"><div class="info-item-1">布隆过滤器入门</div></div></div></a><a class="pagination-related" href="/2025/03/22/Redis-High-Availability-architecture/" title="Redis-High-Availability-architecture"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-22</div><div class="info-item-2">Redis-High-Availability-architecture</div></div><div class="info-2"><div class="info-item-1">高可用架构实现</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Allimac</div><div class="author-info-description">华丽的仓库存放着我简陋的思想</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AillemaCc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AillemaCc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="http://www.swindle.icu/#/Home" target="_blank" title="曾经的博客"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是小梦一场的大床</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFkafka"><span class="toc-number">1.</span> <span class="toc-text">什么是kafka</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFKafka"><span class="toc-number">2.</span> <span class="toc-text">为什么是Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%B8%B0%E5%AF%8C"><span class="toc-number">2.1.</span> <span class="toc-text">功能丰富</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">高性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">2.3.1.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#broker"><span class="toc-number">2.3.2.</span> <span class="toc-text">broker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.3.3.</span> <span class="toc-text">消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">高可用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.</span> <span class="toc-text">基本术语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">特性&amp;设计原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">系统架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">8.</span> <span class="toc-text">为什么这么快</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%83%A8%E5%88%86"><span class="toc-number">8.1.</span> <span class="toc-text">磁盘部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%86%99"><span class="toc-number">8.1.1.</span> <span class="toc-text">顺序写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.1.2.</span> <span class="toc-text">零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%AD%98"><span class="toc-number">8.1.3.</span> <span class="toc-text">页缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86"><span class="toc-number">8.2.</span> <span class="toc-text">网络部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%B9%B6%E5%8F%91"><span class="toc-number">8.3.</span> <span class="toc-text">分区并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%8F%91%E9%80%81%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF"><span class="toc-number">9.</span> <span class="toc-text">怎么发送一条消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B-Producer"><span class="toc-number">9.1.</span> <span class="toc-text">发送流程-Producer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-Broker"><span class="toc-number">9.2.</span> <span class="toc-text">处理流程-Broker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">10.</span> <span class="toc-text">如何保证数据不丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">10.1.</span> <span class="toc-text">多副本机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ISR%E9%9B%86%E5%90%88%E4%B8%8EOSR%E9%9B%86%E5%90%88"><span class="toc-number">10.2.</span> <span class="toc-text">ISR集合与OSR集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E6%B6%88%E6%81%AF%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">如何做到消息的有序性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-2/" title="12306Business-2">12306Business-2</a><time datetime="2025-04-22T10:14:27.000Z" title="发表于 2025-04-22 18:14:27">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-1/" title="12306Business-1">12306Business-1</a><time datetime="2025-04-22T10:10:07.000Z" title="发表于 2025-04-22 18:10:07">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Impl-4/" title="12306Impl-4">12306Impl-4</a><time datetime="2025-04-22T10:06:14.000Z" title="发表于 2025-04-22 18:06:14">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Impl-3/" title="12306Impl-3">12306Impl-3</a><time datetime="2025-04-22T10:03:30.000Z" title="发表于 2025-04-22 18:03:30">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Impl-2/" title="12306Impl-2">12306Impl-2</a><time datetime="2025-04-22T10:00:54.000Z" title="发表于 2025-04-22 18:00:54">2025-04-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Allimac</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>