<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Analysis-of-the-Source-Code-of-the-Request-Annotation | AllimacBlog</title><meta name="author" content="Allimac"><meta name="copyright" content="Allimac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Request注解源代码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="Analysis-of-the-Source-Code-of-the-Request-Annotation">
<meta property="og:url" content="http://example.com/2025/03/12/Analysis-of-the-Source-Code-of-the-Request-Annotation/index.html">
<meta property="og:site_name" content="AllimacBlog">
<meta property="og:description" content="Request注解源代码解析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2025/03/12/pEU3V7d.jpg">
<meta property="article:published_time" content="2025-03-12T10:15:41.000Z">
<meta property="article:modified_time" content="2025-03-12T10:18:47.438Z">
<meta property="article:author" content="Allimac">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="SpringMVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2025/03/12/pEU3V7d.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Analysis-of-the-Source-Code-of-the-Request-Annotation",
  "url": "http://example.com/2025/03/12/Analysis-of-the-Source-Code-of-the-Request-Annotation/",
  "image": "https://s21.ax1x.com/2025/03/12/pEU3V7d.jpg",
  "datePublished": "2025-03-12T10:15:41.000Z",
  "dateModified": "2025-03-12T10:18:47.438Z",
  "author": [
    {
      "@type": "Person",
      "name": "Allimac",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/faviconcute.png"><link rel="canonical" href="http://example.com/2025/03/12/Analysis-of-the-Source-Code-of-the-Request-Annotation/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Analysis-of-the-Source-Code-of-the-Request-Annotation',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s21.ax1x.com/2025/03/12/pEU3V7d.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">AllimacBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">Analysis-of-the-Source-Code-of-the-Request-Annotation</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Analysis-of-the-Source-Code-of-the-Request-Annotation</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-12T10:15:41.000Z" title="发表于 2025-03-12 18:15:41">2025-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-12T10:18:47.438Z" title="更新于 2025-03-12 18:18:47">2025-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>今天在敲代码的时候，遇到了这样一个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ailed to convert property value of type &#x27;java.lang.String&#x27; to required type &#x27;java.util.List&#x27; for property &#x27;orders&#x27;; Cannot convert value of type &#x27;java.lang.String&#x27; to required type &#x27;com.baomidou.mybatisplus.core.metadata.OrderItem&#x27; for property &#x27;orders[0]&#x27;: no matching editors or conversion strategy found</span><br></pre></td></tr></table></figure>

<p>翻译一下大概的意思是</p>
<blockquote>
<p>未能将“java.lang.String”类型的属性值转换为所需的“java.util.util”类型。财产订单列表；无法将“java.lang.String”类型的值转换为所需的“com.baomidou.mybatisplus.core.metadata”类型。属性“orders[0]”的OrderItem“：找不到匹配的编辑器或转换策略</p>
</blockquote>
<p>机翻，但是大概的意思就是形式转换错误了</p>
<p>这个问题困扰了我很久，最后的解决方案是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问单个短链接指定时间内访问记录监控数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/api/shortlink/admin/v1/stats/access-record&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;IPage&lt;ShortLinkStatsAccessRecordRespDTO&gt;&gt; <span class="title function_">shortLinkStatsAccessRecord</span><span class="params">(<span class="meta">@RequestBody</span> ShortLinkStatsAccessRecordReqDTO requestParam)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> shortLinkRemoteService.shortLinkStatsAccessRecord(requestParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在请求参数前面加了一个@RequestBody就解决了。其实这个注解我经常用，但是用这样一个注解就能解决属性值转换的问题，我从没想过。所以今天写完项目之后，我觉得可以稍微探索一下这个注解背后的逻辑了。这也算作一种源码探究了</p>
<p>从这个注解的作用来说，他是用来将http请求解析为对应的对象，假如我们请求的是json的格式，那通过@RequestBody可以解析为ProductSyncNegativeDto对象。这是网上的一篇文档说的，我还没在源码当中找到这一点。但事实上我们的这个注解，最后会把前端的请求转化为一个json字符串</p>
<h1 id="Controller注解"><a href="#Controller注解" class="headerlink" title="Controller注解"></a>Controller注解</h1><p>想讲@RequestBody注解，要先从Controller注解开始。在SpringMVC框架当中，DispatcherServlet通过SPI机制来加载默认提供的相关组件，而SPI的核心就在于DispathcerServlet.properties文件:</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pENRym4"><img src="https://s21.ax1x.com/2025/03/11/pENRym4.png" alt="pENRym4.png"></a></p>
<p> 该文件内部列举了各个组件会提供哪些默认实现，使用这些默认实现的前提是，DispathcerServlet在初始化各个组件时，并没有在当前容器内发现各个组件已有的实现。</p>
<p>对于注解版本Controller寻找是通过RequestMappingHandlerMapping完成的RequestMappingHandlerMapping主要负责在自身初始化阶段搜寻出当前容器内所有可用Controller实现，然后建立相关映射关系； 在请求到来时，再通过这些映射关系寻找到对应处理方法后返回。</p>
<p>至于注解版本的controller如何处理请求，是通过RequestMappingHandlerAdapter完成的，RequestMappingHandlerAdapter负责拿到RequestMappingHandlerMapping返回的方法后，进行一系列处理后，调用目标方法处理请求，这一系列处理包括: 数据绑定和数据校验，返回值处理等等…</p>
<h2 id="映射建立"><a href="#映射建立" class="headerlink" title="映射建立"></a>映射建立</h2><p>Reuqest和HandlerMethod的映射的建立过程由AbstractHandlerMethodMapping实现的初始化回调接口afterPropertiesSet完成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">	initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initHandlerMethods是映射建立的入口，我们需要深入其中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//getCandidateBeanNames可以简单的理解为是获取当前容器内部的所有bean实例</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">	        ...</span><br><span class="line">	        <span class="comment">//需要判断当前bean是不是我们需要的候选bean,如果是就进行处理</span></span><br><span class="line">			processCandidateBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//简单的日志记录</span></span><br><span class="line">	handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>processCandidateBean是核心方法，该方法内部完成了bean的筛选和对某个Controller内部所有handlerMethod的探测。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processCandidateBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">	Class&lt;?&gt; beanType = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//获取当前bean类型</span></span><br><span class="line">	beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">//默认AbstractHandlerMethodMapping是不提供对处理器的识别的,具体如何识别某个bean是不是handler,是由子类决定的</span></span><br><span class="line">    <span class="comment">//这里是AbstractHandlerMethodMapping实现的,筛选规则如下:</span></span><br><span class="line">    <span class="comment">//检验当前bean上是否存在Controller或者RequestMapping注解</span></span><br><span class="line">	<span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">	    <span class="comment">//如果当前bean是一个handler,那么需要探测出该handler内部所有handlerMethod实现</span></span><br><span class="line">		detectHandlerMethods(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handlerMethod才是处理请求的终点，因此我们需要探测当前handler内部有哪些handlerMethod，并且建立好相关映射关系:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="comment">//先获取到当前handler的type</span></span><br><span class="line">	Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">			obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line">                                   </span><br><span class="line">	<span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">	    <span class="comment">//如果当前handler是被cglib代理过的对象,那么需要获取当前代理对象的superClass</span></span><br><span class="line">	    <span class="comment">//因为这才是目标handler的类型</span></span><br><span class="line">		Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">		<span class="comment">//MethodIntrospector类主要提供对方法的筛选和通用处理封装</span></span><br><span class="line">		<span class="comment">//这里selectMethods就是筛选出当前handler内部所有符合要求的handlerMethod</span></span><br><span class="line">		Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">		        <span class="comment">//筛选出某个handlerMethod，利用注册的回调接口生成映射关系</span></span><br><span class="line">				(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">								userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		... </span><br><span class="line">		methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">		    <span class="comment">//对jdk动态代理的情况进行处理--一般情况下可以忽略,因此controller层一般都是采用cglib代理</span></span><br><span class="line">			<span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">			<span class="comment">//注册</span></span><br><span class="line">			registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodIntrospector.selectMethods作用可以简单看做是遍历handler类内部所有方法，包括其父类和实现接口里面的所有方法，然后交给注册进来的回调接口进行处理，回调接口的返回值作为生成的映射信息，如果返回值不为空，就和当前method组成一条记录，放入map中； 遍历完所有方法后，返回该map集合</p>
<p> <strong>selectMethods完成方法筛选的关键就在于目标方法经过回调接口处理过后，返回值是否为空，如果为空，说明当前方法需要被过滤掉</strong></p>
<p><strong>所以，上面注册的回调接口中的getMappingForMethod方法才是我们需要关注的重点，该方法完成了对当前method信息的提取，最终组装返回一个请求映射信息。</strong></p>
<p>和上面识别handler一样，具体是如何完成对method解析的过程，也是由RequestMappingHandlerMapping子类实现的。</p>
<h2 id="解析handlerMethod"><a href="#解析handlerMethod" class="headerlink" title="解析handlerMethod"></a>解析handlerMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RequestMappingInfo <span class="title function_">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> &#123;</span><br><span class="line">   <span class="comment">//根据当前方法,创建一个请求映射信息</span></span><br><span class="line">	<span class="type">RequestMappingInfo</span> <span class="variable">info</span> <span class="operator">=</span> createRequestMappingInfo(method);</span><br><span class="line">	<span class="comment">//如果当前方法并没有标注@RequestMapping等注解,那么也就不是一个handlerMethod，那么就返回null</span></span><br><span class="line">	<span class="comment">//该方法就会在selectMethods中被过滤掉</span></span><br><span class="line">	<span class="keyword">if</span> (info != <span class="literal">null</span>) &#123;</span><br><span class="line">	    <span class="comment">//当前handlerMethod属于的handler上是否也存在@RequestMapping注解,如果存在就解析</span></span><br><span class="line">		<span class="type">RequestMappingInfo</span> <span class="variable">typeInfo</span> <span class="operator">=</span> createRequestMappingInfo(handlerType);</span><br><span class="line">		<span class="keyword">if</span> (typeInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//如果handler上确实存在,那么就需要将方法上的@RequestMapping注解和类上的@RequestMapping注解注解进行合并</span></span><br><span class="line">			info = typeInfo.combine(info);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> getPathPrefix(handlerType);</span><br><span class="line">		<span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">			info = RequestMappingInfo.paths(prefix).options(<span class="built_in">this</span>.config).build().combine(info);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createRequestMappingInfo方法会对传入的AnnotatedElement上的RequestMapping注解进行解析，然后生成RequestMappingInfo返回。</p>
<blockquote>
<p> <strong>AnnotatedElement是JDK反射包提供的顶层接口，实现了该接口的元素，都是可以标注注解的元素，例如: Class，Method,Parameter等都实现了该接口</strong> </p>
</blockquote>
<p>继续向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestMappingInfo <span class="title function_">createRequestMappingInfo</span><span class="params">(AnnotatedElement element)</span> &#123;</span><br><span class="line"><span class="comment">//拿到当前元素上的注解信息</span></span><br><span class="line">	<span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);</span><br><span class="line">	<span class="comment">//用户可以实现相关方法来创建自定义的请求匹配条件</span></span><br><span class="line">	RequestCondition&lt;?&gt; condition = (element <span class="keyword">instanceof</span> Class ?</span><br><span class="line">			getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));</span><br><span class="line">	<span class="keyword">return</span> (requestMapping != <span class="literal">null</span> ?</span><br><span class="line">	  <span class="comment">//如果存在注解,就创建对应的RequestMappingInfo</span></span><br><span class="line">	  createRequestMappingInfo(requestMapping, condition) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RequestMappingInfo <span class="title function_">createRequestMappingInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">		RequestMapping requestMapping, <span class="meta">@Nullable</span> RequestCondition&lt;?&gt; customCondition)</span> &#123;</span><br><span class="line"></span><br><span class="line">	RequestMappingInfo.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestMappingInfo</span><br><span class="line">	        <span class="comment">//requestMapping注解中的path属性会经过EL解析器解析,也就是我们在路径中可以通过el表达式获取上下文中的值</span></span><br><span class="line">	        <span class="comment">//例如: $&#123;user.dir&#125;</span></span><br><span class="line">			.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))</span><br><span class="line">			<span class="comment">//通过请求访问限制匹配</span></span><br><span class="line">			.methods(requestMapping.method())</span><br><span class="line">			<span class="comment">//通过请求参数中必须携带某个请求参数进行限制匹配</span></span><br><span class="line">			.params(requestMapping.params())</span><br><span class="line">			<span class="comment">//通过请求头中必须携带某个请求头进行限制匹配</span></span><br><span class="line">			.headers(requestMapping.headers())</span><br><span class="line">			<span class="comment">//通过限制请求头中的content-type来进行限制匹配</span></span><br><span class="line">			.consumes(requestMapping.consumes())</span><br><span class="line">			<span class="comment">//规定响应的content-type类型</span></span><br><span class="line">			.produces(requestMapping.produces())</span><br><span class="line">			.mappingName(requestMapping.name());</span><br><span class="line">     <span class="comment">//是否存在用户自定义匹配限制	</span></span><br><span class="line">	<span class="keyword">if</span> (customCondition != <span class="literal">null</span>) &#123;</span><br><span class="line">		builder.customCondition(customCondition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构建RequestMappingInfo后返回</span></span><br><span class="line">	<span class="keyword">return</span> builder.options(<span class="built_in">this</span>.config).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前handleMethod对应的Handler上也存在@RequestMapping注解，那么就需要将类上的提供的@RequestMapping注解信息，与当前类内部所有handlerMethod提供的@RequestMapping注解信息进行合并，具体合并规则如下:</p>
<p>请求路径，就是拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HandlerMethod这里对应的就是login方法，而Handler对应的就是AdminController，此时合并完之后，得到的RequestMappingInfo 中的path路径为&#x2F;admin&#x2F;login。</p>
<p>而其他的属性就是简单的合并</p>
<h2 id="注册handlerMethod"><a href="#注册handlerMethod" class="headerlink" title="注册handlerMethod"></a>注册handlerMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="comment">//先获取到当前handler的type</span></span><br><span class="line">	Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">			obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line">                                   </span><br><span class="line">	<span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">	    <span class="comment">//如果当前handler是被cglib代理过的对象,那么需要获取当前代理对象的superClass</span></span><br><span class="line">	    <span class="comment">//因为这才是目标handler的类型</span></span><br><span class="line">		Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">		<span class="comment">//MethodIntrospector类主要提供对方法的筛选和通用处理封装</span></span><br><span class="line">		<span class="comment">//这里selectMethods就是筛选出当前handler内部所有符合要求的handlerMethod</span></span><br><span class="line">		Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">		        <span class="comment">//筛选出某个handlerMethod，利用注册的回调接口生成映射关系</span></span><br><span class="line">				(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">								userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		... </span><br><span class="line">		methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">		    <span class="comment">//对jdk动态代理的情况进行处理--一般情况下可以忽略,因此controller层一般都是采用cglib代理</span></span><br><span class="line">			<span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">			<span class="comment">//注册</span></span><br><span class="line">			registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodIntrospector.selectMethods通过getMappingForMethod回调接口筛选出相关方法，并且建立好Method和对应RequestMappingInfo 映射关系后，返回了一个map集合，下面就是需要将这些映射关系进行注册。</p>
<p>子类RequestMappingHandlerMapping重写了父类的registerHandlerMethod方法，主要提供了对ConsumesCondition扩展点的支持:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, RequestMappingInfo mapping)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>.registerHandlerMethod(handler, method, mapping);</span><br><span class="line">	updateConsumesCondition(mapping, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们先将目光着眼于父类AbstractHandlerMethodMapping提供的registerHandlerMethod实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MappingRegistry映射注册中心"><a href="#MappingRegistry映射注册中心" class="headerlink" title="MappingRegistry映射注册中心"></a>MappingRegistry映射注册中心</h4><p>MappingRegistry是AbstractHandlerMethodMapping内部维护的一个映射关系的注册中心，注册中心内部主要保存的都是映射关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line">       <span class="comment">//保存RequestMappingInfo和MappingRegistration的映射关系</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//保存请求路径和RequestMappingInfo的映射关系</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; pathLookup = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//保存handlerMethodName和handlerMethod的映射关系  </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//保存handlerMethod和跨域配置的映射关系</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//读写锁 </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<h3 id="具体注册过程"><a href="#具体注册过程" class="headerlink" title="具体注册过程"></a>具体注册过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//mapping就是handlerMethod对应的RequestMappingInfo</span></span><br><span class="line">  <span class="comment">//然后是handler和handlerMethod</span></span><br><span class="line">  <span class="comment">//ps:这里的handlerMethod指的是handler中的处理请求方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(T mapping, Object handler, Method method)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//对原生处理请求方法进行了一层封装,包装为了一个HandlerMethod </span></span><br><span class="line">			<span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> createHandlerMethod(handler, method);</span><br><span class="line">			<span class="comment">//进行映射校验,判断是否存在模糊映射,即一个请求URL可以同时被多个handlerMethod处理</span></span><br><span class="line">			validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">               <span class="comment">//从RequestMappingInfo中获取当前handlerMethod能够处理的请求URL集合</span></span><br><span class="line">			Set&lt;String&gt; directPaths = AbstractHandlerMethodMapping.<span class="built_in">this</span>.getDirectPaths(mapping);</span><br><span class="line">			<span class="comment">//将请求路径和RequestMappingInfo的映射关系添加到pathLookUp集合中保存</span></span><br><span class="line">			<span class="keyword">for</span> (String path : directPaths) &#123;</span><br><span class="line">				<span class="built_in">this</span>.pathLookup.add(path, mapping);</span><br><span class="line">			&#125;</span><br><span class="line">              </span><br><span class="line">                 <span class="comment">// 为HandlerMethod的映射分配名称</span></span><br><span class="line">              <span class="comment">// 默认采用：RequestMappingInfoHandlerMethodMappingNamingStrategy 策略来分配名称</span></span><br><span class="line">             <span class="comment">// 策略为：@RequestMapping指定了name属性，那就以指定的为准  否则策略为：取出Controller所有的`大写字母` + # + method.getName()</span></span><br><span class="line">            <span class="comment">// 如：AppoloController#match方法  最终的name为：AC#match </span></span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (getNamingStrategy() != <span class="literal">null</span>) &#123;</span><br><span class="line">				name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">				addMappingName(name, handlerMethod);</span><br><span class="line">			&#125;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//处理方法上的CrossOrigin跨域注解---这个后面讲到跨域问题的时候再说，本文不展开 </span></span><br><span class="line">			<span class="type">CorsConfiguration</span> <span class="variable">corsConfig</span> <span class="operator">=</span> initCorsConfiguration(handler, method, mapping);</span><br><span class="line">			<span class="keyword">if</span> (corsConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">				corsConfig.validateAllowCredentials();</span><br><span class="line">				<span class="built_in">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">//注册---这里是RequestMappingInfo和封装后的MappingRegistration的映射</span></span><br><span class="line">			<span class="built_in">this</span>.registry.put(mapping,</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">MappingRegistration</span>&lt;&gt;(mapping, handlerMethod, directPaths, name, corsConfig != <span class="literal">null</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">		    <span class="comment">//释放写锁</span></span><br><span class="line">			<span class="built_in">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p> createHandlerMethod</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">createHandlerMethod</span><span class="params">(Object handler, Method method)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>((String) handler,</span><br><span class="line">				obtainApplicationContext().getAutowireCapableBeanFactory(),</span><br><span class="line">				obtainApplicationContext(),</span><br><span class="line">				method);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> validateMethodMapping</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateMethodMapping</span><span class="params">(HandlerMethod handlerMethod, T mapping)</span> &#123;</span><br><span class="line">	MappingRegistration&lt;T&gt; registration = <span class="built_in">this</span>.registry.get(mapping);</span><br><span class="line">	<span class="type">HandlerMethod</span> <span class="variable">existingHandlerMethod</span> <span class="operator">=</span> (registration != <span class="literal">null</span> ? registration.getHandlerMethod() : <span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (existingHandlerMethod != <span class="literal">null</span> &amp;&amp; !existingHandlerMethod.equals(handlerMethod)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">				<span class="string">&quot;Ambiguous mapping. Cannot map &#x27;&quot;</span> + handlerMethod.getBean() + <span class="string">&quot;&#x27; method \n&quot;</span> +</span><br><span class="line">				handlerMethod + <span class="string">&quot;\nto &quot;</span> + mapping + <span class="string">&quot;: There is already &#x27;&quot;</span> +</span><br><span class="line">				existingHandlerMethod.getBean() + <span class="string">&quot;&#x27; bean method\n&quot;</span> + existingHandlerMethod + <span class="string">&quot; mapped.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，controller映射建立的部分就结束了，但是离题太远，让我们再回到RequestBody上</p>
<h1 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a><strong>RequestBody</strong></h1><blockquote>
<p><em><strong>*使用 HttpMessageConverter<T> 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，Spring 提供了两种途径*</strong></em></p>
<p>使用 <em><strong>*@RequestBody &#x2F; @ResponseBody*</strong></em> 对处理方法进行标注</p>
<p>使用 <em><strong>*HttpEntity<T> &#x2F; ResponseEntity<T>*</strong></em> 作为处理方法的入参或返回值</p>
</blockquote>
<h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>所有的http请求都会进入ServletInvocableHandlerMethod类（继承InvocableHandlerMethod，所有的参数解析器都会在在这里面进行初始化）的invokeAndHandle方法中，我们来具体看看invokeAndHandle方法是干什么的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 执行http请求</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">		setResponseStatus(webRequest);</span><br><span class="line">	<span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">			disableContentCachingIfNecessary(webRequest);</span><br><span class="line">			mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">		mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">	Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">	<span class="comment">// 返回值处理</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">					returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled())&#123;</span><br><span class="line">		logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到invokeAndHandle方法都会进入invokeForRequest方法中，invokeForRequest方法就是实现@RequestBody注解的功能，将http请求报文解析为我们设置的对象。我们进入该方法看看，里面具体做了哪些事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// http报文解析为对象数组</span></span><br><span class="line">	Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行@PostMapping、@GetMapping等接口</span></span><br><span class="line">	<span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到invokeForRequest中主要做了两件事情，一个是通过getMethodArgumentValues方法返回http解析后的对象数组，然后通过doInvoke方法执行接口的具体业务逻辑代码。<br>我们接着进入getMethodArgumentValues方法，细看一下@RequestBody的具体解析过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">			Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取http请求参数</span></span><br><span class="line">	MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">	<span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">	&#125;</span><br><span class="line">	Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">	<span class="comment">// 遍历所有参数，挨个解析</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">		<span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">		parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">		args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">		<span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">// 参数解析器解析HTTP报文</span></span><br><span class="line">			args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">					<span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">					logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory)方法最终实现@RequestBody 解析操作。我们来看看 this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory) 中做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取对应的解析器</span></span><br><span class="line">	<span class="type">HandlerMethodArgumentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> getArgumentResolver(parameter);</span><br><span class="line">	<span class="keyword">if</span> (resolver == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">					<span class="string">&quot;Unsupported parameter type [&quot;</span> + parameter.getParameterType().getName() + <span class="string">&quot;].&quot;</span> +</span><br><span class="line">							<span class="string">&quot; supportsParameter should be called first.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过HandlerMethodArgumentResolver 解析器解析http报文</span></span><br><span class="line">	<span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getArgumentResolver方法来获取对应的HandlerMethodArgumentResolver参数解析器，参数解析器最终通过RequestResponseBodyMethodProcessor类来具体执行解析过程，我们接着来看看RequestResponseBodyMethodProcessor中resolveArgument方法又是怎样的一个处理过程。</p>
<p>不同的resolvers（HandlerMethodArgumentResolver接口）会对应不同的参数解析器，例如public String testDemo(String name)，解析器就会变成ServletRequestMethodArgumentResolver，如果是@RequestBody，参数解析器就是RequestResponseBodyMethodProcessor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">	parameter = parameter.nestedIfOptional();</span><br><span class="line">	<span class="comment">// 通过HttpMessageConverter来解析http报文为Object对象</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">arg</span> <span class="operator">=</span> readWithMessageConverters(webRequest,parameter,parameter.getNestedGenericParameterType());</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (binderFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">WebDataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">		<span class="keyword">if</span> (arg != <span class="literal">null</span>) &#123;</span><br><span class="line">			validateIfApplicable(binder, parameter);</span><br><span class="line">			<span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MethodArgumentNotValidException</span>(parameter, binder.getBindingResult());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mavContainer != <span class="literal">null</span>) &#123;</span><br><span class="line">			mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>readWithMessageConverters</code>方法中，<code>HttpMessageConverter</code>（接口对应实现类）的<code>read</code>方法实现了http报文解析，我们来看看最终http参数解析部分的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; Object <span class="title function_">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span><br><span class="line"><span class="params">			Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		message = <span class="keyword">new</span> <span class="title class_">EmptyBodyCheckingHttpInputMessage</span>(inputMessage);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="built_in">this</span>.messageConverters) &#123;</span><br><span class="line">			Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line">			GenericHttpMessageConverter&lt;?&gt; genericConverter =</span><br><span class="line">						(converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="literal">null</span>);</span><br><span class="line">			<span class="comment">// 判断转换器是否支持参数类型</span></span><br><span class="line">			<span class="keyword">if</span> (genericConverter != <span class="literal">null</span> ? genericConverter.canRead(targetType, contextClass, contentType) :</span><br><span class="line">						(targetClass != <span class="literal">null</span> &amp;&amp; converter.canRead(targetClass, contentType))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (message.hasBody()) &#123;</span><br><span class="line">					<span class="type">HttpInputMessage</span> <span class="variable">msgToUse</span> <span class="operator">=</span></span><br><span class="line">								getAdvice().beforeBodyRead(message, parameter, targetType, converterType);</span><br><span class="line">					<span class="comment">// read方法执行HTTP报文到参数的转换</span></span><br><span class="line">					body = (genericConverter != <span class="literal">null</span> ? genericConverter.read(targetType, contextClass, msgToUse) :</span><br><span class="line">								((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));</span><br><span class="line">					body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					body = getAdvice().handleEmptyBody(<span class="literal">null</span>, message, parameter, targetType, converterType);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageNotReadableException</span>(<span class="string">&quot;I/O error while reading input message&quot;</span>, ex, inputMessage);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码部分省略了，关键部分即是遍历所有的HttpMessageConverter，然后通过canRead方法判断解析器是否支持，最后执行AbstractJackson2HttpMessageConverter对象（HttpMessageConverter实现类）的read方法完成最后的参数解析。<br>AbstractJackson2HttpMessageConverter对象的read方法，核心是利用了jackson工具，将http报文的json字符串转换为object对象并返回。</p>
<h2 id="返回值序列化过程"><a href="#返回值序列化过程" class="headerlink" title="返回值序列化过程"></a>返回值序列化过程</h2><p>执行完doInvoke逻辑代码之后，通过ServletInvocableHandlerMethod对象的invokeAndHandle方法，利用返回值处理器对返回值进行序列化输出。</p>
<p>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);<br>returnValueHandlers为HandlerMethodReturnValueHandlerComposite对象，该对象实现了HandlerMethodReturnValueHandler接口，我们接着来看看handleReturnValue方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">		ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 选择合适的HandlerMethodReturnValueHandler返回值处理器</span></span><br><span class="line">	<span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行返回值处理</span></span><br><span class="line">	handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>selectHandler方法会提供合适的HandlerMethodReturnValueHandler，用来处理返回值。</p>
<p>我们看到的HandlerMethodReturnValueHandler处理器最终也是由RequestResponseBodyMethodProcessor实现的，我们具体来看看handleReturnValue方法。</p>
<p>handler（HandlerMethodReturnValueHandler）接口会根据不同类型选择不同的返回值处理器，例如页面跳转类型的处理器就是ViewNameMethodReturnValueHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">		ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line">		mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">		<span class="type">ServletServerHttpRequest</span> <span class="variable">inputMessage</span> <span class="operator">=</span> createInputMessage(webRequest);</span><br><span class="line">		<span class="type">ServletServerHttpResponse</span> <span class="variable">outputMessage</span> <span class="operator">=</span> createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用HttpMessageConverter执行</span></span><br><span class="line">		writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">writeWithMessageConverters</span><span class="params">(<span class="meta">@Nullable</span> T value, MethodParameter returnType,</span></span><br><span class="line"><span class="params">			ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line">	<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="built_in">this</span>.messageConverters) &#123;</span><br><span class="line">		<span class="type">GenericHttpMessageConverter</span> <span class="variable">genericConverter</span> <span class="operator">=</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ?</span><br><span class="line">				(GenericHttpMessageConverter&lt;?&gt;) converter : <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 判断是否支持返回值类型，返回值类型很有可能不同，如String，Map，List等</span></span><br><span class="line">		<span class="keyword">if</span> (genericConverter != <span class="literal">null</span> ?</span><br><span class="line">				((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :</span><br><span class="line">				converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">			body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,</span><br><span class="line">					(Class&lt;? <span class="keyword">extends</span> <span class="title class_">HttpMessageConverter</span>&lt;?&gt;&gt;) converter.getClass(),</span><br><span class="line">					inputMessage, outputMessage);</span><br><span class="line">			<span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">theBody</span> <span class="operator">=</span> body;</span><br><span class="line">				LogFormatUtils.traceDebug(logger, traceOn -&gt;</span><br><span class="line">						<span class="string">&quot;Writing [&quot;</span> + LogFormatUtils.formatValue(theBody, !traceOn) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">				<span class="keyword">if</span> (genericConverter != <span class="literal">null</span>) &#123;</span><br><span class="line">				    <span class="comment">// 执行返回值转换</span></span><br><span class="line">					genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">				    <span class="comment">// 执行返回值转换</span></span><br><span class="line">					((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Nothing to write: null body&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看到最终还是由HttpMessageConverter（AbstractGenericHttpMessageConverter实现类）的write方法来进行对象的序列化输出。</p>
<p>大家都知道@ResponseBody需要通过io流来读取，也就HttpMessageConverter最终的write会写入到io输出流中，上面的createOutputMessage(webRequest)方法就是创建一个输出流，我们来具体看看它的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ServletServerHttpResponse <span class="title function_">createOutputMessage</span><span class="params">(NativeWebRequest webRequest)</span> &#123;</span><br><span class="line">	<span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> webRequest.getNativeResponse(HttpServletResponse.class);</span><br><span class="line">		Assert.state(response != <span class="literal">null</span>, <span class="string">&quot;No HttpServletResponse&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletServerHttpResponse</span>(response);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletServerHttpResponse</span> <span class="keyword">implements</span> <span class="title class_">ServerHttpResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HttpServletResponse servletResponse;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HttpHeaders headers;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">headersWritten</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">bodyUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Construct a new instance of the ServletServerHttpResponse based on the given &#123;<span class="doctag">@link</span> HttpServletResponse&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> servletResponse the servlet response</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ServletServerHttpResponse</span><span class="params">(HttpServletResponse servletResponse)</span> &#123;</span><br><span class="line">		Assert.notNull(servletResponse, <span class="string">&quot;HttpServletResponse must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.servletResponse = servletResponse;</span><br><span class="line">		<span class="built_in">this</span>.headers = <span class="keyword">new</span> <span class="title class_">ServletResponseHttpHeaders</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletResponse</span> &#123;</span><br><span class="line">    String <span class="title function_">getCharacterEncoding</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getContentType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setCharacterEncoding</span><span class="params">(String var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setContentLength</span><span class="params">(<span class="type">int</span> var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setContentLengthLong</span><span class="params">(<span class="type">long</span> var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setContentType</span><span class="params">(String var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBufferSize</span><span class="params">(<span class="type">int</span> var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getBufferSize</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resetBuffer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setLocale</span><span class="params">(Locale var1)</span>;</span><br><span class="line"></span><br><span class="line">    Locale <span class="title function_">getLocale</span><span class="params">()</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>createOutputMessage方法中创建了ServletServerHttpResponse ，然后通过 ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage)方法写入到输出流中。write方法的核心也是通过Jackson工具将对象解析为json字符串。我们最后来看看write的核心处理方法writeInternal。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部写方法，用于将给定的对象序列化并写入到HTTP响应输出流中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object 待序列化的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 对象类型，可以为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputMessage HTTP输出消息，包含头部信息和输出流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 如果发生I/O错误</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotWritableException 如果无法将消息写入输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeInternal</span><span class="params">(Object object, <span class="meta">@Nullable</span> Type type, HttpOutputMessage outputMessage)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输出内容的媒体类型（Content-Type）</span></span><br><span class="line">    <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> outputMessage.getHeaders().getContentType();</span><br><span class="line">    <span class="comment">// 根据MediaType确定JSON编码方式</span></span><br><span class="line">    <span class="type">JsonEncoding</span> <span class="variable">encoding</span> <span class="operator">=</span> getJsonEncoding(contentType);</span><br><span class="line">    <span class="comment">// 创建JSON生成器，使用指定的编码方式写入输出流</span></span><br><span class="line">    <span class="type">JsonGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="built_in">this</span>.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 写入前缀，可能包括自定义的头部或其他元数据</span></span><br><span class="line">        writePrefix(generator, object);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> object;</span><br><span class="line">        Class&lt;?&gt; serializationView = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FilterProvider</span> <span class="variable">filters</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">JavaType</span> <span class="variable">javaType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果对象是MappingJacksonValue类型，则从中提取值、视图和过滤器</span></span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> MappingJacksonValue) &#123;</span><br><span class="line">            <span class="type">MappingJacksonValue</span> <span class="variable">container</span> <span class="operator">=</span> (MappingJacksonValue) object;</span><br><span class="line">            value = container.getValue();</span><br><span class="line">            serializationView = container.getSerializationView();</span><br><span class="line">            filters = container.getFilters();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果提供了类型信息且与对象类型兼容，则获取Java类型表示</span></span><br><span class="line">        <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; TypeUtils.isAssignable(type, value.getClass())) &#123;</span><br><span class="line">            javaType = getJavaType(type, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据提供的视图或过滤器配置ObjectWriter</span></span><br><span class="line">        <span class="type">ObjectWriter</span> <span class="variable">objectWriter</span> <span class="operator">=</span> (serializationView != <span class="literal">null</span> ?</span><br><span class="line">                <span class="built_in">this</span>.objectMapper.writerWithView(serializationView) : <span class="built_in">this</span>.objectMapper.writer());</span><br><span class="line">        <span class="keyword">if</span> (filters != <span class="literal">null</span>) &#123;</span><br><span class="line">            objectWriter = objectWriter.with(filters);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果指定了Java类型并且它是容器类型，则进一步配置ObjectWriter</span></span><br><span class="line">        <span class="keyword">if</span> (javaType != <span class="literal">null</span> &amp;&amp; javaType.isContainerType()) &#123;</span><br><span class="line">            objectWriter = objectWriter.forType(javaType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据配置决定是否启用缩进输出</span></span><br><span class="line">        <span class="type">SerializationConfig</span> <span class="variable">config</span> <span class="operator">=</span> objectWriter.getConfig();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span> &amp;&amp; contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &amp;&amp;</span><br><span class="line">                config.isEnabled(SerializationFeature.INDENT_OUTPUT)) &#123;</span><br><span class="line">            objectWriter = objectWriter.with(<span class="built_in">this</span>.ssePrettyPrinter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ObjectWriter将对象序列化为JSON格式并写入生成器</span></span><br><span class="line">        objectWriter.writeValue(generator, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入后缀，可能包括结束标记或其他元数据</span></span><br><span class="line">        writeSuffix(generator, object);</span><br><span class="line">        <span class="comment">// 刷新生成器以确保所有数据都被写出</span></span><br><span class="line">        generator.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidDefinitionException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConversionException</span>(<span class="string">&quot;Type definition error: &quot;</span> + ex.getType(), ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JsonProcessingException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageNotWritableException</span>(<span class="string">&quot;Could not write JSON: &quot;</span> + ex.getOriginalMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回HTTP响应的输出流。在首次调用时设置bodyUsed标志，并写入头部。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 输出流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException 如果发生I/O错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> OutputStream <span class="title function_">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.bodyUsed = <span class="literal">true</span>;</span><br><span class="line">    writeHeaders();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.servletResponse.getOutputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objectWriter.writeValue(generator, value)</code>方法中将value对象通过serialize序列化方法，将对象转为<code>json</code>字符串，然后设置到io流中。我们最后看看Jackson最终的序列化是怎么样的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object bean, JsonGenerator gen, SerializerProvider provider)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_objectIdWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            gen.setCurrentValue(bean); <span class="comment">// [databind#631]</span></span><br><span class="line">            _serializeWithObjectId(bean, gen, provider, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置json的开始符号（&quot;&#123;&quot;）</span></span><br><span class="line">        gen.writeStartObject(bean);</span><br><span class="line">        <span class="keyword">if</span> (_propertyFilterId != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 循环将对象设置为json字符串 serializeFieldsFiltered(bean, gen, provider);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serializeFields(bean, gen, provider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置json的结束符号（&quot;&#125;&quot;）</span></span><br><span class="line">        gen.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此我们就基本走完了一个HTTP请求和响应的过程。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Allimac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/12/Analysis-of-the-Source-Code-of-the-Request-Annotation/">http://example.com/2025/03/12/Analysis-of-the-Source-Code-of-the-Request-Annotation/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">AllimacBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><a class="post-meta__tags" href="/tags/SpringMVC/">SpringMVC</a></div><div class="post-share"><div class="social-share" data-image="https://s21.ax1x.com/2025/03/12/pEU3V7d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/03/JavaWeb-11/" title="JavaWeb-11"><img class="cover" src="https://s21.ax1x.com/2025/03/03/pEGhmLj.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaWeb-11</div></div><div class="info-2"><div class="info-item-1">事务&AOP</div></div></div></a><a class="pagination-related" href="/2025/03/12/NetWork-4/" title="NetWork-4"><img class="cover" src="https://s21.ax1x.com/2025/03/12/pEU3M1f.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">NetWork-4</div></div><div class="info-2"><div class="info-item-1">委托协议栈发送消息的过程</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Allimac</div><div class="author-info-description">华丽的仓库存放着我简陋的思想</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AillemaCc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AillemaCc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="http://www.swindle.icu/#/Home" target="_blank" title="曾经的博客"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是小梦一场的大床</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Controller%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">Controller注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">映射建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90handlerMethod"><span class="toc-number">1.2.</span> <span class="toc-text">解析handlerMethod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8ChandlerMethod"><span class="toc-number">1.3.</span> <span class="toc-text">注册handlerMethod</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MappingRegistry%E6%98%A0%E5%B0%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">MappingRegistry映射注册中心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">具体注册过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RequestBody"><span class="toc-number">2.</span> <span class="toc-text">RequestBody</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">解析过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">返回值序列化过程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/15/A-First-Look-At-Zookeeper/" title="A-First-Look-At-Zookeeper"><img src="https://s21.ax1x.com/2025/03/15/pEaaHz9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A-First-Look-At-Zookeeper"/></a><div class="content"><a class="title" href="/2025/03/15/A-First-Look-At-Zookeeper/" title="A-First-Look-At-Zookeeper">A-First-Look-At-Zookeeper</a><time datetime="2025-03-15T05:21:49.000Z" title="发表于 2025-03-15 13:21:49">2025-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/15/A-First-Look-At-RocketMQ/" title="A-First-Look-At-RocketMQ"><img src="https://s21.ax1x.com/2025/03/15/pEaULE8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A-First-Look-At-RocketMQ"/></a><div class="content"><a class="title" href="/2025/03/15/A-First-Look-At-RocketMQ/" title="A-First-Look-At-RocketMQ">A-First-Look-At-RocketMQ</a><time datetime="2025-03-15T05:13:11.000Z" title="发表于 2025-03-15 13:13:11">2025-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/15/A-First-Look-At-Kafka/" title="A-First-Look-At-Kafka"><img src="https://s21.ax1x.com/2025/03/15/pEaUHDP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A-First-Look-At-Kafka"/></a><div class="content"><a class="title" href="/2025/03/15/A-First-Look-At-Kafka/" title="A-First-Look-At-Kafka">A-First-Look-At-Kafka</a><time datetime="2025-03-15T05:08:55.000Z" title="发表于 2025-03-15 13:08:55">2025-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/12/NetWork-5/" title="NetWork-5"><img src="https://s21.ax1x.com/2025/03/12/pEU3ljS.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NetWork-5"/></a><div class="content"><a class="title" href="/2025/03/12/NetWork-5/" title="NetWork-5">NetWork-5</a><time datetime="2025-03-12T10:20:14.000Z" title="发表于 2025-03-12 18:20:14">2025-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/12/NetWork-4/" title="NetWork-4"><img src="https://s21.ax1x.com/2025/03/12/pEU3M1f.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="NetWork-4"/></a><div class="content"><a class="title" href="/2025/03/12/NetWork-4/" title="NetWork-4">NetWork-4</a><time datetime="2025-03-12T10:20:01.000Z" title="发表于 2025-03-12 18:20:01">2025-03-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Allimac</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>