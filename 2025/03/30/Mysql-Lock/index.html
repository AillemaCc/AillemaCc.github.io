<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Mysql-Lock | AllimacBlog</title><meta name="author" content="Allimac"><meta name="copyright" content="Allimac"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="mysql锁部分">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql-Lock">
<meta property="og:url" content="http://example.com/2025/03/30/Mysql-Lock/index.html">
<meta property="og:site_name" content="AllimacBlog">
<meta property="og:description" content="mysql锁部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2025-03-30T13:35:48.000Z">
<meta property="article:modified_time" content="2025-03-30T13:37:13.178Z">
<meta property="article:author" content="Allimac">
<meta property="article:tag" content="数据库基础">
<meta property="article:tag" content="锁机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Mysql-Lock",
  "url": "http://example.com/2025/03/30/Mysql-Lock/",
  "image": "http://example.com/img/avatar.png",
  "datePublished": "2025-03-30T13:35:48.000Z",
  "dateModified": "2025-03-30T13:37:13.178Z",
  "author": [
    {
      "@type": "Person",
      "name": "Allimac",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/faviconcute.png"><link rel="canonical" href="http://example.com/2025/03/30/Mysql-Lock/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql-Lock',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/nature_top_image.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">AllimacBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">Mysql-Lock</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Mysql-Lock</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-30T13:35:48.000Z" title="发表于 2025-03-30 21:35:48">2025-03-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-30T13:37:13.178Z" title="更新于 2025-03-30 21:37:13">2025-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="锁的由来"><a href="#锁的由来" class="headerlink" title="锁的由来"></a>锁的由来</h2><p>客户端发往mysql的一条条<code>SQL</code>语句，实际上都可以理解成一个个单独的事务（一条sql语句默认就是一个事务）。事务事实上是基于数据库链接的，每个数据库连接在<code>MySQL</code>中，又会用一条工作线程来维护，也意味着一个事务的执行，本质上就是一条工作线程在执行，当出现多个事务同时执行时，这种情况则被称之为并发事务，所谓的并发事务也就是指多条线程并发执行。</p>
<p>多线程并发执行，如果不加以限制或者保护，就会不可避免的出现问题。也就是我们说的<strong>脏写、脏读、不可重复读及幻读问题</strong>。而对于这些问题又可以通过调整事务的隔离级别来避免，那为什么调整事务的隔离级别后能避免这些问题产生呢？这是因为不同的隔离级别中，工作线程执行<code>SQL</code>语句时，用的锁粒度、类型不同。</p>
<h2 id="锁定义"><a href="#锁定义" class="headerlink" title="锁定义"></a>锁定义</h2><p>事实上我们在前面已经写过不少关于锁的文章的笔记，但直到现在，我们才开始真正的看看锁是什么定义的。**锁是计算机协调多个进程或线程并发访问某一资源的机制。**在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><p><code>MySQL</code>的锁机制与索引机制类似，都是由存储引擎负责实现的，这也就意味着不同的存储引擎，支持的锁也并不同，这里是指不同的引擎实现的锁粒度不同。但除开从锁粒度来划分锁之外，其实锁也可以从其他的维度来划分，因此也会造出很多关于锁的名词，下面先简单梳理一下<code>MySQL</code>的锁体系：</p>
<ul>
<li>以锁粒度的维度划分<ul>
<li>全局锁：锁定数据库中的所有表。加上全局锁之后，整个数据库只能允许读，不允许做任何写操作</li>
<li>表级锁：每次操作锁住整张表。主要分为三类<ul>
<li>表锁（分为表共享读锁 read lock、表独占写锁 write lock）</li>
<li>元数据锁（meta data lock，MDL）：基于表的元数据加锁，加锁后整张表不允许其他事务操作。这里的元数据可以简单理解为一张表的表结构</li>
<li>意向锁（分为意向共享锁、意向排他锁）：这个是<code>InnoDB</code>中为了支持多粒度的锁，为了兼容行锁、表锁而设计的，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</li>
</ul>
</li>
<li>行级锁：每次操作锁住对应的行数据。主要分为三类<ul>
<li>记录锁 &#x2F; Record 锁：也就是行锁，一条记录和一行数据是同一个意思。防止其他事务对此行进行update和delete，在 RC、RR隔离级别下都支持</li>
<li>间隙锁 &#x2F; Gap 锁：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</li>
<li>临键锁 &#x2F; Next-Key 锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能，在RR隔离级别下支持</li>
</ul>
</li>
</ul>
</li>
<li>以互斥性的角度划分<ul>
<li>共享锁 &#x2F; S锁：不同事务之间不会相互排斥、可以同时获取的锁</li>
<li>排他锁 &#x2F; X锁：不同事务之间会相互排斥、同时只能允许一个事务获取的锁</li>
<li>共享排他锁 &#x2F; SX锁：<code>MySQL5.7</code>版本中新引入的锁，主要是解决<code>SMO</code>带来的问题</li>
</ul>
</li>
<li>以操作类型的维度划分<ul>
<li>读锁：查询数据时使用的锁</li>
<li>写锁：执行插入、删除、修改、<code>DDL</code>语句时使用的锁</li>
</ul>
</li>
<li>以加锁方式的维度划分<ul>
<li>显示锁：编写<code>SQL</code>语句时，手动指定加锁的粒度</li>
<li>隐式锁：执行<code>SQL</code>语句时，根据隔离级别自动为<code>SQL</code>操作加锁</li>
</ul>
</li>
<li>以思想的维度划分<ul>
<li>乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁</li>
<li>悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行</li>
</ul>
</li>
</ul>
<p>放眼望下来，是不是看着还蛮多的，但总归说来说去其实就共享锁、排他锁两种，只是加的方式不同、加的地方不同，因此就演化出了这么多锁的称呼。</p>
<h1 id="共享锁-排它锁"><a href="#共享锁-排它锁" class="headerlink" title="共享锁 排它锁"></a>共享锁 排它锁</h1><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>定义：<strong>一个事务已获取共享锁，当另一个事务尝试对具备共享锁的数据进行读操作时，可正常读；进行写操作时，会被共享锁排斥</strong>。</p>
<p>共享锁的意思很简单，也就是不同事务之间不会排斥，可以同时获取锁并执行。但这里所谓的不会排斥，仅仅只是指<strong>不会排斥其他事务来读数据，但其他事务尝试写数据时，就会出现排斥性</strong>，举个例子理解：</p>
<blockquote>
<p>事务<code>T1</code>对<code>ID=18</code>的数据加了一个共享锁，此时事务<code>T2、T3</code>也来读取<code>ID=18</code>的这条数据，这时<code>T2、T3</code>是可以获取共享锁执行的；但此刻又来了一个事务<code>T4</code>，它则是想对<code>ID=18</code>的这条数据执行修改操作，此时共享锁会出现排斥行为，不允许<code>T4</code>获取锁执行</p>
</blockquote>
<p>在<code>MySQL</code>中，我们可以在<code>SQL</code>语句后加上相关的关键字来使用共享锁，<strong>语法</strong>如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- MySQL8.0之后也优化了写法，如下：</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>

<p>这种通过在<code>SQL</code>后添加关键字的加锁形式，被称为显式锁，而实际上为数据库设置了不同的事务隔离级别后，<code>MySQL</code>也会对<code>SQL</code>自动加锁，这种形式则被称之为隐式锁。</p>
<p>样例：做个关于共享锁的小测试，先打开两个cmd窗口并于mysql建立连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口1：</span></span><br><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 获取共享锁并查询 id=2 的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bank_balance <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口2：</span></span><br><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 获取共享锁并查询 id=2 的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bank_balance <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试修改id=2的数据</span></span><br><span class="line"><span class="keyword">update</span> bank_balance <span class="keyword">set</span> balance<span class="operator">=</span><span class="number">230</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEawtBt"><img src="https://s21.ax1x.com/2025/03/15/pEawtBt.png" alt="pEawtBt.png"></a></p>
<ul>
<li>当窗口1获取了共享锁，窗口2执行查询&#x2F;读操作时 可获取共享锁、正常读；但当窗口2执行修改&#x2F;写操作时 窗口2没反应、未执行成功。</li>
<li>而当窗口1中事务A提交后，窗口2事务B的写操作才能继续往下执行。</li>
</ul>
<p>由上可见，<strong>一个事务已获取共享锁，当另一个事务尝试对具备共享锁的数据进行读操作时，可正常读；进行写操作时，会被共享锁排斥</strong>。因此从这个实验中可以得知：共享锁也具备排他性，会排斥其他尝试写的线程，当有线程尝试修改同一数据时会陷入阻塞，直至持有共享锁的事务结束才能继续执行</p>
<h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p>上面简单的了解了共享锁之后，紧着来看看排他锁，排他锁也被称之为独占锁。</p>
<p><strong>当一个线程获取到独占锁后，会排斥其他线程（进行读写操作），如若其他线程也想对共享资源&#x2F;同一数据进行操作，必须等到当前线程释放锁并竞争到锁资源才行</strong>。写绝对是独占的</p>
<blockquote>
<p>值得注意的一点是：排他锁并不是只能用于写操作，对于一个读操作，咱们也可以手动地指定为获取排他锁，<strong>当一个事务在读数据时，获取了排他锁，那当其他事务来读、写同一数据时，都会被排斥</strong>。比如事务<code>T1</code>对<code>ID=18</code>的这条数据加了一个排他锁，此时<code>T2</code>来加排他锁读取这条数据，<code>T3</code>来修改这条数据，都会被<code>T1</code>排斥。</p>
</blockquote>
<p>在<code>MySQL</code>中，可以通过如下方式显式获取独占锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> UPTATE;</span><br></pre></td></tr></table></figure>

<p>当两个事务同时获取排他锁，尝试读取一条相同的数据时，其中一个事务就会陷入阻塞，直至另一个事务结束才能继续往下执行；</p>
<p>但是<code>select * from bank_balance where id=2</code>这种普通读(不加排它锁的读) 不会被阻塞，也就是另一个事务不获取排他锁读数据，而是以普通的方式读数据，这种方式则可以立刻执行，<code>Why</code>？是因为读操作默认加共享锁吗？并不是，因为你尝试加共享锁读这条数据时依旧会被排斥。</p>
<blockquote>
<p>你的理解是正确的，排他锁（Exclusive Lock）确实是为了独占写操作而设计的，它确保没有其他事务可以同时对该数据进行修改或获取共享锁（Shared Lock）。然而，当提到普通读（即非锁定读或快照读），这里涉及到数据库实现的一个关键概念：多版本并发控制（MVCC, Multi-Version Concurrency Control）。</p>
<p>在支持MVCC的数据库系统中（例如PostgreSQL和MySQL的InnoDB存储引擎），当你执行一个普通的<code>SELECT</code>查询时，并不会对数据行加锁。相反，它会读取数据的一个快照，这个快照是在你事务开始的那个时刻数据库的状态。这样做的好处是可以避免读操作阻塞写操作，反之亦然，从而提高并发性能。</p>
<p>具体来说：</p>
<ul>
<li><p><strong>排他锁</strong>：当一个事务需要修改数据时，它会对相应的数据行加排他锁，这意味着在此期间其他任何事务都不能对这些数据行加任何类型的锁（包括共享锁和排他锁），直到当前事务完成并释放锁。</p>
</li>
<li><p><strong>普通读（快照读）</strong>：使用MVCC机制，普通<code>SELECT</code>语句能够读取到事务开始时的数据版本，而不需要加锁。这使得读操作不会被写操作所阻塞，因为它们并不试图访问最新的已提交数据，而是访问事务开始时的数据视图。</p>
</li>
</ul>
<p>因此，在你给出的例子中，<code>select * from bank_balance where id=2</code>这样的查询不会被另一个持有排他锁的事务所阻塞，因为它只是读取了一个快照而不是尝试获取最新数据的锁。这种机制有效地提高了数据库的并发处理能力，减少了读写冲突。</p>
</blockquote>
<p>增、删、改都会对数据添加X锁，在查询语句中使用for update也会添加X锁</p>
<h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><p>在前面的测试中，每次都仅获取了锁，但好像从未释放过锁？其实<code>MySQL</code>中释放锁的动作都是隐式的，毕竟如果交给咱们来释放，很容易由于操作不当造成死锁问题发生。因此对于锁的释放工作，<code>MySQL</code>自己来干，就类似于<code>JVM</code>中的<code>GC</code>机制一样，把内存释放的工作留给了自己完成。</p>
<ul>
<li>但对于锁的释放时机，在不同的隔离级别中也并不相同，比如在“读未提交”级别中，是<code>SQL</code>执行完成后就立马释放锁；而在“可重复读”级别中，是在事务结束后才会释放。</li>
</ul>
<blockquote>
<p>如果完全按照数据库规范来实现<code>RC</code>隔离级别，为了保证其他事务可以读到未提交的数据，那就必须得在<code>SQL</code>执行完成后，立马释放掉锁，这时另一个事务才能读到<code>SQL</code>对应写的数据，但在<code>InnoDB</code>引擎中，它基于<code>MVCC</code>机制实现了该效果，为此，<code>InnoDB</code>的<code>RC</code>级别中，<code>SQL</code>执行结束后并不会释放锁。</p>
</blockquote>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<p>为什么全库逻辑备份，就需要加全就锁呢？  ——我们分析下 不加全局锁 可能存在的问题、以及加了全局锁后的情况。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaw4CF"><img src="https://s21.ax1x.com/2025/03/15/pEaw4CF.png" alt="pEaw4CF.png"></a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 加全局锁、获取全局锁</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;  </span><br><span class="line"></span><br><span class="line"># 数据备份。具体指令可见 </span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p 数据库名 <span class="operator">&gt;</span> <span class="operator">/</span>back<span class="operator">/</span>backup.sql</span><br><span class="line"></span><br><span class="line"># 释放全局锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>给数据库加一个全局锁，其实算作是一个很笨重的指令。也比较需要谨慎。</p>
<p>他有比较多的问题</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ul>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>
<p>表级锁：每次操作锁住整张表。主要分为三类</p>
<ul>
<li>表锁（分为表共享读锁 read lock、表独占写锁 write lock）</li>
<li>元数据锁（meta data lock，MDL）：基于表的元数据加锁，加锁后整张表不允许其他事务操作。这里的元数据可以简单理解为一张表的表结构</li>
<li>意向锁（分为意向共享锁、意向排他锁）：这个是<code>InnoDB</code>中为了支持多粒度的锁，为了兼容行锁、表锁而设计的，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</li>
</ul>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>表锁应该是听的最多的一种锁，因为实现起来比较简单，同时应用范围也比较广泛，几乎所有的存储引擎都会支持这个粒度的锁，比如常用的<code>MyISAM、InnoDB、Memory</code>等各大引擎都实现了表锁。</p>
<p>使用表锁的开销相对较小，加锁快，不会产生死锁；但是加锁粒度大，发生锁冲突的概率更高，并发度更低。在innoDB存储引擎中不推荐使用表锁，只有在没有事务支持的存储引擎中才会使用，如MyISAM</p>
<p><strong>对于表锁，分为两类</strong>：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
<p><strong>语法</strong>：</p>
<ul>
<li>加锁：lock tables 表名… read&#x2F;write</li>
<li>释放锁：unlock tables &#x2F; 客户端断开连接</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEa0Svd"><img src="https://s21.ax1x.com/2025/03/15/pEa0Svd.png" alt="pEa0Svd.png"></a></p>
<p>但要注意，不同引擎的表锁也在实现上以及加锁方式上有些许不同，但归根结底，表锁的意思也就以表作为锁的基础，将锁加在表上，一张表只能存在一个同一类型的表锁。</p>
<p>上面这段话中提到过，不同的存储引擎的表锁在使用方式上也有些不同，比如<code>InnoDB</code>是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当<code>SQL</code>执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁</p>
<blockquote>
<p>当在<code>InnoDB</code>存储引擎中执行SQL查询时，如果查询条件能够通过聚簇索引直接定位到特定的行，那么<code>InnoDB</code>会使用行锁而不是表锁。以下是详细解释为什么这种情况会发生：</p>
<h3 id="聚簇索引（Clustered-Index）"><a href="#聚簇索引（Clustered-Index）" class="headerlink" title="聚簇索引（Clustered Index）"></a>聚簇索引（Clustered Index）</h3><p>在<code>InnoDB</code>中，聚簇索引是指数据行本身按照某种顺序（通常是主键）存储在索引结构中。这意味着聚簇索引不仅仅是索引，它还包含了实际的数据行。每个表只能有一个聚簇索引，因为数据行只能按一种顺序物理存储。</p>
<h3 id="行锁的工作原理"><a href="#行锁的工作原理" class="headerlink" title="行锁的工作原理"></a>行锁的工作原理</h3><ol>
<li><p><strong>精确锁定</strong>：当查询条件能够通过聚簇索引直接命中具体的行时，<code>InnoDB</code>可以准确地知道哪些行需要被锁定。例如，如果你执行一个带有主键条件的查询，如 <code>SELECT * FROM table_name WHERE id = 1 FOR UPDATE;</code>，<code>InnoDB</code>可以通过聚簇索引快速找到对应的行，并只对这些行加锁。</p>
</li>
<li><p><strong>并发性提高</strong>：由于行锁仅锁定具体的行，其他事务仍然可以访问和修改未被锁定的行。这种细粒度的锁定机制极大地提高了数据库的并发处理能力，减少了读写冲突的可能性。</p>
</li>
<li><p><strong>锁定范围小</strong>：行锁的作用范围仅限于被操作的具体行，这比锁定整个表要高效得多。锁定范围越小，系统能同时处理的任务就越多，从而提高了整体性能。</p>
</li>
</ol>
<h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>假设你有一个表<code>bank_accounts</code>，其结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> bank_accounts (</span><br><span class="line">    account_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">15</span>,<span class="number">2</span>),</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>account_id</code>是聚簇索引（同时也是主键）。当你执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bank_accounts <span class="keyword">WHERE</span> account_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>由于查询条件<code>account_id = 1</code>可以直接通过聚簇索引找到具体的行，<code>InnoDB</code>只需要对<code>account_id = 1</code>这一行加排他锁（X锁），而不会影响其他行。这样，其他事务仍然可以对其他账户进行读取或修改操作，而不必等待当前事务释放锁。</p>
<h3 id="对比全表扫描"><a href="#对比全表扫描" class="headerlink" title="对比全表扫描"></a>对比全表扫描</h3><p>相比之下，如果你执行一个无法有效利用索引的查询，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bank_accounts <span class="keyword">WHERE</span> balance <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>balance</code>列没有索引，<code>InnoDB</code>将不得不进行全表扫描来查找符合条件的所有行。在这种情况下，为了保证数据一致性，<code>InnoDB</code>可能会选择对整个表加锁，从而导致更高的锁竞争和更低的并发性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当查询条件能够通过聚簇索引直接命中具体的数据行时，<code>InnoDB</code>会选择加行锁而非表锁的原因在于：</p>
<ul>
<li><strong>精确锁定</strong>：可以准确定位并锁定需要操作的行。</li>
<li><strong>提高并发性</strong>：允许其他事务继续操作未被锁定的行，从而提升系统的并发处理能力。</li>
<li><strong>锁定范围小</strong>：减少锁定的资源量，降低锁竞争，提高性能。</li>
</ul>
<p>因此，合理设计索引以支持查询条件，对于最大化数据库的并发性能至关重要。</p>
</blockquote>
<p>InnoDB表锁显式获取后，必须要自己主动释放，否则结合数据库连接池，由于数据库连接是长存的，就会导致表锁一直被占用。当你加了<code>read</code>读锁后，再尝试加<code>write</code>写锁，就会发现无法获取锁，当前线程会陷入阻塞，反过来也是同理。</p>
<h2 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h2><p><code>Meta Data Lock</code>元数据锁，也被简称为<code>MDL</code>锁，这是基于表的元数据加锁，什么意思呢？我们在上文讲过：表锁是基于整张表加锁，行锁是基于一条数据加锁，那这个表的元数据是什么呢？<strong>所有存储引擎的表都会存在一个<code>.frm</code>文件，这个文件中主要存储表的结构（<code>DDL</code>语句，包括表结构的定义信息、创建删除修改表等）</strong>。而**<code>MDL</code>锁就是基于<code>.frm</code>文件中的元数据加锁**的。这里的元数据 可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>
<p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上，<strong>当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)</strong>。MDL锁主要作用是维护表元数据的数据一致性。在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong>。</p>
<p>MDL是在<code>MySQL5.5</code>版本后再开始支持的，一般来说咱们用不上，因此也无需手动获取锁，主要在 <strong>更改表结构时使用</strong>，比如你要向一张表创建&#x2F;删除一个索引、修改一个字段的名称&#x2F;数据类型、增加&#x2F;删除一个表字段等这类情况。因为毕竟当你的表结构正在发生更改，假设此时有其他事务来对表做<code>CRUD</code>操作，自然就会出现问题，比如我刚删了一个表字段，结果另一个事务中又按原本的表结构插入了一条数据，这显然会存在风险，因此<code>MDL</code>锁在加锁后，整张表不允许其他事务做任何操作。</p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p><code>InnoDB</code>引擎是一种支持多粒度锁的引擎，而意向锁则是<code>InnoDB</code>中为了支持多粒度的锁，为了<strong>兼容行锁、表锁</strong>而设计的，怎么理解这句话呢？先来看一个例子：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaBiQJ"><img src="https://s21.ax1x.com/2025/03/15/pEaBiQJ.png" alt="pEaBiQJ.png"></a></p>
<blockquote>
<p>假设一张表中有一千万条数据，现在事务<code>T1</code>对<code>ID=8888888</code>的这条数据加了一个行锁，此时来了一个事务<code>T2</code>，想要获取这张表的表级别写锁，经过前面的一系列讲解，大家应该知道写锁必须为排他锁，也就是在同一时刻内，只允许当前事务操作，如果表中存在其他事务已经获取了锁，目前事务就无法满足“独占性”，因此不能获取锁。</p>
<p>那思考一下，由于<code>T1</code>是对<code>ID=8888888</code>的数据加了行锁，那<code>T2</code>获取表锁时，是不是得先判断一下表中是否存在其他事务在操作？但因为<code>InnoDB</code>中有行锁的概念，所以表中任何一行数据上都有可能存在事务加锁操作，为了能精准的知道答案，<code>MySQL</code>就得<strong>将整张表的<code>1000W</code>条数据全部遍历一次，然后逐条查看是否有锁存在</strong>，那这个效率自然会非常的低。</p>
<p>有人可能会说，慢就慢点怎么了，能接受！但实际上不仅仅存在这个问题，还有另外一个致命问题，比如现在<code>MySQL</code>已经判断到了第<code>567W</code>行数据，发现前面的数据上都没有锁存在，正在继续往下遍历。</p>
<p>要记住<code>MySQL</code>是支持并发事务的，也就是<code>MySQL</code>正在扫描后面的每行数据是否存在锁时，万一<strong>又来了一个事务在扫描过的数据行上加了个锁</strong>怎么办？比如在第<code>123W</code>条数据上加了一个行锁。那难道又重新扫描一遍嘛？这就陷入了死循环，行锁和表锁之间出现了兼容问题。</p>
</blockquote>
<p>由于行锁和表锁之间存在兼容性问题，提出了意向锁。意向锁实际上也是一种特殊的表锁，意向锁其实是一种“挂牌告知”的思想，好比日常生活中的出租车，一般都会有一个牌子，表示它目前是“空车”还是“载客”状态，而意向锁也是这个思想。</p>
<p>比如当事务<code>T1</code>打算对<code>ID=8888888</code>这条数据加一个行锁之前（行级别的读锁或写锁），就会先加一个表级别的意向锁。此时当事务<code>T2</code>尝试获取一个表级锁时，就会先看一下表上是否有意向锁，如果有的话再判断一下与自身是否冲突，比如表上存在一个意向共享锁，目前<code>T2</code>要获取的是表级别的读锁，那自然不冲突可以获取。但反之，如果<code>T2</code>要获取一个表级的写锁时，就会出现冲突，<code>T2</code>事务则会陷入阻塞，直至<code>T1</code>释放了锁（事务结束）为止。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>意向共享锁（IS）：由语句select … lock in share mode添加，与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。在准备给表数据添加一个S锁时，需要先获得该表的IS锁</li>
<li>意向排他锁（IX）：由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。在准备给表数据添加一个X锁时，需要先获得该表的IX锁</li>
</ul>
<blockquote>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
</blockquote>
<h1 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。在<code>MySQL</code>诸多的存储引擎中，仅有<code>InnoDB</code>引擎支持行锁（不考虑那些闭源自研的），MyISAM等引擎不支持行锁【因为<code>InnoDB</code>支持聚簇索引索引结构的叶子节点保存了<strong>行数据</strong>。在之前简单聊到过，<code>InnoDB</code>中如果能够命中索引数据，就会加行锁，无法命中则会加表锁。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过<strong>对索引上的索引项加锁</strong>来实现的，而<strong>不是对记录加的锁</strong>。对于行级锁，主要分为以下三类：行锁、间隙锁、临键锁</p>
<ul>
<li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持</li>
<li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），左右开区间，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</li>
<li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，左开右闭。 在RR隔离级别下支持</li>
</ul>
<p>InnoDB的数据是基于索引组织的</p>
<blockquote>
<p>Q：那么没有加索引的数据，或者整张表除了主键之外没有其他索引，怎么组织数据。还是说主键就是一种索引</p>
<p>A：</p>
<p>在<code>InnoDB</code>存储引擎中，数据的组织方式确实与索引密切相关。具体来说，<code>InnoDB</code>使用一种称为**聚簇索引（Clustered Index）**的数据结构来组织数据。以下是详细的解释：</p>
<h3 id="聚簇索引（Clustered-Index）-1"><a href="#聚簇索引（Clustered-Index）-1" class="headerlink" title="聚簇索引（Clustered Index）"></a>聚簇索引（Clustered Index）</h3><ol>
<li><p><strong>主键作为聚簇索引</strong>：</p>
<ul>
<li>在<code>InnoDB</code>中，表的数据是根据主键（Primary Key）进行物理排序并存储的。换句话说，主键本身就是一种特殊的索引——聚簇索引。</li>
<li>每个表只能有一个聚簇索引，因为数据行只能按一种顺序物理存储。</li>
<li>如果没有显式定义主键，<code>InnoDB</code>会尝试使用第一个唯一非空索引作为聚簇索引；如果仍然没有找到合适的列，<code>InnoDB</code>会自动创建一个隐藏的列作为主键。</li>
</ul>
</li>
<li><p><strong>数据存储结构</strong>：</p>
<ul>
<li>聚簇索引不仅包含索引键值，还包含了实际的数据行。这意味着当你通过主键查找数据时，<code>InnoDB</code>可以直接定位到具体的行而不需要额外的查找操作。</li>
<li>由于数据行和索引键值一起存储在一个B+树结构中，这使得基于主键的查询非常高效。</li>
</ul>
</li>
</ol>
<h3 id="非聚簇索引（Secondary-Index）"><a href="#非聚簇索引（Secondary-Index）" class="headerlink" title="非聚簇索引（Secondary Index）"></a>非聚簇索引（Secondary Index）</h3><p>除了聚簇索引外，<code>InnoDB</code>还可以支持多个<strong>非聚簇索引（Secondary Index）</strong>。这些索引不包含实际的数据行，而是包含指向聚簇索引的指针（即主键值）。当通过非聚簇索引查找数据时，<code>InnoDB</code>首先查找索引，然后根据索引中的主键值再去聚簇索引中查找对应的数据行。</p>
<h3 id="没有其他索引的情况"><a href="#没有其他索引的情况" class="headerlink" title="没有其他索引的情况"></a>没有其他索引的情况</h3><p>如果你的表除了主键之外没有任何其他索引，那么所有的数据访问都将依赖于主键（聚簇索引）。具体来说：</p>
<ul>
<li><strong>插入数据</strong>：新记录将按照主键的顺序插入到聚簇索引的适当位置。如果没有主键值，则会自动生成一个隐藏的主键值。</li>
<li><strong>查询数据</strong>：所有基于主键的查询将直接利用聚簇索引进行高效查找。</li>
<li><strong>更新或删除数据</strong>：涉及主键的更新或删除操作也会直接利用聚簇索引来定位和修改数据。</li>
</ul>
<h3 id="示例说明-1"><a href="#示例说明-1" class="headerlink" title="示例说明"></a>示例说明</h3><p>假设你有一个表<code>employees</code>，其结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    department <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>id</code>列是主键，也是聚簇索引。所有数据行都按照<code>id</code>的顺序存储在B+树中。</li>
<li>如果你执行以下查询：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>由于查询条件可以通过聚簇索引直接命中具体的行，<code>InnoDB</code>可以高效地定位并返回结果。</p>
<p>如果你执行以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>由于<code>department</code>列上没有索引，<code>InnoDB</code>将不得不进行全表扫描来查找符合条件的所有记录。这种情况下，性能可能会受到影响，尤其是在数据量较大的情况下。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>主键就是一种索引</strong>：在<code>InnoDB</code>中，主键实际上是一个特殊的索引——聚簇索引。它不仅包含索引键值，还包含实际的数据行。</li>
<li><strong>数据组织方式</strong>：数据是按照主键的顺序存储的，因此基于主键的查询非常高效。</li>
<li><strong>无其他索引的影响</strong>：如果表除了主键之外没有其他索引，所有的查询和更新操作都将依赖于主键。对于没有索引支持的查询，可能会导致全表扫描，影响性能。</li>
</ul>
<p>为了提高查询性能，建议为常用的查询条件添加适当的非聚簇索引。这样可以在不影响数据一致性的情况下，显著提升查询效率。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEaBj6H"><img src="https://s21.ax1x.com/2025/03/15/pEaBj6H.png" alt="pEaBj6H.png"></a></p>
<h2 id="行锁-记录锁"><a href="#行锁-记录锁" class="headerlink" title="行锁&#x2F;记录锁"></a>行锁&#x2F;记录锁</h2><p>行锁（Record Lock），也称为记录锁，一行表数据、一条表记录本身就是同一个含义。锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p>
<p>锁住一行数据，在索引上才能加锁，非索引会升级为表级锁。</p>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取行级别的共享锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bank_balance <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取行级别的排他锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bank_balance <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>想要使用<code>InnoDB</code>的行锁就是这样写的，如果你的<code>SQL</code>能命中索引数据，那也就自然加的就是行锁，反之则是表锁。但网上很多资料都流传着一个说法：<code>InnoDB</code>引擎的表锁没啥用，其实这句话会存在些许误导性，因为意向锁、自增锁、<code>MDL</code>锁都是表锁，也包括<code>InnoDB</code>的行锁是基于索引实现的，例如在<code>update</code>语句修改数据时，假设<code>where</code>后面的条件无法命中索引，那咋加行锁呢？此时没办法就必须得加表锁了，因此<code>InnoDB</code>的表锁是有用的。</p>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><p>锁定索引记录间隙（不含该记录），左右开区间，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</p>
<p>1）间隙锁是对行锁的一种补充，主要是用来解决幻读问题的，但想要理解它，咱们首先来理解啥叫间隙</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bank_balance;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_name <span class="operator">|</span> balance <span class="operator">|</span> wealth <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+---------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Jenny     <span class="operator">|</span>     <span class="number">300</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Tom       <span class="operator">|</span>     <span class="number">230</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Jack      <span class="operator">|</span>     <span class="number">500</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> Rose      <span class="operator">|</span>     <span class="number">360</span> <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+---------+--------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>那为何又说间隙锁是用来解决幻读问题的呢？因为幻读的概念是：一个事务在执行时，另一个事务插入了一条数据，从而导致第一个事务操作完成之后发现结果与预想的不一致，跟产生了幻觉一样。 好比拿上述表举例子，现在要将<code>ID&gt;2</code>的用户余额改为<code>100</code>，因此事务<code>T1</code>先查到了<code>ID&gt;2</code>的<code>3、9</code>两条数据并上锁了，然后开始更改用户余额，但此时事务<code>T2</code>过来又插入了一条<code>ID=6、balance=320</code>的数据并提交，等<code>T1</code>修改完了<code>3、9</code>两条数据后，此时再次查询<code>ID&gt;2</code>的数据时，结果发现了<code>ID=6</code>的这条数据余额并未被修改、数据行比原来还多了。</p>
<p>在上述这个例子中，<code>T2</code>因为新增并提交了事务，所以<code>T1</code>再次查询时也能看到<code>ID=6</code>的这条数据，就跟产生了幻觉似的，对于这种新增数据，专业的叫法称之为幻影数据。</p>
<p>为了防止出现安全问题，所以<code>T1</code>在操作之前会对目标数据加锁，但在<code>T1</code>事务执行时，这条幻影数据还不存在，因此就会出现一个新的问题：不知道把锁加在哪儿，毕竟想要对<code>ID=6</code>的数据加锁，就是加了个寂寞。普通的行锁无法解决该问题，也不能加表锁、太影响性能了，此时间隙锁就应运而生，主要对间隙区域加锁</p>
</blockquote>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li>
<li>索引上的范围查询(唯一索引) – 会访问到不满足条件的第一个值为止</li>
</ul>
<p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁</p>
<h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><p>临键锁是间隙锁的<code>Plus</code>版本，或者可以说成是一种由记录锁+间隙锁组成的锁：</p>
<ul>
<li>记录锁：锁定的范围是表中具体的一条行数据。</li>
<li>间隙锁：锁定的范围是左右开区间，但不包含当前这一条真实数据，只锁间隙区域。</li>
</ul>
<p>而临键锁则是两者的结合体，加锁后，即锁定<strong>左开右闭</strong>的区间（每个临键锁是左开右闭区间），也会锁定当前行数据。</p>
<p>实际上在<code>InnoDB</code>中，除开一些特殊情况外，当尝试对一条数据加锁时，默认加的是临键锁，而并非记录锁、间隙锁。也就是说，在前面举例幻读问题中，当<code>T1</code>要对<code>ID&gt;2</code>的用户做修改余额，锁3、9这两条行数据时，默认会加的是临键锁，也就是当事务<code>T2</code>尝试插入<code>ID=6</code>的数据时，因为有临建锁存在，因此无法再插入这条“幻影数据”，也就至少保障了<code>T1</code>事务执行过程中，不会碰到幻读问题。</p>
<p>间隙锁和临建锁的目的都是用来解决可重复读的问题，如果在读提交级别，间隙锁和临建锁都会失效。</p>
<h1 id="页面锁，乐观锁与悲观锁"><a href="#页面锁，乐观锁与悲观锁" class="headerlink" title="页面锁，乐观锁与悲观锁"></a>页面锁，乐观锁与悲观锁</h1><p>页面锁是<code>Berkeley DB</code>存储引擎支持的一种锁粒度，当然，由于<code>BDB</code>引擎被<code>Oracle</code>收购的原因，因此<code>MySQL5.1</code>以后不再直接性的支持该引擎（需自己整合），因此页锁见的也比较少，大家稍微了解即可。</p>
<ul>
<li>表锁：以表为粒度，锁住的是整个表数据。</li>
<li>行锁：以行为粒度，锁住的是一条数据。</li>
<li>页锁：以页为粒度，锁住的是一页数据。</li>
</ul>
<p>唯一有些许疑惑的地方，就是一页数据到底是多少呢？其实我也不大清楚，毕竟没用过<code>BDB</code>引擎，但我估计就是只一个索引页的大小，即<code>16KB</code>左右。</p>
<p>简单了解后页锁后，接着来看一看从思想维度划分的两种锁，即乐观锁与悲观锁。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁即是无锁思想。</p>
<ul>
<li>乐观锁：每次执行都认为只会有自身一条线程操作，因此无需拿锁直接执行，在最后更新数据时进行比较</li>
<li>悲观锁：每次执行都认为会有其他线程一起来操作，因此每次都需要先拿锁再执行,保证不被其他事务操作；可通过select…fot update实现。</li>
</ul>
<p>编程中的无锁技术，或者说乐观锁机制，一般都是基于<code>CAS</code>思想实现的，而在<code>MySQL</code>中则可以通过<code>version</code>版本号+<code>CAS</code>的形式实现乐观锁，也就是在表中多设计一个<code>version</code>字段，然后在<code>SQL</code>修改时以如下形式操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> ... <span class="keyword">SET</span> version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">AND</span> version <span class="operator">=</span> version;</span><br></pre></td></tr></table></figure>

<p>也就是每条修改的<code>SQL</code>都在修改后，对<code>version</code>字段加一，比如<code>T1、T2</code>两个事务一起并发执行时，当<code>T2</code>事务执行成功提交后，就会对<code>version+1</code>，因此事务<code>T1</code>的<code>version=version</code>这个条件就无法成立，最终会放弃执行，因为已经被其他事务修改过了。</p>
<p>当然，一般的乐观锁都会配合轮询重试机制，比如上述<code>T1</code>执行失败后，再次执行相同语句，直到成功为止。</p>
<blockquote>
<p>从上述过程中不难看出，这个过程中确实未曾添加锁，因此也做到了乐观锁&#x2F;无锁的概念落地，但这种形式却并不适合所有情况，比如写操作的并发较高时，就容易导致一个事务长时间一直在重试执行，从而导致客户端的响应尤为缓慢。</p>
<p>因此乐观锁更加适用于读大于写的业务场景，频繁写库的业务则并不适合加乐观锁。</p>
</blockquote>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>每次执行时都会加锁再执行，可通过select…fot update实现。即在每次执行前必须获取到锁，然后才能继续往下执行，而数据库中的排他锁，就是一种典型的悲观锁类型。即在每次执行前必须获取到锁，然后才能继续往下执行，而数据库中的排他锁，就是一种典型的悲观锁类型。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Allimac</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/30/Mysql-Lock/">http://example.com/2025/03/30/Mysql-Lock/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">AllimacBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/">数据库基础</a><a class="post-meta__tags" href="/tags/%E9%94%81%E6%9C%BA%E5%88%B6/">锁机制</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/30/Mysql-Index/" title="Mysql-Index"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Mysql-Index</div></div><div class="info-2"><div class="info-item-1">mysql索引部分</div></div></div></a><a class="pagination-related" href="/2025/03/30/ThreadPoolPeek/" title="ThreadPoolPeek"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ThreadPoolPeek</div></div><div class="info-2"><div class="info-item-1">线程池实现原理和应用</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/30/DistributedLocks/" title="DistributedLocks"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">DistributedLocks</div></div><div class="info-2"><div class="info-item-1">分布式锁</div></div></div></a><a class="pagination-related" href="/2025/02/27/JavaWeb-6/" title="JavaWeb-6"><img class="cover" src="https://s21.ax1x.com/2025/02/27/pE3bC5R.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">JavaWeb-6</div></div><div class="info-2"><div class="info-item-1">多表查询&事务&索引入门</div></div></div></a><a class="pagination-related" href="/2025/02/27/JavaWeb-5/" title="JavaWeb-5"><img class="cover" src="https://s21.ax1x.com/2025/02/27/pE3HO2V.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-27</div><div class="info-item-2">JavaWeb-5</div></div><div class="info-2"><div class="info-item-1">数据库设计&操作&多表设计</div></div></div></a><a class="pagination-related" href="/2025/03/30/Mysql-Index/" title="Mysql-Index"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-30</div><div class="info-item-2">Mysql-Index</div></div><div class="info-2"><div class="info-item-1">mysql索引部分</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Allimac</div><div class="author-info-description">华丽的仓库存放着我简陋的思想</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AillemaCc"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/AillemaCc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="http://www.swindle.icu/#/Home" target="_blank" title="曾经的博客"><i class="fas fa-envelope" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是小梦一场的大床</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%94%B1%E6%9D%A5"><span class="toc-number">1.1.</span> <span class="toc-text">锁的由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">锁定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">锁分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">共享锁 排它锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">排它锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-number">2.3.</span> <span class="toc-text">锁的释放</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">全局锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Clustered-Index%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">聚簇索引（Clustered Index）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">行锁的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">4.2.3.</span> <span class="toc-text">示例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">4.2.4.</span> <span class="toc-text">对比全表扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">4.3.</span> <span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">4.4.</span> <span class="toc-text">意向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">4.4.2.</span> <span class="toc-text">分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">5.1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Clustered-Index%EF%BC%89-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">聚簇索引（Clustered Index）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Secondary-Index%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">非聚簇索引（Secondary Index）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">5.1.3.</span> <span class="toc-text">没有其他索引的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="toc-number">5.1.4.</span> <span class="toc-text">示例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81-%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">行锁&#x2F;记录锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">5.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">间隙锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">5.3.1.</span> <span class="toc-text">规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text">临键锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">页面锁，乐观锁与悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">6.1.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">悲观锁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/JavaBasic8Gu/" title="JavaBasic8Gu">JavaBasic8Gu</a><time datetime="2025-04-22T10:30:18.000Z" title="发表于 2025-04-22 18:30:18">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/Hot100-1/" title="Hot100-1">Hot100-1</a><time datetime="2025-04-22T10:22:09.000Z" title="发表于 2025-04-22 18:22:09">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/TechDuck200/" title="TechDuck200">TechDuck200</a><time datetime="2025-04-22T10:20:48.000Z" title="发表于 2025-04-22 18:20:48">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-2/" title="12306Business-2">12306Business-2</a><time datetime="2025-04-22T10:14:27.000Z" title="发表于 2025-04-22 18:14:27">2025-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/22/12306Business-1/" title="12306Business-1">12306Business-1</a><time datetime="2025-04-22T10:10:07.000Z" title="发表于 2025-04-22 18:10:07">2025-04-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Allimac</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>